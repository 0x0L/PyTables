=================================
 What's new in PyTables @VERSION@
=================================

:Author: Francesc Altet i Abad
:Contact: faltet@carabos.com
:Author: Ivan Vilata i Balaguer
:Contact: ivilata@carabos.com


This document details the modifications of PyTables @VERSION@ since PyTables
version 1.4.x.  Its main purpose is help you ensure that your programs will be
runnable when you switch from PyTables 1.x to PyTables @VERSION@.


Migrating from PyTables 1.x to 2.x
==================================

Next are described a series of issues that you must have in mind when
migrating from PyTables 1.x to PyTables 2.x series.


New type system
---------------

In PyTables 2.0 all the data types for leaves are described through a couple
of classes:

- ``Atom``: Describes homogeneous types of the atomic components in ``*Array``
   objects (``Array``, ``CArray``, ``EArray`` and ``VLArray``).

- ``Description``: Describes (possibly nested) heterogeneous types in
  ``Table`` objects.

So, in order to upgrade to the new type system, you must perform the next
replacements:

- ``*Array.stype`` --> ``*Array.atom.type`` (PyTables type)
- ``*Array.type`` --> ``*Array.atom.dtype`` (NumPy type)
- ``*Array.itemsize`` --> ``*Array.atom.itemsize`` (the size of the item)

Furthermore, the PyTables types (previously called "string types") have
changed to better adapt to NumPy conventions.  The next changes have been
applied:

- PyTables types are now written in lower case, so 'Type' becomes 'type'.  For
  example, 'Int64' becomes now 'int64'.

- 'CharType' --> 'string'

- 'Complex32', 'Complex64' --> 'complex64', 'complex128'.  Note that the
  numeric part of a 'complex' type refers now to the *size in bits* of the
  type and not to the precision, as before.

See Appendix I of the Users' Manual on supported data types for more
information on the new PyTables types.


Important changes in ``Atom`` specification
-------------------------------------------

- The ``dtype`` argument of ``EnumAtom`` and ``EnumCol`` constructors
  has been replaced by the ``base`` argument, which can take a
  full-blown atom, although it accepts bare PyTables types as well.
  This is a *mandatory* argument now.

- Finally, ``Atom`` and ``Col`` are now abstract classes, so you can't use
  them to create atoms or column definitions of an arbitrary type.  If you
  know the particular type you need, use the proper subclass; otherwise, use
  the ``Atom.from_*()`` or ``Col.from_*()`` factory methods.  See the section
  on declarative classes in the reference.

  You are also advised to avoid using the inheritance of atoms to check for
  their kind or type; for that purpose, use their ``kind`` and ``type``
  attributes.


New query system
----------------

- In-kernel conditions, since they are based now in Numexpr, must be written
  *as strings*.  For example, a condition that in 1.x was stated as::

      result = [row['col2'] for row in table.where(table.cols.col1 == 1)]

  now should read::

      result = [row['col2'] for row in table.where('col1 == 1')]

  That means that complex selections are possible now::

      result = [ row['col2'] for row in
                 table.where('(col1 == 1) & (col3**4 > 1)') ]

- [Pro] For the same reason, conditions for indexed columns must be written as
  strings as well.


[Pro] New indexing system
-------------------------

The indexing system has been totally rewritten from scratch for PyTables 2.0
Pro Edition (http://www.carabos.com/products/pytables-pro.html).  Due to this,
your existing indexes created with PyTables 1.x will be useless, and although
you will be able to continue using the actual data in files, you won't be able
to take advantage of any improvement in speed.

When using the Pro version you will be offered the possibility to
automatically re-create the indexes in PyTables 1.x format to the new 2.0
format by using the ``ptrepack`` utility.


New meanings for atom shape and ``*Array`` shape argument
---------------------------------------------------------

With PyTables 1.x, the atom shape was used for different goals depending on
the context it was used.  For example, in ``createEArray()``, the shape of the
atom was used to specify the *dataset shape* of the object on disk, while in
``CArray`` the same atom shape was used to specify the *chunk shape* of the
dataset on disk.  Moreover, for ``VLArray`` objects, the very same atom shape
specified the *type shape* of the data type.  As you see, all of these was
quite a mess.

Starting with PyTables 2.x, an ``Atom`` only specifies properties of the data
type (Ã  la ``VLArray`` in 1.x).  This lets the door open for specifying
multidimensional data types (that can be part of another layer of
multidimensional datasets) in a consistent way along all the ``*Array``
objects in PyTables.

As a consequence of this, ``File.createCArray()`` and ``File.createVLArray()``
methods have received new parameters in order to make possible to specify the
shapes of the datasets as well as chunk sizes (in fact, it is possible now to
specify the latter for all the chunked leaves, see below).  Please have this
in mind during the migration process.

Another consequence is that, now that the meaning of the atom shape is clearly
defined, it has been chosen as the main object to describe homogeneous data
types in PyTables.  See the Users' Manual for more info on this.


New argument ``chunkshape`` of chunked leaves
---------------------------------------------

It is possible now to specify the chunk shape for all the chunked leaves in
PyTables (all except ``Array``).  With PyTables 1.x this value was
automatically calculated so as to achieve decent results in most of the
situations.  However, the user may be interested in specifying its own chunk
shape based on her own needs (although this should be done only by advanced
users).

Of course, if this parameter is not specified, a sensible default is
calculated for the size of the leave (which is recommended).

A new attribute called ``chunkshape`` has been added to all leaves.  It is
read-only (you can't change the size of chunks once you have created a leaf),
but it can be useful for inspection by advanced users.


New flavor specification
------------------------

As of 2.0, flavors can *only* be set through the ``flavor`` attribute of
leaves, and they are *persistent*, so changing a flavor requires that the file
be writable.

Flavors can no longer be set through ``File.create*()`` methods, nor the
``flavor`` argument previously found in some ``Table`` methods, nor through
``Atom`` constructors or the ``_v_flavor`` attribute of descriptions.


System attributes can be deleted now
------------------------------------

The protection against removing system attributes (like ``FILTERS``,
``FLAVOR`` or ``CLASS``, to name only a few) has been completely removed.  It
is now the responsibility of the user to make a proper use of this freedom.
With this, users can get rid of all proprietary PyTables attributes if they
want to (for example, for making a file to look more like an HDF5 native one).


Byteorder issues
----------------

Now, all the data coming from reads and internal buffers is always converted
on-the-fly, if needed, to the *native* byteorder.  This represents a big
advantage in terms of speed when operating with objects coming from files that
have been created in machines with a byte ordering different from native.

Besides, all leaf constructors have received a new ``byteorder`` parameter
that allows specifying the byteorder of data on disk.  In particular, a
``_v_byteorder`` entry in a Table description is no longer honored and you
should use the aforementioned ``byteorder`` parameter.


Tunable internal buffer sizes
-----------------------------

You can change the size of the internal buffers for I/O purposes of PyTables
by changing the value of the new public attribute ``nrowsinbuf`` that is
present in all leaves.  By default, this contains a sensible value so as to
achieve a good balance between speed and memory consumption.  Be careful when
changing it, if you don't want to get unwanted results (very slow I/O, huge
memory consumption...).


Changes to module names
-----------------------

If your application is directly accessing modules under the ``tables``
package, you need to know that *the names of all modules are now all in
lowercase*.  This allows one to tell apart the ``tables.Array`` *class* from
the ``tables.array`` *module* (which was also called ``tables.Array`` before).
This includes subpackages like ``tables.nodes.FileNode``.

On top of that, more-or-less independent modules have also been renamed and
some of them grouped into subpackages.  The most important are:

- The ``tables.netcdf3`` subpackage replaces the old ``tables.NetCDF`` module.
- The ``tables.nra`` subpackage replaces the old ``nestedrecords.py`` with the
  implementation of the ``NestedRecArray`` class.

Also, the ``tables.misc`` package includes utility modules which do not depend
on PyTables.


Other changes
-------------

- ``Filters.complib`` is ``None`` for filter properties created with
  ``complevel=0`` (i.e. disabled compression, which is the default).
- 'non-relevant' --> 'irrelevant' (applied to byteorders)
- ``Table.colstypes`` --> ``Table.coltypes``
- ``Table.coltypes`` --> ``Table.coldtypes``
- Added ``Table.coldescr``, dictionary of the ``Col`` descriptions.
- ``Table.colshapes`` has disappeared.  You can get it this way::

       colshapes = dict( (name, col.shape)
                         for (name, col) in table.coldescr.iteritems() )

- ``Table.colitemsizes`` has disappeared.  You can get it this way::

       colitemsizes = dict( (name, col.itemsize)
                            for (name, col) in table.coldescr.iteritems() )

- ``Description._v_totalsize`` --> ``Description._v_itemsize``
- ``Description._v_itemsizes`` and ``Description._v_totalsizes`` have
  disappeared.


API additions
=============

- ``Column.createIndex()`` has received a couple of new parameters:
  ``optlevel`` and ``filters``.  The first one sets the desired quality level
  of the index, while the second one allows the user to specify the filters
  for the index.

- ``Table.indexprops`` has been split into ``Table.indexFilters`` and
  ``Table.autoIndex``.  The later groups the functionality of the old ``auto``
  and ``reindex``.

- The new ``Table.colpathnames`` is a sequence which contains the full
  pathnames of all bottom-level columns in a table.  This can be used to walk
  all ``Column`` objects in a table when used with ``Table.colinstances``.

- The new ``Table.colinstances`` dictionary maps column pathnames to their
  associated ``Column`` or ``Cols`` object for simple or nested columns,
  respectively.  This is similar to ``Table.cols._f_col()``, but faster.

- ``Row`` has received a new ``Row.fetch_all_fields()`` method in order to
  return all the fields in the current row.  This returns a NumPy void scalar
  for each call.

- The new ``tables.restrict_flavors()`` function allows to restrict available
  flavors to a given set.  This can be useful e.g. if you want to force
  PyTables to get NumPy data out of an old, ``numarray``-flavored PyTables
  file even if the ``numarray`` package is installed.

- New ``tables.test(verbose=False, heavy=False)`` high level function for
  interactively running the complete test suite from the Python console.

- Added a ``tables.print_versions()`` for easily getting the versions for all
  the software on which PyTables relies on.


Backward-incompatible changes
=============================

- You can no longer mark a column for indexing in a ``Col`` declaration.  The
  only way of creating an index for a column is to invoke the
  ``createIndex()`` method of the proper column object *after the table has
  been created*.

- Now the ``Table.colnames`` attribute is just a list of the names of
  top-level columns in a table.  You can still get something similar to the
  old structure by using ``Table.description._v_nestedNames``.  See also the
  new ``Table.colpathnames`` attribute.

- The ``File.objects``, ``File.leaves`` and ``File.groups`` dictionaries have
  been removed.  If you still need this functionality, please use the
  ``File.getNode()`` and ``File.walkNodes()`` instead.

- ``Table.removeIndex()`` is no longer available; to remove an index on a
  column, one must use the ``removeIndex()`` method of the associated
  ``Column`` instance.

- ``Column.dirty`` is no longer available.  If you want to check
  column index dirtiness, use ``Column.index.dirty``.

- ``complib`` and ``complevel`` parameters have been removed from
  ``File.createTable()``, ``File.createEArray()``, ``File.createCArray()`` and
  ``File.createVLArray()``.  They were already deprecated in PyTables 1.x.

- The ``shape`` and ``atom`` parameters have been swapped in
  ``File.createCArray()``.  This has been done to be consistent with
  ``Atom()`` definitions (i.e. type comes before and shape after).


Deprecated features
===================

- ``Node._v_rootgroup`` has been removed.  Please use ``node._v_file.root``
  instead.

- The ``Node._f_isOpen()`` and ``Leaf.isOpen()`` methods have been removed.
  Please use the ``Node._v_isopen`` attribute instead (it is much faster).

- The ``File.getAttrNode()``, ``File.setAttrNode()`` and
  ``File.delAttrNode()`` methods have been removed.  Please use
  ``File.getNodeAttr()``, ``File.setNodeAttr()`` and ``File.delNodeAttr()``
  instead.

- ``File.copyAttrs()`` has been removed.  Please use ``File.copyNodeAttrs()``
  instead.

- The ``table[colname]`` idiom is no longer supported.  You can use
  ``table.cols._f_col(column)`` for doing the same.


API refinements
===============

- ``File.createEArray()`` received a new ``shape`` parameter.  This allows to
  not have to use the shape of the atom so as to set the shape of the
  underlying dataset on disk.

- All the leaf constructors have received a new ``chunkshape`` parameter that
  allows specifying the chunk sizes of datasets on disk.

- All ``File.create*()`` factories for ``Leaf`` nodes have received a new
  ``byteorder`` parameter that allows the user to specify the byteorder in
  which data will be written to disk (data in memory is now always handled in
  *native* order).


----

  **Enjoy data!**

  -- The PyTables Team


.. Local Variables:
.. mode: rst
.. coding: utf-8
.. fill-column: 78
.. End:
