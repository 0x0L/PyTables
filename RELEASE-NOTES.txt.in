=================================
 What's new in PyTables @VERSION@
=================================


:Author: Francesc Altet
:Contact: faltet@carabos.com
:Author: Ivan Vilata i Balaguer
:Contact: ivilata@carabos.com


This document details the modifications of PyTables @VERSION@ since PyTables
version 1.x.  Its main purpose is help you ensure that your programs will be
runnable when you switch from PyTables 1.x to PyTables @VERSION@.


Migrating from PyTables 1.x to 2.x
==================================

- Tipus/Atoms/Cols
- Indexs
- Cosultes
- Menors
- Canvis significat shape
- Flavor
- Byteorder

Things to have in mind when migrating from PyTables 1.x to PyTables
2.x series:

- Leaf.stype --> Leaf.type
- Leaf.type --> Leaf.dtype
- "CharType" --> "string"
- "Complex32", "Complex64" --> "complex64", "complex128"
- PyTables types (previously called "string types") are now written in
  lower case, so "Type" becomes "type".  See the appendix on supported
  data types in the manual for more information on PyTables types.
- "non-relevant" --> "irrelevant" (applied to byteorders)
- Table.colstypes --> Table.coltypes
- Table.coltypes --> Table.coldtypes
- Table.colshapes & Table.colitemsizes have disappeared
- Description.itemsize have disappeared
- In-kernel conditions must be written as strings.
- New meanings of atom shape and array shape.
- New argument ``chunkshape`` of chunked arrays.
- ``Atom`` and ``Col`` are now abstract classes, so you can't use them
  to create atoms or column definitions of an arbitrary type.  If you
  know the particular type you need, use the proper subclass;
  otherwise, use the ``Atom.from_*()`` or ``Col.from_*()`` factory
  methods.  See the section on declarative classes in the reference.

  You are also advised to avoid using the inheritance of atoms to
  check for their kind or type; for that purpose, use their ``kind``
  and ``type`` attributes.
- The ``dtype`` argument of ``EnumAtom`` and ``EnumCol`` constructors
  has been replaced by the ``base`` argument, which can take a
  full-blown atom, although it accepts bare PyTables types as well.
  This is a *mandatory* argument now.
- Flavors can *only* be set through the ``flavor`` attribute of
  leaves, and they are *persistent*, so changing a flavor requires
  that the file be writable.

  Flavors can no longer be set through ``File.create*()`` methods, the
  ``flavor`` argument previously found in some ``Table`` methods, nor
  through ``Atom`` constructors or the ``_v_flavor`` attribute of
  descriptions.


API additions
=============

- ``Column.createIndex()`` has received a couple of new parameters:
  ``optlevel`` and ``filters``.  The first one sets the desired quality level
  of the index, while the second one allows the user to specify the filters
  for the index.

- ``Table.indexprops`` has been splitted into ``Table.indexFilters`` and
  ``Table.autoIndex``.  The later groups the functionality of the old ``auto``
  and ``reindex``.

- The new ``Table.colpathnames`` is a sequence which contains the full
  pathnames of all bottom-level columns in a table.  This can be used to walk
  all ``Column`` objects in a table when used with ``Table.colinstances``.

- The new ``Table.colinstances`` dictionary maps column pathnames to their
  associated ``Column`` or ``Cols`` object for simple or nested columns,
  respectively.  This is similar to ``Table.cols._f_col()``, but faster.

- ``File.createEArray()`` received a new ``shape`` parameter.  This allows to
  not have to use the shape of the atom so as to set the shape of the
  underlying dataset (this change was needed for a future use of the atom
  shape as the dimensionality of the atom type).

- ``File.createCArray()`` has received a new ``chunksize`` parameter. This
  allows to not have to use the shape of the atom so as to set the chunksize
  of the underlying dataset (this change was needed for a future use of the
  atom shape as the dimensionality of the atom type).

- All the ``File.create*()`` factories for Leaf creation has received a new
  ``byteorder`` parameter that allows the user to specify the byteorder in
  which the data will be written to disk.


Backward-incompatible changes
=============================

- You can no longer mark a column for indexing in a ``Col`` declaration.  The
  only way of creating an index for a column is to invoke the
  ``createIndex()`` method of the proper column object *after the table has
  been created*.

- Now the ``Table.colnames`` attribute is just a list of the names of
  top-level columns in a table.  You can still get something similar to the
  old structure by using ``Table.description._v_nestedNames``.  See also the
  new ``Table.colpathnames`` attribute.

- The dictionaries File.objects, File.leaves and File.groups has been removed.
  If you need this functionality, please, use the File.getNode() and
  File.walkNodes() instead. (XXX documentar!!!)

- ``Table.removeIndex()`` is no longer available; to remove an index on a
  column, one must use the ``removeIndex()`` method of the associated
  ``Column`` instance.

- ``Column.dirty`` is no longer available.  If you want to check
  column index dirtiness, use ``Column.index.dirty``.

- ``complib`` and ``complevel`` parameters have been removed from
  ``File.createTable``, ``File.createEArray``, ``File.createCArray`` and
  ``File.createVLArray``. They were already deprecated in PyTables 1.x.

- Parameters ``shape`` and ``atom`` has been swapped in
  ``File.createCArray()``. This has been done to be consistent with Atom()
  definitions (i.e. type comes before and shape after).


Deprecated features
===================

- Node._v_rootgroup has been removed. Please use node._v_file.root instead.

- Node._f_isOpen() and Leaf.isOpen() methods has been removed. Use
  Node._v_isopen attribute instead (it is much faster).

- File.getAttrNode(), File.setAttrNode() and File.delAttrNode() have been
  removed. Please use File.getNodeAttr(), File.setNodeAttr() and
  File.delNodeAttr() instead.

- File.copyAttrs() has been removed. Use File.copyNodeAttrs() instead.

- table[colname] idiom has been removed. You can use table.cols._f_col(column)
  for doing the same.


----

  **Enjoy data!**

  -- The PyTables Team


.. Local Variables:
.. mode: rst
.. coding: utf-8
.. fill-column: 78
.. End:
