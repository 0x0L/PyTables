=======================================
 Release notes for PyTables 2.1 series
=======================================

:Author: Francesc Alted i Abad
:Contact: faltet@pytables.org


Changes from 2.1.x to 2.2
=========================

Enhancements
------------

- Added support for NumPy's extended slicing in all `Leaf` objects.
  With that, you can do the next sort of selections::

      array1 = array[4]                       # simple selection
      array2 = array[4:1000:2]                # slice selection
      array3 = array[1, ..., ::2, 1:4, 4:]    # general slice selection
      array4 = array[1, [1,5,10], ..., -1]    # fancy selection
      array5 = array[np.where(array[:] > 4)]  # point selection
      array6 = array[array[:] > 4]            # boolean selection

  Closes #198 and #209.

API changes
-----------

- In order to be consistent and allow the extended slicing to happen
  in `VLArray` objects too, `VLArray.__setitem__()` is not able to
  partially modify rows based on the second dimension passed as key.
  If this is tried, an `IndexError` is raised now.  Closes #210.

- The `forceCSI` flag has been replaced by `checkCSI` in the next
  `Table` methods: `copy()`, `readSorted()` and `itersorted()`.  The
  change reflects the fact that a re-index operation cannot be
  triggered from these methods anymore.  The rational for the change
  is that an indexing operation is a potentially very expensive
  operation that should be carried out explicitely instead of being
  triggered by methods that should not be in charge of this task.
  Closes #216.


Changes from 2.1 to 2.1.1
=========================

Small enhancements
------------------

- `openFile()`, `isHDF5File()` and `isPyTablesFile()` functions accept
  Unicode filenames now.  Closes #202 and #214.

- When creating large type sizes (exceeding 64 KB), HDF5 complained
  and refused to do so.  The HDF5 team has logged the issue as a bug,
  but meanwhile it has been implemented a workaround in PyTables that
  allows to create such large datatypes for situations that does not
  require defaults other than zero.  Addresses #211.

- In order to be consistent with how are stored the other data types,
  Unicode attributes are retrieved now as NumPy scalars instead of
  Python Unicode strings or NumPy arrays.  For the moment, I've fixed
  this through pickling the Unicode strings.  In the future, when HDF5
  1.8.x series would be a requirement, that should be done via a HDF5
  native Unicode type.  Closes #213.

Bug fixes
---------

- Fixed a memory leak when a lot of queries were made.  Closes #203
  and #207.

- The chunkshape="auto" parameter value of `Leaf.copy()` is honored
  now, even when the (start, stop, step) parameters are specified.
  Closes #204.

- Due to a flaw in its design, the `File` class was not able to be
  subclassed.  This has been fixed.  Closes #205.

- Default values were not correctly retrieved when opening already
  created CArray/EArray objects.  Fixed.  Closes #212.

- Fixed a problem with the installation of the ``nctoh5`` script that
  prevented it from being executed.  Closes #215.

- [Pro] The ``iterseq`` cache ignored non-indexed conditions, giving
  wrong results when those appeared in condition expressions.  This
  has been fixed.  Closes #206.

----

  **Enjoy data!**

  -- The PyTables Team


.. Local Variables:
.. mode: rst
.. coding: utf-8
.. fill-column: 72
.. End:
