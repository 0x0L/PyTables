<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:bib="http://bibtexml.org/STSCHEMA" xmlns:adr="http://tbookdtd.sourceforge.net/addressbook" xmlns:ref="http://tbookdtd.sourceforge.net/references" xmlns:index="http://tbookdtd.sourceforge.net/index" xmlns:dimensions="http://tbookdtd.sourceforge.net/dimension-file" xmlns:depths="http://tbookdtd.sourceforge.net/depths-file" xmlns:loc="local" xmlns:CSS="http://www.w3.org/1998/Style/CSS2" xmlns:pref="http://www.w3.org/2002/Math/preference" id="usage"><a name="usage"></a><head>
      <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>PyTables User's Guide</title><meta http-equiv="Content-Type" content="text/html"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="generator" content="The tbook system at http://tbookdtd.sourceforge.net"><meta name="robots" content="index"><meta name="DC.Title" content="PyTables User's Guide"><meta name="DC.Description" content="PyTables User's Guide A hierarchical database for Python Release 0.7.2"><meta name="DC.Creator" content="Francesc Alted"><meta name="Author" content="Francesc Alted"><meta name="DC.Date" content="2003-09-22T13:38:59+02:00"><meta name="Date" content="2003-09-22T13:38:59+02:00"><meta name="DC.Rights" content="(c) 2002, 2003 Francesc Alted"><meta name="Copyright" content="(c) 2002, 2003 Francesc Alted"><meta name="DC.Type" content="Text"><meta name="DC.Format" content="text/html"><meta name="DC.Language" scheme="rfc3066" content="en"><meta name="Language" content="en"><meta http-equiv="Content-Style-Type" content="text/css"><style type="text/css">
    body {
      font-family: serif; text-align: justify;
      margin: 0pt; line-height: 1.3; background-color: white; color: black }
    body.letter { background-image: none }
    h1, h2, h3, h4, h5, h6, div.partheadline, div.title,
      div.title-article {
      font-family: sans-serif; font-weight: bold; font-stretch: condensed;
      text-align: left; }
    h1, h2, h3, h4, h5, h6, div.partheadline { padding-left: 18pt }
    h1 { clear: both }
    h1.toc { clear: none }
    a:link, a:visited, a:active { text-decoration: none }
    a:hover { text-decoration: underline; color: #0066FF; }
    div.document, div.letter { margin-left: 80px; margin-right: 150px;
      padding-top: 3ex; padding-bottom: 5ex }
    div.authorlist { font-family: sans-serif;
      font-stretch: condensed; text-align: left; font-size: x-large;
      margin-bottom: 1ex }
    div.authorlist-article { font-size: x-large; text-align: center;
      margin-bottom: 2ex }
    div.title { font-size: xx-large; color: gray; margin-bottom: 5ex; }
    div.title-article { font-size: xx-large; text-align: center;
      margin-bottom: 1ex }
    div.date-article { font-size: large; text-align: center;
      margin-bottom: 5ex }
    div.subtitle { text-align: left; margin-bottom: 3ex }
    div.legal { text-align: right }
    div.legalnotice { margin-top: 3ex; text-align: left }
    div.partheadline { font-size: xx-large; margin-top: 1ex; margin-bottom: 1ex }
    div.footnote { }
    hr.footnoterule { text-align: left; width: 20%; color: black }
    div.mathdisplay { text-align: center;
    margin-top: 2ex; margin-bottom: 2ex }
    div.figure, div.table, div.mathml-remark { margin-bottom: 3ex;
            margin-top: 2ex}
    div.mathml-remark { width: 50%; text-align: left; text-indent: 0pt }
    div.caption { margin-top: 1ex; width: 20em}
    div.caption-text { font-size: small;
      padding-left: 1em; text-indent: -1em; text-align: left}
    caption { max-width: 100%; min-width: 200px; margin-bottom: 1ex;
      text-align: left }
    div.verse { white-space: pre; margin-left: 2em;
      margin-top: 2ex; margin-bottom: 2ex }
    div.toc { margin-bottom: 6ex }
    div.biblio { }
    div.index { width: 100% }
    div.aphorism { margin-bottom: 2ex; font-style: italic; text-align: right;
      margin-left: 50%}
    div.aphorism-origin { margin-top: 1ex }
    div.letter { }
    div.subject { margin-top: 3ex; margin-bottom: 3ex }
    div.opening { margin-top: 3ex; margin-bottom: 3ex }
    div.closing { margin-top: 3ex; text-align: right }
    div.to { margin-top: 3ex; margin-bottom: 3ex }
    span.subject { font-weight: bold }
    div.speedbar-top, div.speedbar-bottom { margin-left: 1em; margin-right: 1em }
    div.speedbar-top { margin-top: 2ex }
    div.speedbar-bottom { margin-bottom: 3ex }
    table.speedbar { width: 100% }
    hr.speedbar { clear: both }
    div.theorem-plain, div.theorem-definition, div.theorem-remark { margin-top: 2ex;
      margin-bottom: 2ex }
    div.theorem-plain { font-style: italic }
    div.proof { margin-top: 2ex; margin-bottom: 2ex }
    span.theorem-head-plain, span.theorem-head-definition, span.theorem-head-remark
      { margin-right: 0.66em }
    span.theorem-head-plain, span.theorem-head-definition
      { font-style: normal; font-weight: bold }
    span.theorem-head-remark { font-style: italic }
    span.proof-head { font-style: italic; margin-right: 0.66em }
    acronym { font-size: 95%; letter-spacing: 0.1em; text-transform: uppercase }
    td.header { text-align: center; font-weight: bold }
    table.toc { }
    table.tabular { font-size: smaller }
    td.thickline { height: 0pt; border-bottom: medium solid; padding: 2px }
    td.thinline { height: 0pt; border-bottom: thin solid;   padding: 2px }
     /* FixMe: Following definition Still bad */
    div.part-toc { margin-top: 2ex; font-weight: bold; font-size: larger }
     /* FixMe: Following definition: How cleaner? */
    div.toplevel-toc { margin-top: 1ex; font-weight: bold }
    td.number1 { width: 1.5em }
    td.number2 { width: 2em }
    td.number3 { width: 3em }
    td.author { text-align: center; width: 50% }
    div { }  /* Must remain empty! */
    span.captionlabel { font-family: sans-serif; font-weight: bold;
      margin-right: 0.66em }
    span.captionlabel:after { content: " " }
    b.captionlabel {  }
    b.captionlabel:after { content: " " }
    span.headlinenumber { margin-right: 0.66em }
    tt.verb {font-family: monospace }
    span.bibtag { font-weight: bold; margin-right: 1em }
    span.bib-author { }
    span.bib-lastname { font-variant: small-caps }
    span.bib-title { font-style: italic }
    span.bib-booktitle { }
    span.bib-journal { }
    span.bib-journal-volume { font-weight: bold }
    span.bib-publisher { }
    span.bib-school { }
    span.bib-year { }
    span.bib-note { }
    span { } /* Muss leer bleiben! */
    li.bibitem { margin-left: 1em; text-indent: -1em }
    img.graphics { border: 0pt }
    p,div.p { margin: 0pt; text-indent: 18pt }
    ul, dl, ol { text-indent: 0pt; }
    p.first, div.p-first { margin: 0pt; text-indent: 0pt }
    p.bibitem { margin-top: 1.5ex; margin-left: 3em; text-indent: -3em }
    ul.biblio { list-style: none }
    mi.ch { font-style: normal }
    math[display="block"], div.equation {
      margin-top: 1ex; margin-bottom: 1ex }
    div.i-lettergroup { font-size: larger; font-weight: bold; padding-left: 18pt;
      margin-top: 3ex; margin-bottom: 1.5ex }
    div.i-item { }
    div.i-main { }
    dt { display: compact; font-weight: bold }
    dd { text-indent: 0pt }
    pre { text-indent: 0pt }
    span.i-see { font-style: italic; }

h1 { color: red }
h2 { color: olive }
h3 { color: navy }
h4 { color: maroon }
body { background-image: url("tile.jpg");
         background-color: white;
         color: black;
	 font-size: 13pt; }
hr.footnoterule { color: white }
div.title { font-size: x-large; color: maroon }
div.subtitle { font-size: x-large; color: olive }
div.title-article { font-size: x-large }
div.partheadline { font-size: x-large }
</style></head><body><div class="speedbar-top"><table class="speedbar"><tbody><tr><td style="text-align: left; width: 15%"><a href="usersguide2.html">previous</a></td><td style="text-align: center"><a href="usersguide.html#tb:table-of-contents">Table of Contents</a></td><td style="text-align: right; width: 15%"><a href="usersguide4.html">next</a></td></tr><tr><td colspan="3">&nbsp;</td></tr></tbody></table><hr class="speedbar"></div><div class="document"><div id="usage"><a name="usage"></a>
      <h1 id="chapter3"><a name="chapter3"></a>Chapter&nbsp;3: Some tutorials</h1>

      <div class="aphorism">Tout le malheur des hommes vient d'une seule chose,
	qui est de ne savoir pas demeurer en repos, dans une chambre.
	<div class="aphorism-origin">&#8212;Blaise Pascal</div>
      </div>

      <p class="first">This chapter begins with a series of simple, yet
	comprehensive sections written in a tutorial style that will
	let you understand the main features that
	<tt class="verb">PyTables</tt> provide. If during the trip you want
	more information on some specific instance variable, global
	function or method, look at the doc strings or go to the
	library reference in <a href="usersguide4.html#libraryReference">chapter&nbsp;4</a>. However, if you are
	reading this in PDF or HTML formats, there should be an
	hyperlink to its reference near each newly introduced
	entity.
      </p>

      <p>Please, note that throughout this document the terms
	<em>column</em> and <em>field</em> will be used
	interchangeably with the same meaning, and the same goes for
	the terms <em>row</em> and <em>record</em>.
      </p>

      <div>
	<h2 id="section3.1"><span class="headlinenumber"><a name="section3.1"></a>3.1 </span>Getting started</h2>

	<p class="first">In this section, we will see how to define our own records
	  from Python and save collections of them (i.e. a <b>table</b>) on a file. Then, we will select
	  some data in the table using Python cuts, creating
	  <tt class="verb">numarray</tt> arrays to keep this selection as
	  separate objects in the tree.
	</p>
	<p>
	  In <em>examples/tutorial1-1.py</em> you will find the
	  working version of all the code in this
	  section. Nonetheless, this tutorial series has been written
	  to allow you reproduce it in a Python interactive
	  console. You are encouraged to take advantage of that by
	  doing parallel testing and inspecting the created objects
	  (variables, docs, children objects, etc.) during the
	  voyage!.
	</p>

	<div>
	  <h3 id="subsection3.1.1"><span class="headlinenumber"><a name="subsection3.1.1"></a>3.1.1 </span>Importing <tt>tables</tt>
	    objects</h3>
	  
	  <p class="first">Before doing anything you need to import the
	    public objects in the <tt class="verb">tables</tt> package. You
	    normally do that by issuing:
	  </p>
	  <pre>
&gt;&gt;&gt; import tables
&gt;&gt;&gt;
	  </pre>
	  <p>This is the recommended way to import <tt class="verb">tables</tt>
	    if you don't want to pollute too much your
	    namespace. However, <tt class="verb">PyTables</tt> has a very
	    reduced set of first-level primitives, so you may consider
	    to use this alternative:
	  </p>
	  <pre>
&gt;&gt;&gt; from tables import *
&gt;&gt;&gt;
	  </pre>
	  <p>that will export in your caller application namespace the
	    next objects: <tt class="verb">openFile</tt>, <tt class="verb">isHDF5</tt>,
	    <tt class="verb">isPyTablesFile</tt> and
	    <tt class="verb">IsDescription</tt>. These are a rather small number
	    of objects, and for convenience, we will use this last way
	    to access them.
	  </p>
	  <p>If you are going to deal with <tt class="verb">numarray</tt> or
	    <tt class="verb">Numeric</tt> arrays (and normally, you will) you
	    also need to import some objects from it. You can do that
	    in the normal way. So, to access to <tt class="verb">PyTables</tt>
	    functionality normally you should start you programs with:
	  </p>
	  <pre>
&gt;&gt;&gt; import tables        # but in this tutorial we use "from tables import *"
&gt;&gt;&gt; from numarray import *  # or "from Numeric import *"
&gt;&gt;&gt;
	  </pre>
	</div>

	<div>
	  <h3 id="subsection3.1.2"><span class="headlinenumber"><a name="subsection3.1.2"></a>3.1.2 </span>Declaring a Column Descriptor</h3>

	  <p class="first">Now, imagine that we have a particle detector and we want
	    to create a table object in order to save data that comes
	    from it. You need first to define that table, how many
	    columns it have, which kind of object is each element on
	    the columns, and so on.
	  </p>
	  <p>Our detector has a TDC (Time to Digital Converter)
	    counter with a dynamic range of 8 bits and an ADC
	    (Analogic to Digital Converter) with a range of 16
	    bits. For these values, we will define 2 fields in our
	    record object called <tt class="verb">TDCcount</tt> and
	    <tt class="verb">ADCcount</tt>. We also want to save the grid
	    position in which the particle has been detected and we
	    will add two new fields called <tt class="verb">grid_i</tt> and
	    <tt class="verb">grid_j</tt>. Our instrumentation also can obtain
	    the pressure and energy of this particle that we want to
	    add in the same way. The resolution of pressure-gauge
	    allows us to use simple-precision float which will be
	    enough to save <tt class="verb">pressure</tt> information, while
	    <tt class="verb">energy</tt> would need a double-precision
	    float. Finally, to track this particle we want to assign
	    it a name to inform about the kind of the particle and a
	    number identifier unique for each particle. So we will add
	    a couple of fields: <tt class="verb">name</tt> will be the a string
	    of up-to 16 characters and because we want to deal with a
	    really huge number of particles, <tt class="verb">idnumber</tt>
	    will be an integer of 64 bits.
	  </p>
	  <p>With all of that, we can declare a new
	    <tt class="verb">Particle</tt> class that will keep all this info:
	  </p>

	  <pre>
&gt;&gt;&gt; class Particle(IsDescription):
...     name      = StringCol(16)   # 16-character String
...     idnumber  = Int64Col()      # Signed 64-bit integer
...     ADCcount  = UInt16Col()     # Unsigned short integer
...     TDCcount  = UInt8Col()      # unsigned byte
...     grid_i    = Int32Col()      # integer
...     grid_j    = IntCol()        # integer (equivalent to Int32Col)
...     pressure  = Float32Col()    # float  (single-precision)
...     energy    = FloatCol()      # double (double-precision)
...
&gt;&gt;&gt;
	  </pre>
	  <p>This definition class is quite
	    auto-explanatory. Basically, you have to declare a class
	    variable for each field you need, and as its value we
	    assign a subclass instance of the <tt class="verb">Col</tt> class,
	    that describes the kind of column (the data type, the
	    length, the shape, ...). See <a href="usersguide4.html#ColClassDescr">section&nbsp;4.3</a> for a complete
	    description of these subclasses. See also <a href="usersguide6.html#datatypesSupported">appendix&nbsp;A</a> for a list of
	    data types supported in <tt class="verb">Col</tt> constructors.
	  </p>
	  <p>From now on, we can use <tt class="verb">Particle</tt> instances
	    as a descriptor for our detector data table. We will see
	    how to pass this object to the <tt class="verb">Table</tt>
	    constructor. But first, we must create a file where all
	    the actual data pushed into <tt class="verb">Table</tt> will be
	    saved.
	  </p>

	</div>

	<div>
	  <h3 id="subsection3.1.3"><span class="headlinenumber"><a name="subsection3.1.3"></a>3.1.3 </span>Creating a <tt>PyTables</tt> file from scratch</h3>

	  <p class="first">To create a <tt class="verb">PyTables</tt> file use the
	    first-level <tt class="verb">openFile</tt> (see <a href="#openFileDescr"><strong>??</strong></a>) function:
	  </p>

	  <pre>
&gt;&gt;&gt; h5file = openFile("tutorial1.h5", mode = "w", title = "Test file")
	  </pre>
	  <p>This <tt class="verb">openFile</tt> (<a href="#openFileDescr">see&nbsp;<strong>??</strong></a>) is one of the objects
	    imported by the "<tt class="verb">from tables import *</tt>", do
	    you remember?. Here, we are telling that we want to create
	    a new file called "<tt class="verb">tutorial1.h5</tt>" in
	    "<tt class="verb">w</tt>"rite mode and with an descriptive title
	    string ("<tt class="verb">Test file</tt>"). This function tries to
	    open the file, and if successful, returns a
	    <tt class="verb">File</tt> (<a href="usersguide4.html#FileClassDescr">see&nbsp;4.4</a>)
	    instance which hosts the root of the object tree on its
	    <tt class="verb">root</tt> attribute.
	  </p>
	</div>

	<div>
	  <h3 id="subsection3.1.4"><span class="headlinenumber"><a name="subsection3.1.4"></a>3.1.4 </span>Creating a new group</h3>

	  <p class="first">Now, to better organize our data, we will create a group
	    hanging from the root called <em>detector</em>. We will
	    use this group to save our particle data there.
	  </p>
	  <pre>
&gt;&gt;&gt; group = h5file.createGroup("/", 'detector', 'Detector information')
&gt;&gt;&gt;
	  </pre>

	  <p>Here, we have taken the <tt class="verb">File</tt> instance
	    <tt class="verb">h5file</tt> and invoked its
	    <tt class="verb">createGroup</tt> method (<a href="usersguide4.html#createGroupDescr">see&nbsp;4.4.2</a>), telling that we want
	    to create a new group called <em>detector</em> hanging
	    from "<em>/</em>", which is other way to refer to the
	    <tt class="verb">h5file.root</tt> object we mentioned before. This
	    will create a new <tt class="verb">Group</tt> (see<a href="usersguide4.html#GroupClassDescr">4.5</a>) instance that will be
	    assigned to the <tt class="verb">group</tt> variable.
	  </p>

	</div>
	<div>
	  <h3 id="subsection3.1.5"><span class="headlinenumber"><a name="subsection3.1.5"></a>3.1.5 </span>Creating a new table</h3>

	  <p class="first">Let's now create the <tt class="verb">Table</tt> (see <a href="usersguide4.html#TableClassDescr">4.7</a>) object hanging from the new
	    created group. We do that by calling the
	    <tt class="verb">createTable</tt> (see <a href="#createTableDescr"><strong>??</strong></a>) method from the
	    <tt class="verb">h5file</tt> object:
	  </p>
	  <pre>
&gt;&gt;&gt; table = h5file.createTable(group, 'readout', Particle, "Readout example")
&gt;&gt;&gt;
	  </pre>

	  <p>Look at how we asked to create the <tt class="verb">Table</tt>
	    instance hanging from <tt class="verb">group</tt>, with name
	    "<em>readout</em>". We have passed <tt class="verb">Particle</tt>,
	    the class that we have declared before, as the
	    <em>description</em> parameter and finally we have used
	    "<em>Readout example</em>" as a <tt class="verb">Table</tt>
	    title. With all this information, a new <tt class="verb">Table</tt>
	    instance is created and assigned to <em>table</em>
	    variable.
	  </p>

	  <p>If you are getting curious how the object tree looks like
	    at this moment, simply print the name of the
	    <tt class="verb">File</tt> instance, <em>h5file</em>, and look at
	    their output:
	  </p>

	  <pre>
&gt;&gt;&gt; print h5file
Filename: 'tutorial1.h5' Title: 'Test file' Last modif.: 'Sun Jul 27 14:00:13 2003'
/ (Group) 'Test file'
/detector (Group) 'Detector information'
/detector/readout (Table(0,)) 'Readout example'

&gt;&gt;&gt;
	  </pre>

	  <p>As you can see, a dump of the object tree has been shown
	    and it's very easy to visualize the <tt class="verb">Group</tt> and
	    <tt class="verb">Table</tt> objects we have just created. If you
	    want more information, just type the name of the
	    <tt class="verb">File</tt> instance:
	  </p>

	  <pre>
&gt;&gt;&gt; h5file
&gt;&gt;&gt; h5file
Filename: 'tutorial1.h5' Title: 'Test file' Last modif.: 'Sun Jul 27 14:00:13 2003'
/ (Group) 'Test file'
/detector (Group) 'Detector information'
/detector/readout (Table(0,)) 'Readout example'

&gt;&gt;&gt; h5file
File(filename='tutorial1.h5', title='Test file', mode='w', trMap={}, rootUEP='/')
/ (Group) 'Test file'
/detector (Group) 'Detector information'
/detector/readout (Table(0,)) 'Readout example'
  description := {
    "ADCcount": Col('UInt16', shape=1, itemsize=2, dflt=0),
    "TDCcount": Col('UInt8', shape=1, itemsize= 1, dflt=0),
    "energy": Col('Float64', shape=1, itemsize=8, dflt=0.0),
    "grid_i": Col('Int32', shape=1, itemsize=4, dflt=0),
    "grid_j": Col('Int32', shape=1, itemsize=4, dflt=0),
    "idnumber": Col('Int64', shape=1, itemsize=8, dflt=0),
    "name": Col('CharType', shape=1, itemsize=16, dflt=None),
    "pressure": Col('Float32', shape=1, itemsize=4, dflt=0.0) }
  byteorder := little

&gt;&gt;&gt;
	  </pre>

	  <p>where more detailed info is printed on each object on the
	    tree. Pay attention on how <tt class="verb">Particle</tt>, our
	    table descriptor class, is printed as part of the
	    <em>readout</em> table description information. In
	    general, you can obtain lot of information on the objects
	    and its children by just printing them. That introspection
	    capability is very meaningful, so I recommend you to use it
	    extensively.
	  </p>

	  <p>Now, time to fill this table with some values. But first,
	    we are going to get a pointer to the <tt class="verb">Row</tt>
	    instance of this <tt class="verb">table</tt> instance:
	  </p>
	  <pre>
&gt;&gt;&gt; particle = table.row
&gt;&gt;&gt;
	  </pre>

	  <p>The <tt class="verb">row</tt> attribute of <tt class="verb">table</tt>
	    points to the <tt class="verb">Row</tt> (see <a href="usersguide4.html#RowClassDescr">4.8</a>) instance that will be used
	    to input data rows into the table. We achieve this by just
	    assigning it the values for each row as if it was a
	    dictionary (although it is actually an <em>extension
	    class</em>) and using the column names as keys.
	  </p>

	  <p>Look at how the filling process works like:
	  </p>

	  <pre>
&gt;&gt;&gt; particle = table.row
&gt;&gt;&gt; for i in xrange(10):
...     particle['name']  = 'Particle: %6d' % (i)
...     particle['TDCcount'] = i % 256
...     particle['ADCcount'] = (i * 256) % (1 &lt;&lt; 16)
...     particle['grid_i'] = i
...     particle['grid_j'] = 10 - i
...     particle['pressure'] = float(i*i)
...     particle['energy'] = float(particle['pressure'] ** 4)
...     particle['idnumber'] = i * (2 ** 34)
...     particle.append()
...
&gt;&gt;&gt;
	  </pre>
	  
	  <p>This code should be easy to understand. The lines inside
	    the loop just assign values to the different columns in
	    the <tt class="verb">particle</tt> Row instance (<a href="usersguide4.html#RowClassDescr">see&nbsp;4.8</a>) and then a call to its
	    <tt class="verb">append()</tt> method is made to put this
	    information in the <tt class="verb">table</tt> I/O buffer.
	  </p>

	  <p>After we have pushed all our data, we should flush the
	    I/O buffer for the table if we want to consolidate all
	    this data on disk. We can achieve that by calling the
	    <tt class="verb">table.flush()</tt> method.
	  </p>
	  <pre>
&gt;&gt;&gt; table.flush()
&gt;&gt;&gt;
	  </pre>

	</div>

	<div id="readingAndSelectingUsage"><a name="readingAndSelectingUsage"></a>
	  <h3 id="subsection3.1.6"><span class="headlinenumber"><a name="subsection3.1.6"></a>3.1.6 </span>Reading (and selecting) data in table</h3>

	  <p class="first">Ok. We have now our data on disk but to this data be
	    useful we need to access it and select some values we are
	    interested in and located at some specific columns. That's
	    is easy to do:
	  </p>
	  <pre>
&gt;&gt;&gt; table = h5file.root.detector.readout
&gt;&gt;&gt; pressure = [ x['pressure'] for x in table.iterrows()
...              if x['TDCcount']&gt;3 and 20&lt;=x['pressure']&lt;50 ]
&gt;&gt;&gt; pressure
[25.0, 36.0, 49.0]
&gt;&gt;&gt;
	  </pre>

	  <p>The first line is only to declare a convenient shortcut
	    to the <em>readout</em> table which is a bit deeper on the
	    object tree. As you can see, we have used the <b>natural naming</b> schema to access
	    it. We could also have used the
	    <tt class="verb">h5file.getNode()</tt> method instead, and we
	    will certainly do that later on.
	  </p>

	  <p>You will recognize the last two lines to be a Python list
	    comprehension. It loops over rows in <em>table</em> as
	    they are provided by <tt class="verb">table.iterrows()</tt>
	    iterator (see <a href="#iterrowsDescr"><strong>??</strong></a>) that
	    returns values until data in table is exhausted. These
	    rows are filtered using the expression <tt class="verb">x['TDCcount']
	    &gt; 3 and x['pressure'] &lt; 50</tt>, and the
	    <tt class="verb">pressure</tt> field for satisfying records is
	    selected to form the final list that is assigned to
	    <tt class="verb">pressure</tt> variable.
	  </p>

	  <p>We could indeed have used a normal <tt class="verb">for</tt> loop
	    to do that, but I find comprehension syntax to be more
	    compact and elegant.
	  </p>

	  <p>Let's select the names for the same set of cuts:
	  </p>

	  <pre>
&gt;&gt;&gt; names=[ x['name'] for x in table if x['TDCcount']&gt;3 and 20&lt;=x['pressure']&lt;50 ]
&gt;&gt;&gt; names
['Particle:      5', 'Particle:      6', 'Particle:      7']
&gt;&gt;&gt;
	  </pre>

	  <p>Note how we have omitted the <tt class="verb">iterrows()</tt> call
	    in the list comprehension. This is because the
	    <tt class="verb">Table</tt> class has an implementation of the
	    special method called <tt class="verb">__iter__()</tt>, so that it
	    implements the iterator protocol over all the rows in the
	    table. In fact, <tt class="verb">iterrows()</tt> internally calls
	    this special <tt class="verb">__iter__()</tt> method. This way to
	    access all the rows in a table turns out to be very
	    convenient, specially for interactive use.
	  </p>

	  <p>Ok. that's enough for selections. Next section will show
	    you how to save these selections on file.
	  </p>

	</div>

	<div>
	  <h3 id="subsection3.1.7"><span class="headlinenumber"><a name="subsection3.1.7"></a>3.1.7 </span>Creating new array objects</h3>

	  <p class="first">In order to separate the selected data from the detector
	    data, we will create a new group, called
	    <tt class="verb">columns</tt> hanging from the root group:
	  </p>

	  <pre>
&gt;&gt;&gt; gcolumns = h5file.createGroup(h5file.root, "columns", "Pressure and Name")
&gt;&gt;&gt;
	  </pre>

	  <p>Note that this time we have specified the first parameter
	    in a <em>natural naming</em> fashion
	    (<tt class="verb">h5file.root</tt>) instead of using an absolute
	    path string ("/").
	  </p>

	  <p>Now, create one <tt class="verb">Array</tt> object:
	  </p>

	  <pre>
&gt;&gt;&gt; h5file.createArray(gcolumns, 'pressure', array(pressure),
...                     "Pressure column selection")
/columns/pressure (Array(3,)) 'Pressure column selection'
  type = Float64
  itemsize = 8
  flavor = 'NumArray'
  byteorder = 'little'
&gt;&gt;&gt;
	  </pre>

	  <p>We already know the first two parameters of the
	    <tt class="verb">createArray</tt> (see <a href="#createArrayDescr"><strong>??</strong></a>) methods (these are the
	    same as the firsts in <tt class="verb">createTable</tt>): they are
	    the parent group <em>where</em> <tt class="verb">Array</tt> will be
	    created and the <tt class="verb">Array</tt> instance
	    <em>name</em>. You can figure out that the fourth
	    parameter is the <em>title</em>. And in the third position
	    we have the <em>object</em> we want to save on disk. In
	    this case, it is a <tt class="verb">Numeric</tt> array that is
	    built from the selection lists we created before.
	  </p>

	  <p>Now, we are going to save the other selection. In this
	    case it's a list of strings, and we want to save this
	    object as is, with no further conversion. Look at how this
	    can be done:
	  </p>

	  <pre>
&gt;&gt;&gt; h5file.createArray(gcolumns, 'name', names, "Name column selection")
/columns/name Array(4,) 'Name column selection'
  type = 'CharType'
  itemsize = 16
  flavor = 'List'
  byteorder = 'little'
&gt;&gt;&gt;
	  </pre>

	  <p>You see, <tt class="verb">createArray()</tt> accepts
	    <em>names</em> (which is a regular Python list) as
	    <em>object</em> parameter. Actually, it accepts a variety
	    of other regular objects (see <a href="#createArrayDescr"><strong>??</strong></a>). We will check that we can
	    retrieve exactly the same object from disk later on.
	  </p>
	  <p>Note that in this examples, <tt class="verb">createArray</tt>
	    method returns an <tt class="verb">Array</tt> instance that is not
	    assigned to any variable. Don't worry, this was
	    intentional because I wanted to show you the kind of
	    object we have created by showing its
	    representation. Indeed, the <tt class="verb">Array</tt> objects has
	    been attached to the object tree and saved on disk, as you
	    can see if you print the complete object tree:
	  </p>
	  <pre>
&gt;&gt;&gt; print h5file
Filename: 'tutorial1.h5' Title: 'Test file' Last modif.: 'Sun Jul 27 14:00:13 2003'
/ (Group) 'Test file'
/columns (Group) 'Pressure and Name'
/columns/name (Array(3,)) 'Name column selection'
/columns/pressure (Array(3,)) 'Pressure column selection'
/detector (Group) 'Detector information'
/detector/readout (Table(10,)) 'Readout example'

&gt;&gt;&gt;	  
	  </pre>
	</div>

	<div>
	  <h3 id="subsection3.1.8"><span class="headlinenumber"><a name="subsection3.1.8"></a>3.1.8 </span>Closing the file and looking at its content</h3>

	  <p class="first">To finish this first tutorial, we use the
	    <tt class="verb">close</tt> method of the h5file <tt class="verb">File</tt>
	    instance to close the file before exiting Python:
	  </p>
	  <pre>
&gt;&gt;&gt; h5file.close()
&gt;&gt;&gt; ^D
	  </pre>

	  <p>With all that, you have created your first
	    <tt class="verb">PyTables</tt> file with a table and two
	    arrays. That was easy, admit it. Now, you can have a look
	    at it with some generic HDF5 tool, like
	    <tt class="verb">h5dump</tt> or <tt class="verb">h5ls</tt>. Here is the
	    result of passing to <tt class="verb">h5ls</tt> the
	    <tt class="verb">tutorial1.h5</tt> file:
	  </p>
	  <pre>
$ h5ls -rd tutorial1.h5
/columns                 Group
/columns/name            Dataset {3}
    Data:
        (0) "Particle:      5", "Particle:      6", "Particle:      7"
/columns/pressure        Dataset {3}
    Data:
        (0) 25, 36, 49
/detector                Group
/detector/readout        Dataset {10/Inf}
    Data:
        (0) {0, 0, 0, 0, 10, 0, "Particle:      0", 0},
        (1) {256, 1, 1, 1, 9, 17179869184, "Particle:      1", 1},
        (2) {512, 2, 256, 2, 8, 34359738368, "Particle:      2", 4},
        (3) {768, 3, 6561, 3, 7, 51539607552, "Particle:      3", 9},
        (4) {1024, 4, 65536, 4, 6, 68719476736, "Particle:      4", 16},
        (5) {1280, 5, 390625, 5, 5, 85899345920, "Particle:      5", 25},
        (6) {1536, 6, 1679616, 6, 4, 103079215104, "Particle:      6", 36},
        (7) {1792, 7, 5764801, 7, 3, 120259084288, "Particle:      7", 49},
        (8) {2048, 8, 16777216, 8, 2, 137438953472, "Particle:      8", 64},
        (9) {2304, 9, 43046721, 9, 1, 154618822656, "Particle:      9", 81}
	  </pre>

	  <p>or, using the "dumpFile.py" <tt class="verb">PyTables</tt> utility
	    (located in <tt class="verb">examples/</tt> directory):
	  </p>

	  <pre>
$ python dumpFile.py tutorial1.h5
Filename: 'tutorial1.h5' Title: 'Test file' Last modif.: 'Sun Jul 27 14:40:51 2003'
/ (Group) 'Test file'
/columns (Group) 'Pressure and Name'
/columns/name (Array(3,)) 'Name column selection'
/columns/pressure (Array(3,)) 'Pressure column selection'
/detector (Group) 'Detector information'
/detector/readout (Table(10,)) 'Readout example'

	  </pre>

	  <p>You can pass the <tt class="verb">-v</tt> or <tt class="verb">-d</tt>
	    options to <tt class="verb">dumpFile.py</tt> if you want more
	    verbosity. Try them out!.
	  </p>
	</div>
      </div>

      <div>
	<h2 id="section3.2"><span class="headlinenumber"><a name="section3.2"></a>3.2 </span>Browsing the <i>object tree</i>
	  and more</h2>

	<p class="first">In this section, we will learn how to browse the tree while
	  retrieving meta-information about the actual data, and will
	  finish by appending some rows to the existing table to show
	  how table objects can be enlarged.
	</p>
	<p>
	  In <em>examples/tutorial1-2.py</em> you will find the
	  working version of all the code in this section. As before,
	  you are encouraged to use a python shell and inspect the
	  object tree during the voyage.
	</p>

	<div>
	  <h3 id="subsection3.2.1"><span class="headlinenumber"><a name="subsection3.2.1"></a>3.2.1 </span>Traversing the object tree</h3>

	  <p class="first">First of all, let's open the file we have recently
	    created in last tutorial section, as we will take it as a
	    basis for this section:
	  </p>

	  <pre>
&gt;&gt;&gt; h5file = openFile("tutorial1.h5", "a")
	  </pre>

	  <p>This time, we have opened the file in "a"ppend mode. We
	    are using this mode because we want to add more
	    information to the file.
	  </p>
	  <p><tt class="verb">PyTables</tt>, following the Python tradition,
	    offers powerful introspection capabilities, i.e. you can
	    easily ask information about any component of the object
	    tree as well as traverse the tree searching for something.
	  </p>
	  <p>To start with, you can get a first glance image of the
	    object tree, by simply printing the existing
	    <tt class="verb">File</tt> instance:
	  </p>

	  <pre>
&gt;&gt;&gt; print h5file
Filename: 'tutorial1.h5' Title: 'Test file' Last modif.: 'Sun Jul 27 14:40:51 2003'
/ (Group) 'Test file'
/columns (Group) 'Pressure and Name'
/columns/name (Array(3,)) 'Name column selection'
/columns/pressure (Array(3,)) 'Pressure column selection'
/detector (Group) 'Detector information'
/detector/readout (Table(10,)) 'Readout example'

&gt;&gt;&gt;
	  </pre>

	  <p>That's right, it seems that all our objects are
	    there. Now, let's make use of the File iterator to see how
	    to list all the nodes in the object tree:
	  </p>

	  <pre>
&gt;&gt;&gt; for node in h5file:
...   print node
...
/ (Group) 'Test file'
/columns (Group) 'Pressure and Name'
/detector (Group) 'Detector information'
/columns/name (Array(3,)) 'Name column selection'
/columns/pressure (Array(3,)) 'Pressure column selection'
/detector/readout (Table(10,)) 'Readout example'
&gt;&gt;&gt;
	  </pre>
	  
	  <p>We can use the <tt class="verb">walkGroups</tt> method (see <a href="#walkGroupsDescr"><strong>??</strong></a>) of <tt class="verb">File</tt> class
	    to list only the <em>groups</em> on tree:
	  </p>

	  <pre>
&gt;&gt;&gt; for group in h5file.walkGroups("/"):
...   print group
...
/ (Group) 'Test file'
/columns (Group) 'Pressure and Name'
/detector (Group) 'Detector information'
&gt;&gt;&gt;
	  </pre>

	  <p>Note that <tt class="verb">walkGroups()</tt> actually returns an
	    <em>iterator</em>, not a list of objects. Combining this
	    iterator with the <tt class="verb">listNodes()</tt> method, we can
	    do very powerful things. Let's see an example listing all
	    the arrays in the tree:
	  </p>

	  <pre>
&gt;&gt;&gt; for group in h5file.walkGroups("/"):
...     for array in h5file.listNodes(group, classname = 'Array'):
...         print array
...
/columns/name Array(4,) 'Name column selection'
/columns/pressure Array(4,) 'Pressure column selection'
	  </pre>

	  <p><tt class="verb">listNodes()</tt> (see <a href="#listNodesDescr"><strong>??</strong></a>) returns a list containing
	    all the nodes hanging from a specific <tt class="verb">Group</tt>,
	    and if <em>classname</em> keyword is specified, the method
	    will filter all instances which are not descendants of
	    it. We have specified it to solely return
	    <tt class="verb">Array</tt> instances.
	  </p>

	  <p>We can combine both calls by using the
	      <tt class="verb">__call__(where, classname)</tt> special method
	      of <tt class="verb">File</tt> (<a href="#__callFileDescr">see&nbsp;<strong>??</strong></a>), i.e.:
	  </p>

	  <pre>
&gt;&gt;&gt; for array in h5file("/", "Array"):
...   print array
...
/columns/name (Array(3,)) 'Name column selection'
/columns/pressure (Array(3,)) 'Pressure column selection'
&gt;&gt;&gt;
	  </pre>

	  <p>which is a nice shortcut for doing interactive work.</p>

	  <p>As a final example, we will list all the
	    <tt class="verb">Leaf</tt>, i.e. <tt class="verb">Table</tt> and
	    <tt class="verb">Array</tt> instances (see <a href="usersguide4.html#LeafClassDescr">4.6</a> for detailed information on
	    <tt class="verb">Leaf</tt> class), in <tt class="verb">/detector</tt>
	    group. Check that only one instance of <tt class="verb">Table</tt>
	    class (i.e. <tt class="verb">readout</tt>) will be selected in this
	    group (as it should be):
	  </p>

	  <pre>
&gt;&gt;&gt; for leaf in h5file.root.detector('Leaf'):
...   print leaf
...
/detector/readout (Table(10,)) 'Readout example'
&gt;&gt;&gt; 
	  </pre>

	  <p>where we have used a call to the
	    <tt class="verb">Group.__call__(classname, recursive)</tt> special
	    method (<a href="#__callGroupDescr"><strong>??</strong></a>), combined
	    with a <em>natural naming</em> path specification.</p>

	  <p>Of course you can do more sophisticated node selections
	    using these powerful methods, but first, we need to
	    learn a bit about some important instance variables of
	    <tt class="verb">PyTables</tt> objects.
	  </p>

	</div>

	<div>
	  <h3 id="subsection3.2.2"><span class="headlinenumber"><a name="subsection3.2.2"></a>3.2.2 </span>Setting and getting user attributes</h3>

	  <p class="first">PyTables provides an easy and concise way to complement
	    the meaning of your node objects on the tree by using the
	    <tt class="verb">AttributeSet</tt> class (see <a href="usersguide4.html#AttributeSetClassDescr">section&nbsp;4.10</a>). You can
	    access to this object through the standard attribute
	    <tt class="verb">attrs</tt> in <tt class="verb">Leaf</tt> nodes and
	    <tt class="verb">_v_attrs</tt> in <tt class="verb">Group</tt> nodes.
	  </p>

	  <p>For example, let's imagine that we want to save the date
	    indicating when the data in <tt class="verb">/detector/readout</tt>
	    table has been acquired, as well as the temperature during
	    the gathering process. That is easy:
	  </p>

	  <pre>
&gt;&gt;&gt; table = h5file.root.detector.readout
&gt;&gt;&gt; table.attrs.gath_date = "Wed, 06/12/2003 18:33"
&gt;&gt;&gt; table.attrs.temperature = 18.4
&gt;&gt;&gt; table.attrs.temp_scale = "Celsius"
&gt;&gt;&gt;
	  </pre>

	  <p>Now, set a somewhat more complex attribute in the
	    <tt class="verb">/detector</tt> group:
	  </p>

	  <pre>
&gt;&gt;&gt; detector = h5file.root.detector
&gt;&gt;&gt; detector._v_attrs.stuff = [5, (2.3, 4.5), "Integer and tuple"]
&gt;&gt;&gt;
	  </pre>

	  <p>Note how the AttributeSet instance is accessed with
	    <tt class="verb">_v_attrs</tt> because detector is a
	    <tt class="verb">Group</tt> node. In general, you can save any
	    standard Python data structure as an attribute node, but
	    see <a href="usersguide4.html#AttributeSetClassDescr">section&nbsp;4.10</a> for
	    a more detailed explanation of how this are serialized on
	    disk.
	  </p>

	  <p>Now, getting the attributes is equally easy:
	  </p>

	  <pre>
&gt;&gt;&gt; table.attrs.gath_date
'Wed, 06/12/2003 18:33'
&gt;&gt;&gt; table.attrs.temperature
18.399999999999999
&gt;&gt;&gt; table.attrs.temp_scale
'Celsius'
&gt;&gt;&gt; detector._v_attrs.stuff
[5, (2.2999999999999998, 4.5), 'Integer and tuple']
&gt;&gt;&gt;
	  </pre>

	  <p>You can probably guess how to delete attributes:
	  </p>

	  <pre>
&gt;&gt;&gt; del table.attrs.gath_date
	  </pre>

	  <p>If you want to have a look at the current attribute set
	  of <tt class="verb">/detector/table</tt>, you can print its
	  representation (try also hitting the <tt class="verb">TAB</tt> key
	  twice if you are on a Unix Python console with the
	  <tt class="verb">rlcompleter</tt> module active):
	  </p>

	  <pre>
&gt;&gt;&gt; table.attrs
/detector/readout (AttributeSet), 14 attributes:
   [CLASS := 'TABLE',
    FIELD_0_NAME := 'ADCcount',
    FIELD_1_NAME := 'TDCcount',
    FIELD_2_NAME := 'energy',
    FIELD_3_NAME := 'grid_i',
    FIELD_4_NAME := 'grid_j',
    FIELD_5_NAME := 'idnumber',
    FIELD_6_NAME := 'name',
    FIELD_7_NAME := 'pressure',
    NROWS := 10,
    TITLE := 'Readout example',
    VERSION := '2.0',
    tempScale := 'Celsius',
    temperature := 18.399999999999999]
&gt;&gt;&gt;
	  </pre>

	  <p>You can get a list only the user or system attributes
	    with the <tt class="verb">_v_list()</tt> method.
	  </p>

	  <pre>
&gt;&gt;&gt; print table.attrs._f_list("user")
['temp_scale', 'temperature']
&gt;&gt;&gt; print table.attrs._f_list("sys")
['CLASS', 'FIELD_0_NAME', 'FIELD_1_NAME', 'FIELD_2_NAME', 'FIELD_3_NAME',
 'FIELD_4_NAME', 'FIELD_5_NAME', 'FIELD_6_NAME', 'FIELD_7_NAME', 'NROWS',
 'TITLE', 'VERSION']
&gt;&gt;&gt;
	  </pre>

	  <p>And rename attributes:
	  </p>

	  <pre>
&gt;&gt;&gt; table.attrs._f_rename("temp_scale","tempScale")
&gt;&gt;&gt; print table.attrs._f_list()
['tempScale', 'temperature']
&gt;&gt;&gt;
	  </pre>

	  <p>However, you can't set, delete or rename read-only
	    attributes:
	  </p>

	  <pre>
&gt;&gt;&gt; table.attrs._f_rename("VERSION", "version")
Traceback (most recent call last):
  File "&gt;stdin&gt;", line 1, in ?
  File "/home/falted/PyTables/pytables-0.7/tables/AttributeSet.py", line 249, in _f_rename
    raise RuntimeError, \
RuntimeError: Read-only attribute ('VERSION') cannot be renamed
&gt;&gt;&gt;
	  </pre>

	  <p>After your session, you can check that the
	  <tt class="verb">/detector/readout</tt> attributes in disk looks like:
	  </p>

	  <pre>
$ h5ls -vr tutorial1.h5/detector/readout
Opened "tutorial1.h5" with sec2 driver.
/detector/readout        Dataset {10/Inf}
    Attribute: CLASS     scalar
        Type:      6-byte null-terminated ASCII string
        Data:  "TABLE"
    Attribute: VERSION   scalar
        Type:      4-byte null-terminated ASCII string
        Data:  "2.0"
    Attribute: TITLE     scalar
        Type:      16-byte null-terminated ASCII string
        Data:  "Readout example"
    Attribute: FIELD_0_NAME scalar
        Type:      9-byte null-terminated ASCII string
        Data:  "ADCcount"
    Attribute: FIELD_1_NAME scalar
        Type:      9-byte null-terminated ASCII string
        Data:  "TDCcount"
    Attribute: FIELD_2_NAME scalar
        Type:      7-byte null-terminated ASCII string
        Data:  "energy"
    Attribute: FIELD_3_NAME scalar
        Type:      7-byte null-terminated ASCII string
        Data:  "grid_i"
    Attribute: FIELD_4_NAME scalar
        Type:      7-byte null-terminated ASCII string
        Data:  "grid_j"
    Attribute: FIELD_5_NAME scalar
        Type:      9-byte null-terminated ASCII string
        Data:  "idnumber"
    Attribute: FIELD_6_NAME scalar
        Type:      5-byte null-terminated ASCII string
        Data:  "name"
    Attribute: FIELD_7_NAME scalar
        Type:      9-byte null-terminated ASCII string
        Data:  "pressure"
    Attribute: tempScale scalar
        Type:      8-byte null-terminated ASCII string
        Data:  "Celsius"
    Attribute: temperature {1}
        Type:      native double
        Data:  18.4
    Attribute: NROWS     {1}
        Type:      native int
        Data:  10
    Location:  0:1:0:1952
    Links:     1
    Modified:  2003-07-24 13:59:19 CEST
    Chunks:    {2048} 96256 bytes
    Storage:   470 logical bytes, 96256 allocated bytes, 0.49% utilization
    Type:      struct {
                   "ADCcount"         +0    native unsigned short
                   "TDCcount"         +2    native unsigned char
                   "energy"           +3    native double
                   "grid_i"           +11   native int
                   "grid_j"           +15   native int
                   "idnumber"         +19   native long long
                   "name"             +27   16-byte null-terminated ASCII string
                   "pressure"         +43   native float
               } 47 bytes
 

	  </pre>


	  <p>As you can see, the use of attributes can be a good
	    mechanism to add persistent (meta) information to your
	    actual data. Be sure to use them extensively.
	  </p>

	</div>

	<div>
	  <h3 id="subsection3.2.3"><span class="headlinenumber"><a name="subsection3.2.3"></a>3.2.3 </span>Getting object metadata</h3>

	  <p class="first">Each object in <tt class="verb">PyTables</tt> has
	    <em>metadata</em> information about the actual data on the
	    file. Normally this <em>metainformation</em> is accessible
	    through the node instance variables. Let's have a look at
	    some examples:
	  </p>

	  <pre>
&gt;&gt;&gt; print "Object:", table
Object: /detector/readout Table(10,) 'Readout example'
&gt;&gt;&gt; print "Table name:", table.name
Table name: readout
&gt;&gt;&gt; print "Table title:", table.title
Table title: Readout example
&gt;&gt;&gt; print "Number of rows in table:", table.nrows
Number of rows in table: 10
&gt;&gt;&gt; print "Table variable names with their type and shape:"
Table variable names with their type and shape:
&gt;&gt;&gt; for name in table.colnames:
...   print name, ':= %s, %s' % (table.coltypes[name], table.colshapes[name])
...
ADCcount := UInt16, 1
TDCcount := UInt8, 1
energy := Float64, 1
grid_i := Int32, 1
grid_j := Int32, 1
idnumber := Int64, 1
name := CharType, 1
pressure := Float32, 1
&gt;&gt;&gt;
	  </pre>

	  <p>
	    Here, the <tt class="verb">name</tt>, <tt class="verb">title</tt>,
	    <tt class="verb">nrows</tt>, <tt class="verb">colnames</tt>,
	    <tt class="verb">coltypes</tt> and <tt class="verb">colshapes</tt>
	    attributes (see <a href="usersguide4.html#FileInstanceVariablesDescr">4.4.1</a> for a complete
	    attribute list) of <tt class="verb">Table</tt> object give us quite
	    a lot of information about actual table data.
	  </p>

	  <p>In general, you can get up-to-the-minute information
	    about the public objects in PyTables in a interactive way
	    by printing its internal doc strings:
	  </p>

	  <pre>
&gt;&gt;&gt; print table.__doc__
Represent a table in the object tree.

    It provides methods to create new tables or open existing ones, as
    well as to write/read data to/from table objects over the
    file. A method is also provided to iterate over the rows without
    loading the entire table or column in memory.

    Data can be written or read both as Row() instances or as numarray
    (NumArray or RecArray) objects.
    
    Methods:
    
      Common to all leaves:
        close()
        flush()
        getAttr(attrname)
        rename(newname)
        remove()
        setAttr(attrname, attrvalue)
        
      Specific of Table:
        iterrows()
        read([start] [, stop] [, step] [, field [, flavor]])
        removeRows(start, stop)

    Instance variables:
    
      Common to all leaves:
        name -- the leaf node name
        hdf5name -- the HDF5 leaf node name
        title -- the leaf title
        shape -- the leaf shape
        byteorder -- the byteorder of the leaf
        
      Specific of Table:
        description -- the metaobject describing this table
        row -- a reference to the Row object associated with this table
        nrows -- the number of rows in this table
        rowsize -- the size, in bytes, of each row
        colnames -- the field names for the table (list)
        coltypes -- the type class for the table fields (dictionary)
        colshapes -- the shapes for the table fields (dictionary)

&gt;&gt;&gt;
	  </pre>

	  <p>This is very handy if you don't have this manual at
	    hand. Try yourself with other objects docs, like for example:
	  </p>

	  <pre>
&gt;&gt;&gt; help(table.__class__)
&gt;&gt;&gt; help(table.removeRows)
	  </pre>

	  <p>Now, print some metadata in <em>/columns/pressure</em>
	    <tt class="verb">Array</tt> object:
	  </p>

	  <pre>
&gt;&gt;&gt; pressureObject = h5file.getNode("/columns", "pressure")
&gt;&gt;&gt; print "Info on the object:", repr(pressureObject)
Info on the object: /columns/pressure (Array(3,)) 'Pressure column selection'
  type = Float64
  itemsize = 8
  flavor = 'NumArray'
  byteorder = 'little'
&gt;&gt;&gt; print "  shape: ==&gt;", pressureObject.shape
  shape: ==&gt; (3,)
&gt;&gt;&gt; print "  title: ==&gt;", pressureObject.title
  title: ==&gt; Pressure column selection
&gt;&gt;&gt; print "  type: ==&gt;", pressureObject.type
  type: ==&gt; Float64
&gt;&gt;&gt;
	  </pre>

	  <p>Observe how we have used the <tt class="verb">getNode()</tt>
	    method of <tt class="verb">File</tt> class to access a node in the
	    tree, instead of the natural naming method. Both are
	    useful, and depending on the context you will prefer to
	    use one or another. <tt class="verb">getNode()</tt> has the
	    advantage that it can get a node from the pathname string
	    (like in this example), and, besides, you can force a
	    filter so that the node in that location has to be a
	    <em>classname</em> instance. However, I consider natural
	    naming to be more elegant and quicker to specify,
	    specially if you are using the name completion capability
	    present in interactive console. I suggest to give a try at
	    this powerful combination of natural naming and completion
	    capabilities present on most Python consoles. You will see
	    how pleasant can be browsing the object tree (well, as
	    long as this activity can be qualified in that way).
	  </p>
	  <p>If you look at the <tt class="verb">type</tt> attribute of the
	    <tt class="verb">pressureObject</tt>, you can certify that this is
	    a "<b>Float64</b>" array, and that
	    by looking at their <tt class="verb">shape</tt> attribute, it can
	    deduced that the array on disk is unidimensional and has 4
	    elements. See <a href="usersguide4.html#ArrayClassInstanceVariables">4.9.1</a> or the internal
	    string docs for the complete <tt class="verb">Array</tt> attribute
	    list.
	  </p>
	</div>

	<div>
	  <h3 id="subsection3.2.4"><span class="headlinenumber"><a name="subsection3.2.4"></a>3.2.4 </span>Reading actual data from <tt>Array</tt> objects</h3>

	  <p class="first">Once you have found the desired <tt class="verb">Array</tt> and
	    decided that you want to retrieve the actual data array
	    from it, you should use the <tt class="verb">read()</tt> method of
	    the <tt class="verb">Array</tt> object:</p>

	  <pre>
&gt;&gt;&gt; pressureArray = pressureObject.read()
&gt;&gt;&gt; pressureArray
array([ 25.,  36.,  49.])
&gt;&gt;&gt; print "pressureArray is an object of type:", type(pressureArray)
pressureArray is an object of type: &lt;class 'numarray.numarraycore.NumArray'&gt;
&gt;&gt;&gt; nameArray = h5file.root.columns.name.read()
&gt;&gt;&gt; nameArray
['Particle:      5', 'Particle:      6', 'Particle:      7']
&gt;&gt;&gt; print "nameArray is an object of type:", type(nameArray)
nameArray is an object of type: &lt;type 'list'&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; print "Data on arrays nameArray and pressureArray:"
Data on arrays nameArray and pressureArray:
&gt;&gt;&gt; for i in range(pressureObject.shape[0]):
...   print nameArray[i], "--&gt;", pressureArray[i]
...
Particle:      5 --&gt; 25.0
Particle:      6 --&gt; 36.0
Particle:      7 --&gt; 49.0
&gt;&gt;&gt; pressureObject.name
'pressure'
&gt;&gt;&gt; 
	  </pre>

	  <p>You can verify as the <tt class="verb">read()</tt> method (see
	    <a href="#readArrayDescr">section&nbsp;<strong>??</strong></a>) returns an authentic
	    <tt class="verb">numarray</tt> object for the
	    <tt class="verb">pressureObject</tt> instance by looking at the
	    output of the <tt class="verb">type()</tt> call, while for the
	    <tt class="verb">nameObject</tt> instance <tt class="verb">read()</tt>
	    returns a native Python list (of strings). This is because
	    the type of the object saved is kept as an HDF5 attribute
	    (named <tt class="verb">FLAVOR</tt>) for these objects on
	    disk. This attribute is then read as part of the
	    <tt class="verb">Array</tt> metainformation and accessible through
	    the <tt class="verb">Array.attrs.FLAVOR</tt> variable, enabling the
	    read array to be converted into the original object. This
	    provides a means to save a large variety of objects as
	    arrays with the guarantee that you will be able to recover
	    them in its original form afterwards. See <a href="#createArrayDescr">section&nbsp;<strong>??</strong></a> for a complete list
	    of supported objects for <tt class="verb">Array</tt>.
	  </p>

	</div>

	<div>
	  <h3 id="subsection3.2.5"><span class="headlinenumber"><a name="subsection3.2.5"></a>3.2.5 </span>Appending data to an existing table</h3>

	  <p class="first">Now, let's have a look at how we can add records to an
	    existing on-disk table. Let's use our well-known
	    <em>readout</em> <tt class="verb">Table</tt> instance and let's
	    append some new values to it:
	  </p>

	  <pre>
&gt;&gt;&gt; table = h5file.root.detector.readout
&gt;&gt;&gt; particle = table.row
&gt;&gt;&gt; for i in xrange(10, 15):
...     particle['name']  = 'Particle: %6d' % (i)
...     particle['TDCcount'] = i % 256
...     particle['ADCcount'] = (i * 256) % (1 &lt;&lt; 16)
...     particle['grid_i'] = i
...     particle['grid_j'] = 10 - i
...     particle['pressure'] = float(i*i)
...     particle['energy'] = float(particle['pressure'] ** 4)
...     particle['idnumber'] = i * (2 ** 34)
...     particle.append()
...
&gt;&gt;&gt; table.flush()
&gt;&gt;&gt;
	  </pre>

	  <p>That works exactly in the same way than filling a new
	    table. <tt class="verb">PyTables</tt> knows that this table is on
	    disk, and when you add new records, they are appended to
	    the end of the table<a href="#footnote3" name="footnoteback3"><sup title="Note that you can append not only scalar values to tables, but also fully multidimensional array objects.">3)</sup></a>.
	  </p>
	  <p>
	    If you look carefully at the code you will see that we
	    have used the <tt class="verb">table.row</tt> attribute so as to
	    access a table row and fill it up with the new values.
	    Each time that its <tt class="verb">append()</tt> method is called,
	    the actual row is committed to the output buffer and the
	    row pointer is incremented to point to the next table
	    record. When the buffer is full, the data is saved on
	    disk, and the buffer is reused again for the next cycle.
	  </p>

	  <p><b>Caveat emptor</b>!: Do not
	    forget to always call the .flush() method after a writing
	    operation; else your tables will not be fully
	    updated!.</p>

	  <p>Let's have a look at some columns of the resulting table:
	  </p>

	  <pre>
&gt;&gt;&gt; for r in table.iterrows():
...     print "%-16s | %11.1f | %11.4g | %6d | %6d | %8d |" % \
...        (r['name'], r['pressure'], r['energy'], r['grid_i'], r['grid_j'],
...         r['TDCcount'])
...
...
Particle:      0 |         0.0 |           0 |      0 |     10 |        0 |
Particle:      1 |         1.0 |           1 |      1 |      9 |        1 |
Particle:      2 |         4.0 |         256 |      2 |      8 |        2 |
Particle:      3 |         9.0 |        6561 |      3 |      7 |        3 |
Particle:      4 |        16.0 |   6.554e+04 |      4 |      6 |        4 |
Particle:      5 |        25.0 |   3.906e+05 |      5 |      5 |        5 |
Particle:      6 |        36.0 |    1.68e+06 |      6 |      4 |        6 |
Particle:      7 |        49.0 |   5.765e+06 |      7 |      3 |        7 |
Particle:      8 |        64.0 |   1.678e+07 |      8 |      2 |        8 |
Particle:      9 |        81.0 |   4.305e+07 |      9 |      1 |        9 |
Particle:     10 |       100.0 |       1e+08 |     10 |      0 |       10 |
Particle:     11 |       121.0 |   2.144e+08 |     11 |     -1 |       11 |
Particle:     12 |       144.0 |     4.3e+08 |     12 |     -2 |       12 |
Particle:     13 |       169.0 |   8.157e+08 |     13 |     -3 |       13 |
Particle:     14 |       196.0 |   1.476e+09 |     14 |     -4 |       14 |
	  </pre>

	</div>
	<div>
	  <h3 id="subsection3.2.6"><span class="headlinenumber"><a name="subsection3.2.6"></a>3.2.6 </span>And finally... how to remove rows from a table</h3>

	  <p class="first">Let's starting finishing this tutorial by deleting some
	    rows from the table we have. Suppose that we want to
	    delete the rows from 5th to 9th (inclusive). That's very
	    easy to do:
	  </p>

	  <pre>
&gt;&gt;&gt; table.removeRows(5,10)
5
&gt;&gt;&gt;
	  </pre>

	  <p><tt class="verb">removeRows(start, stop)</tt> (<a href="#removeRowsDescr">see&nbsp;<strong>??</strong></a>) deletes the rows in
	      the range (start, stop). It returns the number of rows
	      effectively removed.
	  </p>

	  <p>We have reached the end of this first tutorial. But, ei!,
	    do not forget to close the file after you finish all the
	    work:
	  </p>

	  <pre>
&gt;&gt;&gt; h5file.close()
&gt;&gt;&gt; ^D
$ 
	  </pre>

	  <p>In <a href="#tutorial1-tableview">figure&nbsp;3.1</a> you can
	    see a graphical view of the <tt class="verb">PyTables</tt> file,
	    with the datasets we have just created. And in <a href="#tutorial1-general">figure&nbsp;3.2</a> you can see the
	    general properties of the table
	    <tt class="verb">/detector/readout</tt>.
	  </p>

	  <div class="figure" id="tutorial1-tableview"><a name="tutorial1-tableview"></a>
	    <a target="_blank" href="tutorial1-tableview.jpg"><img class="graphics" width="" height="" alt="The final version of data file for tutorial... (Click for original bitmap)" src="tutorial1-tableview-web.jpg"></a>
	    <div class="caption" style="width: 200px"><div class="caption-text"><span class="captionlabel">Figure&nbsp;3.1:</span> The final version of data file for tutorial 1,
	    with a view of the data objects.
	    </div></div>
	  </div>

	  <div class="figure" id="tutorial1-general"><a name="tutorial1-general"></a>
	    <a target="_blank" href="tutorial1-general.jpg"><img class="graphics" width="" height="" alt="General properties of the /detector/readout... (Click for original bitmap)" src="tutorial1-general-web.jpg"></a>
	    <div class="caption" style="width: 200px"><div class="caption-text"><span class="captionlabel">Figure&nbsp;3.2:</span> General properties of the <tt>/detector/readout</tt> table.
	    </div></div>
	  </div>

	</div>

      </div>

      <div id="secondExample"><a name="secondExample"></a>
	<h2 id="section3.3"><span class="headlinenumber"><a name="section3.3"></a>3.3 </span>Multidimensional table cells and automatic
	  sanity checks</h2>

	<p class="first">Now, time for a more real life example (i.e. with errors in
	  code). Here, we will create a couple of groups hanging
	  directly from <tt class="verb">root</tt> called
	  <tt class="verb">Particles</tt> and <tt class="verb">Events</tt>. Then, we
	  will put 3 tables in each group; in <tt class="verb">Particles</tt>
	  we will put tables based on <tt class="verb">Particle</tt> descriptor
	  and in <tt class="verb">Events</tt>, tables based <tt class="verb">Event</tt>
	  descriptor.
	</p>
	<p>
	  After that, we will feed the tables with a number of
	  records. Finally, we will read the recently created table
	  <tt class="verb">/Events/TEvent3</tt> and select some values from it
	  using a comprehension list.
	</p>
	<p>Look at the next script (you can find it in
	  <tt class="verb">examples/tutorial2.py</tt>). It seems to do all of
	  that, but a couple of small bugs will be shown up. Note that
	  this <tt class="verb">Particle</tt> class is not directly related
	  with the one defined in last example; this one is simpler
	  (but notice the <em>multidimensional</em> columns called
	  <tt class="verb">pressure</tt> and <tt class="verb">temperature</tt>!). And we
	  will introduce a new manner to describe a <tt class="verb">Table</tt>
	  as a dictionary, as you can see in the <tt class="verb">Event</tt>
	  description. See section <a href="#createTableDescr"><strong>??</strong></a> about the different kinds of
	  descriptor objects that can be passed to the
	  <tt class="verb">createTable()</tt> method.
	</p>

	<pre>
from numarray import *
from tables import *

# Describe a particle record
class Particle(IsDescription):
    name        = StringCol(length=16) # 16-character String
    lati        = IntCol()             # integer
    longi       = IntCol()             # integer
    pressure    = Float32Col(shape=(2,3)) # array of floats (single-precision)
    temperature = FloatCol(shape=(2,3))   # array of doubles (double-precision)

# Another way to describe the columns of a table
Event = {
    "name"    : Col('CharType', 16),    # 16-character String
    "TDCcount": Col("UInt8", 1),        # unsigned byte
    "ADCcount": Col("UInt16", 1),       # Unsigned short integer
    "xcoord"  : Col("Float32", 1),      # integer
    "ycoord"  : Col("Float32", 1),      # integer
    }

# Open a file in "w"rite mode
fileh = openFile("tutorial2.h5", mode = "w")
# Get the HDF5 root group
root = fileh.root
# Create the groups:
for groupname in ("Particles", "Events"):
    group = fileh.createGroup(root, groupname)
# Now, create and fill the tables in Particles group
gparticles = root.Particles
# Create 3 new tables
for tablename in ("TParticle1", "TParticle2", "TParticle3"):
    # Create a table
    table = fileh.createTable("/Particles", tablename, Particle,
                           "Particles: "+tablename)
    # Get the record object associated with the table:
    particle = table.row
    # Fill the table with 257 particles
    for i in xrange(257):
        # First, assign the values to the Particle record
        particle['name'] = 'Particle: %6d' % (i)
        particle['lati'] = i 
        particle['longi'] = 10 - i
        ########### Detectable errors start here. Play with them!
        particle['pressure'] = array(i*arange(2*3), shape=(2,4))  # Incorrect
        #particle['pressure'] = array(i*arange(2*3), shape=(2,3))  # Correct
        ########### End of errors
        particle['temperature'] = (i**2)     # Broadcasting
        # This injects the Record values
        particle.append()      
    # Flush the table buffers
    table.flush()

# Now, go for Events:
for tablename in ("TEvent1", "TEvent2", "TEvent3"):
    # Create a table in Events group
    table = fileh.createTable(root.Events, tablename, Event,
                           "Events: "+tablename)
    # Get the record object associated with the table:
    event = table.row
    # Fill the table with 257 events
    for i in xrange(257):
        # First, assign the values to the Event record
        event['name']  = 'Event: %6d' % (i)
        event['TDCcount'] = i % (1&lt;&lt;8)   # Correct range
        ########### Detectable errors start here. Play with them!
        #event['xcoord'] = float(i**2)   # Correct spelling
        event['xcoor'] = float(i**2)     # Wrong spelling
        event['ADCcount'] = i * 2        # Correct type
        #event['ADCcount'] = "s"          # Wrong type
        ########### End of errors
        event['ycoord'] = float(i)**4
        # This injects the Record values
        event.append()

    # Flush the buffers
    table.flush()

# Read the records from table "/Events/TEvent3" and select some
table = root.Events.TEvent3
e = [ p['TDCcount'] for p in table
      if p['ADCcount'] &lt; 20 and 4 &lt;= p['TDCcount'] &lt; 15 ]
print "Last record ==&gt;", p
print "Selected values ==&gt;", e
print "Total selected records ==&gt; ", len(e)
# Finally, close the file (this also will flush all the remaining buffers!)
fileh.close()
	</pre>

	<div>
	  <h3 id="subsection3.3.1"><span class="headlinenumber"><a name="subsection3.3.1"></a>3.3.1 </span>Shape checking</h3>

	  <p class="first">If you have read the code carefully it looks pretty good,
	    but it won't work. When you run this example, you will get
	    the next error:</p>

	<pre>
$ python tutorial2.py
Traceback (most recent call last):
  File "tutorial2.py", line 53, in ?
    particle['pressure'] = array(i*arange(2*3), shape=(2,4))  # Incorrect
  File "/usr/local/lib/python2.2/site-packages/numarray/numarraycore.py", line 281, in array
    a.setshape(shape)
  File "/usr/local/lib/python2.2/site-packages/numarray/generic.py", line 530, in setshape
    raise ValueError("New shape is not consistent with the old shape")
ValueError: New shape is not consistent with the old shape
	</pre>

	  <p>which is saying that you are trying to assign an array of
	    incompatible shape to a table cell. If you look at the
	    source, we were trying to assign an array of shape
	    <tt class="verb">(2,4)</tt> to a pressure<tt class="verb"></tt> element,
	    which was defined to have a shape of
	    <tt class="verb">(2,3)</tt>.
	  </p>
	  <p>In general, this kind of operations are forbidden, with
	    a honorable exception: when you tries to assign an
	    <em>scalar</em> value to a column cell that is
	    multidimensional, all the cell elements are populated with
	    the value of this scalar. This happens in the next line:
	  </p>

	  <pre>
        particle['temperature'] = (i**2)    # Broadcasting
	  </pre>

	  <p>So, the value <tt class="verb">i**2</tt> is assigned to all the
	    elements of the <tt class="verb">temperature</tt> table cell. This
	    capability is provided by the <tt class="verb">numarray</tt>
	    package and is known as <em>broadcasting</em>.
	  </p>

	</div>

	<div>
	  <h3 id="subsection3.3.2"><span class="headlinenumber"><a name="subsection3.3.2"></a>3.3.2 </span>Field name checking</h3>

	  <p class="first">After fixing the previous error, and re-running again the
	  program, we will get another one:
	  </p>
	  <pre>
$ python tutorial2.py
Traceback (most recent call last):
  File "tutorial2.py", line 74, in ?
    event['xcoor'] = float(i**2)     # Wrong spelling
  File "/home/falted/PyTables/pytables-0.7/src/hdf5Extension.pyx",
 line 1812, in hdf5Extension.Row.__setitem__
    raise AttributeError, "Error setting \"%s\" attr.\n %s" % \
AttributeError: Error setting "xcoor" attr.
 Error was: "exceptions.KeyError: xcoor"
	  </pre>

	  <p>This error is telling us that we tried to assign a value to
	    a non-existent field in the <em>event</em> table
	    object. By looking carefully at the <tt class="verb">Event</tt>
	    class attributes, we see that we misspelled the
	    <tt class="verb">xcoord</tt> field (we wrote <tt class="verb">xcoor</tt>
	    instead). This is very unusual in Python because if you
	    try to assign a value to a non-existent instance variable,
	    a new one is created with that name. Such a feature is not
	    satisfactory when we are dealing with an object that has
	    fixed list of field names. So, a check is made inside
	    PyTables so that if you try to assign a value to a
	    non-existing field a <tt class="verb">KeyError</tt> is raised.
	  </p>

	</div>

	<div>
	  <h3 id="subsection3.3.3"><span class="headlinenumber"><a name="subsection3.3.3"></a>3.3.3 </span>Data type checking</h3>

	  <p class="first">Finally, in order to test the type checking, we will change
	    the next line:
	  </p>
	  <pre>
	    event.ADCcount = i * 2        # Correct type
	  </pre>

	  <p>to read:</p>

	  <pre>
	    event.ADCcount = "s"          # Wrong type
	  </pre>

	  <p>After this modification, the next exception will be
	    raised when the script is executed:
	  </p>

	  <pre>
$ python tutorial2.py
Traceback (most recent call last):
  File "tutorial2.py", line 76, in ?
    event['ADCcount'] = "s"          # Wrong type
  File "/home/falted/PyTables/pytables-0.7/src/hdf5Extension.pyx", line 1812, in hdf5Extension.Row.__setitem__
    raise AttributeError, "Error setting \"%s\" attr.\n %s" % \
AttributeError: Error setting "ADCcount" attr.
 Error was: "exceptions.TypeError: NA_setFromPythonScalar: bad value type."
	  </pre>

	  <p>that states the kind of error (<tt class="verb">TypeError</tt>).
	  </p>

	  <p>You can admire the structure we have created with this
	    (corrected) script in <a href="#tutorial2">figure&nbsp;3.3</a>.
	    In particular, pay attention to the multidimensional
	    column cells in table <tt class="verb">/Particles/TParticle2</tt>.
	  </p>

	  <div class="figure" id="tutorial2"><a name="tutorial2"></a>
	    <a target="_blank" href="tutorial2-tableview.jpg"><img class="graphics" width="" height="" alt="Table hierarchy for tutorial 2. (Click for original bitmap)" src="tutorial2-tableview-web.jpg"></a>
	    <div class="caption" style="width: 200px"><div class="caption-text"><span class="captionlabel">Figure&nbsp;3.3:</span> Table hierarchy for tutorial 2.</div></div>
	  </div>

	  <p>Feel free to visit the rest of examples in directory
	    <tt class="verb">examples</tt>, and try to understand them. I've
	    tried to make several use cases to give you an idea of the
	    <tt>PyTables</tt> capabilities and its
	    way of dealing with HDF5 objects.
	  </p>

	</div>
      </div>
    </div><hr align="left" noshade="true" class="footnoterule"><div class="footnote"><a name="footnote3" href="#footnoteback3"><sup>3)</sup></a>&nbsp;Note that you can append not
	    only scalar values to tables, but also fully
	    multidimensional array objects.</div></div><div class="speedbar-bottom"><hr class="speedbar"><table class="speedbar"><tbody><tr><td style="text-align: left; width: 15%"><a href="usersguide2.html">previous</a></td><td style="text-align: center"><a href="usersguide.html#tb:table-of-contents">Table of Contents</a></td><td style="text-align: right; width: 15%"><a href="usersguide4.html">next</a></td></tr></tbody></table></div></body></html>