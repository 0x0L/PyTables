<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>PyTables User's Guide</title><meta http-equiv="Content-Type" content="text/html"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="generator" content="The tbook system at http://tbookdtd.sourceforge.net"><meta name="robots" content="index"><meta name="DC.Title" content="PyTables User's Guide"><meta name="DC.Description" content="PyTables User's Guide Hierarchical datasets in Python Release 0.9"><meta name="DC.Creator" content="Francesc Altet"><meta name="Author" content="Francesc Altet"><meta name="DC.Creator" content="Scott Prater"><meta name="Author" content="Scott Prater"><meta name="DC.Creator" content="Ivan Vilata"><meta name="Author" content="Ivan Vilata"><meta name="DC.Creator" content="Tom Hedley"><meta name="Author" content="Tom Hedley"><meta name="DC.Date" content="2004-11-05T16:54:26+01:00"><meta name="Date" content="2004-11-05T16:54:26+01:00"><meta name="DC.Rights" content="(c) 2002, 2003, 2004 Francesc Altet"><meta name="Copyright" content="(c) 2002, 2003, 2004 Francesc Altet"><meta name="DC.Type" content="Text"><meta name="DC.Format" content="text/html"><meta name="DC.Language" scheme="rfc3066" content="en"><meta name="Language" content="en"><meta http-equiv="Content-Style-Type" content="text/css"><style type="text/css">
    body {
      font-family: serif; text-align: justify;
      margin: 0pt; line-height: 1.3; background-color: white; color: black }
    body.letter { background-image: none }
    h1, h2, h3, h4, h5, h6, div.partheadline, div.title,
      div.title-article {
      font-family: sans-serif; font-weight: bold; font-stretch: condensed;
      text-align: left; }
    h1, h2, h3, h4, h5, h6, div.partheadline { padding-left: 18pt }
    h1 { clear: both }
    h1.toc { clear: none }
    a:link, a:visited, a:active { text-decoration: none }
    a:hover[href] { text-decoration: underline; color: #0066FF; }
    div.document, div.letter { margin-left: 80px; margin-right: 150px;
      padding-top: 3ex; padding-bottom: 5ex }
    div.authorlist { font-family: sans-serif;
      font-stretch: condensed; text-align: left; font-size: x-large;
      margin-bottom: 1ex }
    div.authorlist-article { font-size: x-large; text-align: center;
      margin-bottom: 2ex }
    div.title { font-size: xx-large; color: gray; margin-bottom: 5ex; }
    div.title-article { font-size: xx-large; text-align: center;
      margin-bottom: 1ex }
    div.date-article { font-size: large; text-align: center;
      margin-bottom: 5ex }
    div.subtitle { text-align: left; margin-bottom: 3ex }
    div.legal { text-align: right }
    div.legalnotice { margin-top: 3ex; text-align: left }
    div.partheadline { font-size: xx-large; margin-top: 1ex; margin-bottom: 1ex }
    div.footnote { }
    hr.footnoterule { text-align: left; width: 40%; margin-right: 60%; color: black }
    div.mathdisplay { text-align: center;
    margin-top: 2ex; margin-bottom: 2ex }
    div.figure, div.table, div.mathml-remark { margin-bottom: 3ex;
            margin-top: 2ex}
    div.mathml-remark { width: 50%; text-align: left; text-indent: 0pt }
    div.caption { margin-top: 1ex; width: 20em}
    div.caption-text { font-size: small;
      padding-left: 1em; text-indent: -1em; text-align: left}
    caption { max-width: 100%; min-width: 200px; margin-bottom: 1ex;
      text-align: left }
    div.verse { white-space: pre; margin-left: 2em;
      margin-top: 2ex; margin-bottom: 2ex }
    div.toc { margin-bottom: 6ex }
    div.biblio { }
    div.index { width: 100% }
    div.aphorism { margin-bottom: 2ex; font-style: italic; text-align: right;
      margin-left: 50%}
    div.aphorism-origin { margin-top: 1ex }
    div.letter { }
    div.subject { margin-top: 3ex; margin-bottom: 3ex }
    div.opening { margin-top: 3ex; margin-bottom: 3ex }
    div.closing { margin-top: 3ex; text-align: right }
    div.to { margin-top: 3ex; margin-bottom: 3ex }
    span.subject { font-weight: bold }
    div.speedbar-top, div.speedbar-bottom { margin-left: 1em; margin-right: 1em }
    div.speedbar-top { margin-top: 2ex }
    div.speedbar-bottom { margin-bottom: 3ex }
    table.speedbar { width: 100% }
    hr.speedbar { clear: both }
    div.theorem-plain, div.theorem-definition, div.theorem-remark { margin-top: 2ex;
      margin-bottom: 2ex }
    div.theorem-plain { font-style: italic }
    div.proof { margin-top: 2ex; margin-bottom: 2ex }
    span.theorem-head-plain, span.theorem-head-definition, span.theorem-head-remark
      { margin-right: 0.66em }
    span.theorem-head-plain, span.theorem-head-definition
      { font-style: normal; font-weight: bold }
    span.theorem-head-remark { font-style: italic }
    span.proof-head { font-style: italic; margin-right: 0.66em }
    acronym { font-size: 95%; letter-spacing: 0.1em; text-transform: uppercase }
    td.header { text-align: center; font-weight: bold }
    table.toc { }
    table.tabular { font-size: smaller }
    td.thickline { height: 0pt; border-bottom: medium solid; padding: 2px }
    td.thinline { height: 0pt; border-bottom: thin solid;   padding: 2px }
     /* FixMe: Following definition Still bad */
    div.part-toc { margin-top: 2ex; font-weight: bold; font-size: larger }
     /* FixMe: Following definition: How cleaner? */
    div.toplevel-toc { margin-top: 1ex; font-weight: bold }
    td.number1 { width: 1.5em }
    td.number2 { width: 2em }
    td.number3 { width: 3em }
    td.author { text-align: center; width: 50% }
    div { }  /* Must remain empty! */
    span.captionlabel { font-family: sans-serif; font-weight: bold;
      margin-right: 0.66em }
    span.captionlabel:after { content: " " }
    b.captionlabel {  }
    b.captionlabel:after { content: " " }
    span.headlinenumber { margin-right: 0.66em }
    tt.verb {font-family: monospace }
    span.bibtag { font-weight: bold; margin-right: 1em }
    span.bib-author { }
    span.bib-lastname { font-variant: small-caps }
    span.bib-title { font-style: italic }
    span.bib-booktitle { }
    span.bib-journal { }
    span.bib-journal-volume { font-weight: bold }
    span.bib-publisher { }
    span.bib-school { }
    span.bib-year { }
    span.bib-note { }
    span { } /* Muss leer bleiben! */
    li.bibitem { margin-left: 1em; text-indent: -1em }
    img.graphics { border: 0pt }
    p,div.p { margin: 0pt; text-indent: 18pt }
    ul, dl, ol { text-indent: 0pt; }
    p.first, div.p-first { margin: 0pt; text-indent: 0pt }
    p.bibitem { margin-top: 1.5ex; margin-left: 3em; text-indent: -3em }
    ul.biblio { list-style: none }
    mi.ch { font-style: normal }
    math[display="block"], div.equation {
      margin-top: 1ex; margin-bottom: 1ex }
    div.i-lettergroup { font-size: larger; font-weight: bold; padding-left: 18pt;
      margin-top: 3ex; margin-bottom: 1.5ex }
    div.i-item { }
    div.i-main { }
    dt { display: compact; font-weight: bold }
    dd { text-indent: 0pt }
    pre { text-indent: 0pt }
    span.i-see { font-style: italic; }

h1 { color: red }
h2 { color: olive }
h3 { color: navy }
h4 { color: maroon }
body { /* background-image: url("tile.jpg"); */  /* Per a imprimir millor */
 font: 14px/1.5 Verdana, Arial, Helvetica, sans-serif;
 background:#fff;
 padding:5%;
 padding-top:2%;
 margin:0px;
}
/*     body { background-image: url("tile.jpg");
         background-color: white;
         color: black;
	 font-size: 13pt; } */
hr.footnoterule { color: white }
div.title { font-size: x-large; color: maroon }
div.subtitle { font-size: x-large; color: olive }
div.title-article { font-size: x-large }
div.partheadline { font-size: x-large }
</style></head><body><div class="speedbar-top"><table class="speedbar"><tbody><tr><td style="text-align: left; width: 15%"><a href="usersguide4.html">previous</a></td><td style="text-align: center"><a href="usersguide.html#tb:table-of-contents">Table of Contents</a></td><td style="text-align: right; width: 15%"><a href="usersguide6.html">next</a></td></tr><tr><td colspan="3">&nbsp;</td></tr></tbody></table><hr class="speedbar"></div><div class="document"><div id="FileNode"><a name="FileNode"></a>
      <h1 id="chapter5"><a name="chapter5"></a>Chapter&nbsp;5: FileNode</h1>

      <div>
	<h2 id="section5.1"><span class="headlinenumber"><a name="section5.1"></a>5.1 </span>What is <tt>FileNode</tt>?</h2>

	<p class="first"><tt class="verb">FileNode</tt> is a module which enables you to
	  create a <tt class="verb">PyTables</tt> database of nodes which can
	  be used like regular opened files in Python.  In other
	  words, you can store a file in a <tt class="verb">PyTables</tt>
	  database, and read and write it as you would do with any
	  other file in Python.  Used in conjunction with
	  <tt class="verb">PyTables</tt> hierarchical database organisation,
	  you can have your database turned into an open, extensible,
	  efficient, high capacity, portable and metadata-rich
	  filesystem for data exchange with other systems (including
	  backup purposes).
	</p>

	<p>Between the main features of <tt class="verb">FileNode</tt>, one can
	  list:</p>

	<ul>
	  <li><em>Open:</em> Since it relies on
	    <tt class="verb">PyTables</tt>, which in turn, sits over HDF5 (see
	    <a href="#HDFWhatIs"></a>), a standard hierarchical
	    data format from NCSA.</li>

	  <li><em>Extensible:</em> You can define new types of
	    nodes, and their instances will be safely preserved (as
	    are normal groups, leafs and attributes) by
	    <tt class="verb">PyTables</tt> applications having no knowledge of
	    their types.  Moreover, the set of possible attributes for
	    a node is not fixed, so you can define your own node
	    attributes.
	  </li>

	  <li><em>Efficient:</em> Thanks to PyTables' proven
	    extreme efficiency on handling huge amounts of data.
	    FileNode can make use of PyTables' on-the-fly compression
	    and decompression of data.</li>

	  <li><em>High capacity:</em> Since PyTables and HDF5 are
	    designed for massive data storage (they use 64-bit
	    addressing even where the platform does not support it
	    natively).</li>

	  <li><em>Portable:</em> Since the HDF5 format has an
	    architecture-neutral design, and the HDF5 libraries and
	    PyTables are known to run under a variety of platforms.
	    Besides that, a PyTables database fits into a single file,
	    which poses no trouble for transportation.</li>

	  <li><em>Metadata-rich:</em> Since PyTables can store
	    arbitrary key-value pairs (even Python objects!) for every
	    database node.  Metadata may include authorship, keywords,
	    MIME types and encodings, ownership information, access
	    control lists (ACL), decoding functions and anything you
	    can imagine!</li>

	</ul>
      </div>

      <div>
	<h2 id="section5.2"><span class="headlinenumber"><a name="section5.2"></a>5.2 </span>Current limitations</h2>

	<p class="first"><tt class="verb">FileNode</tt> is still a young piece of software,
	  so it lacks some functionality.  This is a list of known
	  current limitations:
	</p>

	<ol>
	  <li>Node file names are constrained to
	    <tt class="verb">PyTables</tt> node names (i.e. most valid Python
	    identifiers).  For the moment, if you want arbitrary names
	    you will have to use a translation map (see <a href="usersguide4.html#openFileDescr">4.1.2</a>) or the node title.  The same
	    restriction applies to attribute names.
	  </li>
	  <li>Node files can only be opened for read-only or read
	    and append mode.  This will be enhanced in the future.
	  </li>
	  <li>There is no universal newline support yet.  This is
	    likely to be implemented in a near future.
	  </li>
	  <li>Sparse files (files with lots of zeros) are not
	    treated specially; if you want them to take less space,
	    you should be better off using compression.
	  </li>
	</ol>

	<p>These limitations still make <tt class="verb">FileNode</tt> entirely
	  adequate to work with most binary and text files.  Of
	  course, suggestions and patches are welcome.
	</p>

      </div>

      <div>
	<h2 id="section5.3"><span class="headlinenumber"><a name="section5.3"></a>5.3 </span>Finding a <tt>FileNode</tt>
	  node</h2>

	<p class="first"><tt>FileNode</tt> nodes can be
	  recognised because they have a <tt class="verb">_type</tt> attribute
	  with a <tt class="verb">'file'</tt> value.  It is recommended that
	  you use the <tt class="verb">getAttrNode()</tt> method (see <a href="usersguide4.html#getAttrNodeDescr">4.2.2</a>) of <tt class="verb">tables.File</tt>
	  class to get the <tt class="verb">_type</tt> attribute independently
	  of the nature (group or leaf) of the node, so you do not
	  need to care about.
	</p>
      </div>

      <div>
	<h2 id="section5.4"><span class="headlinenumber"><a name="section5.4"></a>5.4 </span>Using <tt>FileNode</tt></h2>

	<p class="first">The <tt>FileNode</tt> module is part of
	  the <tt class="verb">nodes</tt> sub-package of <tt class="verb">PyTables</tt>.
	  The recommended way to import the module is:
	</p>
	<pre>
  &gt;&gt;&gt; from tables.nodes import FileNode
	</pre>

	<p>However, <tt>FileNode</tt> exports very
	  few symbols, so you can import <tt class="verb">*</tt> for
	  interactive usage.  In fact, you will most probably only use
	  the <tt class="verb">NodeType</tt> constant and the
	  <tt class="verb">newNode()</tt> and <tt class="verb">openNode()</tt> calls.
	</p>
	<p>The <tt class="verb">NodeType</tt> constant contains the value that
	  the <tt class="verb">_type</tt> attribute of a node file is expected
	  to contain (<tt class="verb">'file'</tt>, as we have seen).  Although
	  this is not expected to change, you should use <tt>FileNode.NodeType</tt> instead of the
	  literal <tt class="verb">'file'</tt> when possible.
	</p>
	<p><tt class="verb">newNode()</tt> and <tt class="verb">openNode()</tt> are the
	  equivalent to the Python <tt class="verb">file()</tt> call (alias
	  <tt class="verb">open()</tt>) for ordinary files.  Their arguments
	  differ from that of <tt class="verb">file()</tt>, but this is the
	  only point where you will note the difference between
	  working with a node file and working with an ordinary file.
	</p>

	<p>For this little tutorial, we will assume that we have a
	  <tt class="verb">PyTables</tt> database opened for writing. Also, if
	  you are somewhat lazy at typing sentences, the code that we
	  are going to explain is included in the
	  <tt class="verb">examples/filenodes1.py</tt> file.
	</p>
	<p>You can create a brand new file with these sentences:
	</p>
	<pre>
  &gt;&gt;&gt; import tables
  &gt;&gt;&gt; h5file = tables.openFile('fnode.h5', 'w')
	</pre>

	<div>
	  <h3 id="subsection5.4.1"><span class="headlinenumber"><a name="subsection5.4.1"></a>5.4.1 </span>Creating a new file node</h3>

	  <p class="first">Creation of a new file node is achieved with the
	    <tt class="verb">newNode()</tt> call.  You must tell it in which
	    <tt class="verb">PyTables</tt> file you want to create it, where in
	    the <tt class="verb">PyTables</tt> hierarchy you want to create the
	    node and which will be its name.  The
	    <tt class="verb">PyTables</tt> file is the first argument to
	    <tt class="verb">newNode()</tt>; it will be also called the
	    <tt class="verb">'host PyTables file'</tt>.  The other two
	    arguments must be given as keyword arguments
	    <tt class="verb">where</tt> and <tt class="verb">name</tt>, respectively.
	    As a result of the call, a brand new appendable and
	    readable file node object is returned.
	  </p>
	  <p>So let us create a new node file in the previously opened
	    <tt class="verb">h5file</tt> <tt class="verb">PyTables</tt> file, named
	    <tt class="verb">'fnode_test'</tt> and placed right under the root
	    of the database hierarchy.  This is that command:
	  </p>
	  <pre>
  &gt;&gt;&gt; fnode = FileNode.newNode(h5file, where='/', name='fnode_test')
	  </pre>

	  <p>That is basically all you need to create a file node.
	    Simple, isn't it?  From that point on, you can use
	    <tt class="verb">fnode</tt> as any opened Python file (i.e. you can
	    write data, read data, lines of text and so on).
	  </p>

	  <p><tt class="verb">newNode()</tt> accepts some more keyword
	    arguments.  You can give a title to your file with the
	    <tt class="verb">title</tt> argument.  You can use
	    <tt class="verb">PyTables</tt>' compression features with the
	    <tt class="verb">filters</tt> argument.  If you know beforehand the
	    size that your file will have, you can give its final file
	    size in bytes to the <tt class="verb">expectedsize</tt> argument so
	    that the <tt class="verb">PyTables</tt> library would be able to
	    optimise the data access.
	  </p>

	  <p><tt class="verb">newNode()</tt> creates a <tt class="verb">PyTables</tt>
	    node where it is told to.  To prove it, we will try to get
	    the <tt class="verb">_type</tt> attribute from the newly created
	    node.
	  </p>
	  <pre>
  &gt;&gt;&gt; print h5file.getAttrNode('/fnode_test', '_type')
  file
	  </pre>
	</div>

	<div>
	  <h3 id="subsection5.4.2"><span class="headlinenumber"><a name="subsection5.4.2"></a>5.4.2 </span>Using a file node</h3>

	  <p class="first">As stated above, you can use the new node file as any
	    other opened file.  Let us try to write some text in and
	    read it.
	  </p>
	  <pre>
  &gt;&gt;&gt; print &gt;&gt; fnode, "This is a test text line."
  &gt;&gt;&gt; print &gt;&gt; fnode, "And this is another one."
  &gt;&gt;&gt; print &gt;&gt; fnode
  &gt;&gt;&gt; fnode.write("Of course, file methods can also be used.")
  &gt;&gt;&gt; 
  &gt;&gt;&gt; fnode.seek(0)  # Go back to the beginning of file.
  &gt;&gt;&gt; 
  &gt;&gt;&gt; for line in fnode:
  ...   print repr(line)
  'This is a test text line.\n'
  'And this is another one.\n'
  '\n'
  'Of course, file methods can also be used.'
	  </pre>

	  <p>This was run on a Unix system, so newlines are expressed
	    as <tt class="verb">'\n'</tt>.  In fact, you can override the line
	    separator for a file by setting its
	    <tt class="verb">lineSeparator</tt> property to any string you
	    want.
	  </p>

	  <p>While using a file node, you should take care of closing
	    it <b>before</b> you close the
	    <tt class="verb">PyTables</tt> host file.  Because of the way
	    <tt class="verb">PyTables</tt> works, your data it will not be at a
	    risk, but every operation you execute after closing the
	    host file will fail with a <tt class="verb">ValueError</tt>.  To
	    close a file node, simply delete it or call its
	    <tt class="verb">close()</tt> method.
	  </p>
	  <pre>
  &gt;&gt;&gt; fnode.close()
  &gt;&gt;&gt; print fnode.closed
  True
	  </pre>
	</div>

	<div>
	  <h3 id="subsection5.4.3"><span class="headlinenumber"><a name="subsection5.4.3"></a>5.4.3 </span>Opening an existing file node</h3>

	  <p class="first">If you have a file node that you created using
	    <tt class="verb">newNode()</tt>, you can open it later by calling
	    <tt class="verb">openNode()</tt>.  Its arguments are similar to
	    that of <tt class="verb">file()</tt> or <tt class="verb">open()</tt>: the
	    first argument is the <tt class="verb">PyTables</tt> node that you
	    want to open (i.e. a node with a <tt class="verb">_type</tt>
	    attribute having a <tt class="verb">'file'</tt> value), and the
	    second argument is a mode string indicating how to open
	    the file.  Contrary to <tt class="verb">file()</tt>,
	    <tt class="verb">openNode()</tt> can not be used to create a new
	    file node.
	  </p>

	  <p>File nodes can be opened in read-only mode
	    (<tt class="verb">'r'</tt>) or in read-and-append mode
	    (<tt class="verb">'a+'</tt>).  Reading from a file node is allowed
	    in both modes, but appending is only allowed in the second
	    one.  Just like Python files do, writing data to an
	    appendable file places it after the file pointer if it is
	    on or beyond the end of the file, or otherwise after the
	    existing data.  Let us see an example:
	  </p>
	  <pre>
  &gt;&gt;&gt; node = h5file.root.fnode_test
  &gt;&gt;&gt; fnode = FileNode.openNode(node, 'a+')
  &gt;&gt;&gt; print repr(fnode.readline())
  'This is a test text line.\n'
  &gt;&gt;&gt; print fnode.tell()
  26
  &gt;&gt;&gt; print &gt;&gt; fnode, "This is a new line."
  &gt;&gt;&gt; print repr(fnode.readline())
  ''
	  </pre>

	  <p>Of course, the data append process places the pointer at
	    the end of the file, so the last <tt class="verb">readline()</tt>
	    call hit <tt class="verb">EOF</tt>.  Let us seek to the beginning
	    of the file to see the whole contents of our file.
	  </p>
	  <pre>
  &gt;&gt;&gt; fnode.seek(0)
  &gt;&gt;&gt; for line in fnode:
  ...   print repr(line)
  'This is a test text line.\n'
  'And this is another one.\n'
  '\n'
  'Of course, file methods can also be used.This is a new line.\n'
	  </pre>

	  <p>As you can check, the last string we wrote was correctly
	    appended at the end of the file, instead of overwriting
	    the second line, where the file pointer was positioned by
	    the time of the appending.
	  </p>
	</div>

	<div>
	  <h3 id="subsection5.4.4"><span class="headlinenumber"><a name="subsection5.4.4"></a>5.4.4 </span>Adding metadata to a file node</h3>

	  <p class="first">You can associate arbitrary metadata to any open node
	    file, regardless of its mode, as long as the host
	    <tt class="verb">PyTables</tt> file is writable.  Of course, you
	    could use the <tt class="verb">setAttrNode()</tt> method of
	    <tt class="verb">tables.File</tt> to do it directly on the proper
	    node, but <tt>FileNode</tt> offers a
	    much more comfortable way to do it.  <tt class="verb">FileNode</tt>
	    objects have an <tt class="verb">attrs</tt> property which gives
	    you direct access to their corresponding
	    <tt class="verb">AttributeSet</tt> object.
	  </p>

	  <p>For instance, let us see how to associate MIME type
	    metadata to our file node:
	  </p>
	  <pre>
  &gt;&gt;&gt; fnode.attrs.content_type = 'text/plain; charset=us-ascii'
	  </pre>

	  <p>As simple as A-B-C.  You can put nearly anything in an
	    attribute, which opens the way to authorship, keywords,
	    permissions and more.  Moreover, there is not a fixed list
	    of attributes.  However, you should avoid names in all
	    caps or starting with <tt class="verb">'_'</tt>, since
	    <tt class="verb">PyTables</tt> and <tt>FileNode</tt> may use them internally.
	    Some valid examples:
	  </p>

	  <pre> 
  &gt;&gt;&gt; fnode.attrs.author = "Ivan Vilata i Balaguer"
  &gt;&gt;&gt; fnode.attrs.creation_date = '2004-10-20T13:25:25+0200'
  &gt;&gt;&gt; fnode.attrs.keywords_en = ["FileNode", "test", "metadata"]
  &gt;&gt;&gt; fnode.attrs.keywords_ca = ["FileNode", "prova", "metadades"]
  &gt;&gt;&gt; fnode.attrs.owner = 'ivan'
  &gt;&gt;&gt; fnode.attrs.acl = {'ivan': 'rw', '@users': 'r'}
	  </pre>

	  <p>You can check that these attributes get stored by running
	    the <tt class="verb">ptdump</tt> command on the host
	    <tt class="verb">PyTables</tt> file:
	  </p>
	  <pre>
  $ ptdump -a fnode.h5:/fnode_test
  /fnode_test (EArray(113, 1)) ''
    /fnode_test.attrs (AttributeSet), 14 attributes:
     [CLASS := 'EARRAY',
      EXTDIM := 0,
      FLAVOR := 'NumArray',
      TITLE := '',
      VERSION := '1.0',
      _type := 'file',
      _type_version := 1,
      acl := {'ivan': 'rw', '@users': 'r'},
      author := 'Ivan Vilata i Balaguer',
      content_type := 'text/plain; charset=us-ascii',
      creation_date := '2004-10-20T13:25:25+0200',
      keywords_ca := ['FileNode', 'prova', 'metadades'],
      keywords_en := ['FileNode', 'test', 'metadata'],
      owner := 'ivan']
	  </pre>

	  <p>Please note that <tt>FileNode</tt>
	    makes no assumptions about the meaning of your metadata,
	    so its handling is entirely left to your needs and
	    imagination.
	  </p>
	</div>
      </div>

      <div>
	<h2 id="section5.5"><span class="headlinenumber"><a name="section5.5"></a>5.5 </span>Complementary notes</h2>

	<p class="first">You can use <tt class="verb">FileNodes</tt> and
	  <tt class="verb">PyTables</tt> groups to mimic a filesystem with
	  files and directories.  Since you can store nearly anything
	  you want as file metadata, this enables you to use a
	  <tt class="verb">PyTables</tt> file as a portable compressed backup,
	  even between radically different platforms.  Take this with
	  a grain of salt, since node files are restricted in their
	  naming (only valid Python identifiers are valid); however,
	  remember that you can use node titles and metadata to
	  overcome this limitation.  Also, you may need to devise some
	  strategy to represent special files such as devices, sockets
	  and such (not necessarily using <tt>FileNode</tt>).
	</p>

	<p>We are eager to hear your opinion about <tt>FileNode</tt> and its potential uses.
	  Suggestions to improve <tt>FileNode</tt>
	  and create other node types are also welcome.  Do not
	  hesitate to contact us!
	</p>

      </div>

      <div>
	<h2 id="section5.6"><span class="headlinenumber"><a name="section5.6"></a>5.6 </span><tt>FileNode</tt> module
	  reference</h2>

	<div>
	  <h3 id="subsection5.6.1"><span class="headlinenumber"><a name="subsection5.6.1"></a>5.6.1 </span>Global constants</h3>

	  <dl>
	    <dt>NodeType</dt> <dd>Value for <tt class="verb">_type</tt>
	      node attribute.</dd>

	    <dt>NodeTypeVersions</dt> <dd>Supported values for
	      <tt class="verb">_type_version</tt> node attribute.</dd>
	  </dl>

	</div>

	<div>
	  <h3 id="subsection5.6.2"><span class="headlinenumber"><a name="subsection5.6.2"></a>5.6.2 </span>Global functions</h3>

	  <div>
	    <h4 id="subsubsection5.6.2.1">newNode(h5file, where, name, title="",
	      filters=None, expectedsize=1000)</h4>
	    
	    <p class="first">Creates a new file node object in the specified
	      <tt class="verb">PyTables</tt> file object.  Additional named
	      arguments <tt class="verb">where</tt> and <tt class="verb">name</tt> must
	      be passed to specify where the file node is to be
	      created.  Other named arguments such as
	      <tt class="verb">title</tt> and <tt class="verb">filters</tt> may also be
	      passed. The special named argument
	      <tt class="verb">expectedsize</tt>, indicating an estimate of the
	      file size in bytes, may also be passed. It returns the
	      filenode object.
	    </p>
	  </div>

	  <div>
	    <h4 id="subsubsection5.6.2.2">openNode(node, mode = 'r')</h4>

	    <p class="first">Opens an existing file node. Returns a file node object
	      from the existing specified PyTables node.  If mode is
	      not specified or it is <tt class="verb">'r'</tt>, the file can
	      only be read, and the pointer is positioned at the
	      beginning of the file.  If mode is <tt class="verb">'a+'</tt>,
	      the file can be read and appended, and the pointer is
	      positioned at the end of the file.
	    </p>

	  </div>
	</div> 

	<div>
	  <h3 id="subsection5.6.3"><span class="headlinenumber"><a name="subsection5.6.3"></a>5.6.3 </span>The <tt>FileNode</tt>
	    abstract class</h3>

	  <p class="first">This is the ancestor of <tt class="verb">ROFileNode</tt> and
	    <tt class="verb">RWFileNode</tt> (see below). Instances of these
	    classes are returned when <tt class="verb">newNode()</tt> or
	    <tt class="verb">openNode()</tt> are called. It represents a new
	    file node associated with a <tt class="verb">PyTables</tt> node,
	    providing a standard Python file interface to it.
	  </p>
	  <p>This abstract class provides only an implementation of
	    the reading methods needed to implement a file-like object
	    over a <tt class="verb">PyTables</tt> node.  The attribute set of
	    the node becomes available via the <tt class="verb">attrs</tt>
	    property.  You can add attributes there, but try to avoid
	    attribute names in all caps or starting with
	    <tt class="verb">'_'</tt>, since they may clash with internal
	    attributes.
	  </p>
	  <p>The node used as storage is also made available via the
	    read-only attribute <tt class="verb">node</tt>.  Please do not
	    tamper with this object unless unavoidably, since you may
	    break the operation of the file node object.
	  </p>
	  <p>The <tt class="verb">lineSeparator</tt> property contains the
	    string used as a line separator, and defaults to
	    <tt class="verb">os.linesep</tt>.  It can be set to any
	    reasonably-sized string you want.
	  </p>
	  <p>The constructor sets the <tt class="verb">closed</tt>,
	    <tt class="verb">softspace</tt> and <tt class="verb">_lineSeparator</tt>
	    attributes to their initial values, as well as the
	    <tt class="verb">node</tt> attribute to <tt class="verb">None</tt>.
	    Sub-classes should set the <tt class="verb">node</tt>,
	    <tt class="verb">mode</tt> and <tt class="verb">offset</tt> attributes.
	  </p>
	  <p>Version 1 implements the file storage as a
	    <tt class="verb">UInt8</tt> uni-dimensional <tt class="verb">EArray</tt>.
	  </p>

	  <div>
	    <h4 id="subsubsection5.6.3.1"><tt>FileNode</tt>
	      methods</h4>

	    <dl>

	      <dt>getLineSeparator()</dt> <dd>Returns the line
		separator string.</dd>

	      <dt>setLineSeparator()</dt> <dd>Sets the line
		separator string.</dd>

	      <dt>getAttrs()</dt> <dd>Returns the attribute set
		of the file node.</dd>

	      <dt>close()</dt> <dd>Flushes the file and closes
		it.  The <tt class="verb">node</tt> attribute becomes
		<tt class="verb">None</tt> and the <tt class="verb">attrs</tt> property
		becomes no longer available.</dd>

	      <dt>next()</dt> <dd>Returns the next line of text.
		Raises <tt class="verb">StopIteration</tt> when lines are
		exhausted.  See <tt class="verb">file.next.__doc__</tt> for
		more information.</dd>

	      <dt>read(size=None)</dt> <dd>Reads at most
		<tt class="verb">size</tt> bytes.  See
		<tt class="verb">file.read.__doc__</tt> for more
		information</dd>

	      <dt>readline(size=-1)</dt> <dd>Reads the next text
		line.  See <tt class="verb">file.readline.__doc__</tt> for more
		information</dd>

	      <dt>readlines(sizehint=-1)</dt> <dd>Reads the text
		lines.  See <tt class="verb">file.readlines.__doc__</tt> for
		more information.</dd>

	      <dt>seek(offset, whence=0)</dt> <dd>Moves to a new
		file position.  See <tt class="verb">file.seek.__doc__</tt> for
		more information.</dd>

	      <dt>tell()</dt> <dd> Gets the current file
		position.  See <tt class="verb">file.tell.__doc__</tt> for more
		information.</dd>

	      <dt>xreadlines()</dt> <dd>For backward
		compatibility.  See
		<tt class="verb">file.xreadlines.__doc__</tt> for more
		information.</dd>

	    </dl>

	  </div>

	</div>

	<div>
	  <h3 id="subsection5.6.4"><span class="headlinenumber"><a name="subsection5.6.4"></a>5.6.4 </span>The <tt>ROFileNode</tt>
	    class</h3>

	  <p class="first">Instances of this class are returned when
	    <tt class="verb">openNode()</tt> is called in read-only mode
	    (<tt class="verb">'r'</tt>). This is a descendant of
	    <tt class="verb">FileNode</tt> class, so it inherits all its
	    methods. Moreover, it does not define any other useful
	    method, just some protections against users intents to
	    write on file.
	  </p>

	</div>

	<div>
	  <h3 id="subsection5.6.5"><span class="headlinenumber"><a name="subsection5.6.5"></a>5.6.5 </span>The <tt>RWFileNode</tt>
	    class</h3>

	  <p class="first">Instances of this class are returned when either
	    <tt class="verb">newNode()</tt> is called or when
	    <tt class="verb">openNode()</tt> is called in append mode
	    (<tt class="verb">'a+'</tt>). This is a descendant of
	    <tt class="verb">FileNode</tt> class, so it inherits all its
	    methods. It provides additional methods that allow to
	    write on file nodes.
	  </p>

	  <dl>

	    <dt>flush()</dt> <dd>Flushes the file node.  See
	      <tt class="verb">file.flush.__doc__</tt> for more
	      information.</dd>

	    <dt>truncate(size=None)</dt> <dd>Truncates the file
	      node to at most <tt class="verb">size</tt> bytes. Currently, this
	      method only makes sense to grow the file node, since
	      data can not be rewritten nor deleted.  See
	      <tt class="verb">file.truncate.__doc__</tt> for more
	      information.</dd>

	    <dt>write(string)</dt> <dd>Writes the string to the
		file.  Writing an empty string does nothing, but
		requires the file to be open.  See
		<tt class="verb">file.write.__doc__</tt> for more
		information.</dd>

	    <dt>writelines(sequence)</dt> <dd>Writes the
		sequence of strings to the file.  See
		<tt class="verb">file.writelines.__doc__</tt> for more
		information.</dd>

	  </dl>

	</div>

      </div> 

    </div></div><div class="speedbar-bottom"><hr class="speedbar"><table class="speedbar"><tbody><tr><td style="text-align: left; width: 15%"><a href="usersguide4.html">previous</a></td><td style="text-align: center"><a href="usersguide.html#tb:table-of-contents">Table of Contents</a></td><td style="text-align: right; width: 15%"><a href="usersguide6.html">next</a></td></tr></tbody></table></div></body></html>