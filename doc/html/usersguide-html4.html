
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:bib="http://bibtexml.org/STSCHEMA" xmlns:adr="http://tbookdtd.sourceforge.net/addressbook" xmlns:ref="http://tbookdtd.sourceforge.net/references" xmlns:index="http://tbookdtd.sourceforge.net/index" xmlns:dimensions="http://tbookdtd.sourceforge.net/dimension-file" xmlns:depths="http://tbookdtd.sourceforge.net/depths-file" xmlns:loc="local" xmlns:CSS="http://www.w3.org/1998/Style/CSS2" id="libraryReference"><a name="libraryReference"></a><head>
      <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>PyTables User's Guide</title><meta http-equiv="Content-Type" content="text/html"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="generator" content="The tbook system at http://tbookdtd.sourceforge.net"><meta name="robots" content="index"><meta name="DC.Title" content="PyTables User's Guide"><meta name="DC.Description" content="PyTables User's Guide"><meta name="DC.Creator" content="Francesc Alted"><meta name="Author" content="Francesc Alted"><meta name="DC.Date" content="2003-03-17T19:55:03+01:00"><meta name="Date" content="2003-03-17T19:55:03+01:00"><meta name="DC.Rights" content="(c) 2003 Francesc Alted"><meta name="Copyright" content="(c) 2003 Francesc Alted"><meta name="DC.Type" content="Text"><meta name="DC.Format" content="text/html"><meta name="DC.Language" scheme="rfc3066" content="en"><meta name="Language" content="en"><meta http-equiv="Content-Style-Type" content="text/css"><style type="text/css">
    body {
      font-family: serif; text-align: justify;
      margin: 0pt; line-height: 1.3; background-color: white; color: black }
    body.letter { background-image: none }
    h1, h2, h3, h4, h5, h6, div.partheadline, div.title,
      div.title-article {
      font-family: sans-serif; font-weight: bold; font-stretch: condensed;
      text-align: left; }
    h1, h2, h3, h4, h5, h6, div.partheadline { padding-left: 18pt }
    h1 { clear: both }
    h1.toc { clear: none }
    div.document, div.letter { margin-left: 80px; margin-right: 150px;
      padding-top: 3ex; padding-bottom: 5ex }
    div.authorlist { font-family: sans-serif;
      font-stretch: condensed; text-align: left; font-size: x-large;
      margin-bottom: 1ex }
    div.authorlist-article { font-size: x-large; text-align: center;
      margin-bottom: 2ex }
    div.title { font-size: xx-large; color: gray; margin-bottom: 5ex; }
    div.title-article { font-size: xx-large; text-align: center;
      margin-bottom: 2ex }
    div.date-article { font-size: large; text-align: center;
      margin-bottom: 5ex }
    div.subtitle { text-align: left; margin-bottom: 3ex }
    div.legal { text-align: right }
    div.partheadline { font-size: xx-large; margin-top: 1ex; margin-bottom: 1ex }
    div.footnote { }
    div.mathdisplay { text-align: center;
    margin-top: 2ex; margin-bottom: 2ex }
    div.figure, div.table, div.mathml-remark { margin-bottom: 3ex;
            margin-top: 2ex}
    div.mathml-remark { width: 50%; text-align: left; text-indent: 0pt }
    div.caption { margin-top: 1ex; width: 20em}
    div.caption-text { font-size: small;
      padding-left: 1em; text-indent: -1em; text-align: justify}
    caption { max-width: 100%; min-width: 200px; margin-bottom: 1ex;
      text-align: justify }
    div.verse { white-space: pre }
    div.toc { margin-bottom: 6ex }
    div.biblio, div.index { }
    div.aphorism { margin-bottom: 2ex; font-style: italic; text-align: right;
      margin-left: 50%}
    div.aphorism-origin { margin-top: 1ex }
    div.letter { }
    div.subject { margin-top: 3ex; margin-bottom: 3ex }
    div.opening { margin-top: 3ex; margin-bottom: 3ex }
    div.closing { margin-top: 3ex; text-align: right }
    div.to { margin-top: 3ex; margin-bottom: 3ex }
    span.subject { font-weight: bold }
    div.speedbar-top, div.speedbar-bottom { margin-left: 1em; margin-right: 1em }
    div.speedbar-top { margin-top: 2ex }
    div.speedbar-bottom { margin-bottom: 3ex }
    table.speedbar { width: 100% }
    hr.speedbar { clear: both }
    div.theorem-plain, div.theorem-definition, div.theorem-remark { margin-top: 2ex;
      margin-bottom: 2ex }
    div.theorem-plain { font-style: italic }
    div.proof { margin-top: 2ex; margin-bottom: 2ex }
    span.theorem-head-plain, span.theorem-head-definition, span.theorem-head-remark
      { margin-right: 0.66em }
    span.theorem-head-plain, span.theorem-head-definition
      { font-style: normal; font-weight: bold }
    span.theorem-head-remark { font-style: italic }
    span.proof-head { font-style: italic; margin-right: 0.66em }
    acronym { font-size: 95%; letter-spacing: 0.1em; text-transform: uppercase }
    td.header { text-align: center; font-weight: bold }
    table.toc { }
    table.tabular { font-size: smaller }
    td.thickline { height: 0pt; border-bottom: medium solid; padding: 2px }
    td.thinline { height: 0pt; border-bottom: thin solid;   padding: 2px }
     /* FixMe: Following definition Still bad */
    div.part-toc { margin-top: 2ex; font-weight: bold; font-size: larger }
     /* FixMe: Following definition: How cleaner? */
    div.toplevel-toc { margin-top: 1ex; font-weight: bold }
    td.number1 { width: 1.5em }
    td.number2 { width: 2em }
    td.number3 { width: 3em }
    td.author { text-align: center }
    div { }  /* Must remain empty! */
    span.captionlabel { font-family: sans-serif; font-weight: bold;
      margin-right: 0.66em }
    span.captionlabel:after { content: " " }
    b.captionlabel {  }
    b.captionlabel:after { content: " " }
    span.headlinenumber { margin-right: 0.66em }
    tt.verb {font-family: monospace }
    span.bibtag { font-weight: bold; margin-right: 1em }
    span.bib-author { }
    span.bib-lastname { font-variant: small-caps }
    span.bib-title { font-style: italic }
    span.bib-booktitle { }
    span.bib-journal { }
    span.bib-journal-volume { font-weight: bold }
    span.bib-publisher { }
    span.bib-school { }
    span.bib-year { }
    span.bib-note { }
    span { } /* Muss leer bleiben! */
    li.bibitem { margin-left: 1em; text-indent: -1em }
    img.graphics { border: 0pt }
    p,div.p { margin: 0pt; text-indent: 18pt }
    ul, dl, ol { text-indent: 0pt; }
    p.first, div.p-first { margin: 0pt; text-indent: 0pt }
    p.bibitem { margin-top: 1.5ex; margin-left: 3em; text-indent: -3em }
    ul.biblio { list-style: none }
    mi.ch { font-style: normal }
    math[display="block"], div.equation {
      margin-top: 1ex; margin-bottom: 1ex }
    div.i-lettergroup { font-size: larger; font-weight: bold; padding-left: 18pt;
      margin-top: 3ex; margin-bottom: 1.5ex }
    div.i-item { }
    div.i-main { }
    dt { display: compact; font-weight: bold }
    dd { text-indent: 0pt }
    pre { text-indent: 0pt }
    span.i-see { font-style: italic; }
</style></head><body bgcolor="#FFFFFF"><div class="speedbar-top"><table class="speedbar"><tr><td style="text-align: left; width: 15%"><a href="usersguide-html3.html">previous</a></td><td style="text-align: center"><a href="usersguide-html.html#tb:table-of-contents">Table of Contents</a> &#8212; <a href="usersguide-html6.html">References</a></td><td style="text-align: right; width: 15%"><a href="usersguide-html5.html">next</a></td></tr><tr><td colspan="3">&nbsp;</td></tr></table><hr class="speedbar"></div><div class="document"><div id="libraryReference"><a name="libraryReference"></a>
      <h1 id="chapter4"><a name="chapter4"></a>Chapter&nbsp;4: Library Reference</h1>
      
      <p class="first"><tt class="verb">PyTables</tt> implements several classes to represent
	the different nodes in the object tree. They are named
	<tt class="verb">File</tt>, <tt class="verb">Group</tt>, <tt class="verb">Leaf</tt>,
	<tt class="verb">Table</tt> and <tt class="verb">Array</tt>. Another one is
	responsible to build record objects from a subclass user
	declaration, and performs field and type checks; its name is
	<tt class="verb">IsDescription</tt>. An important function, called
	<tt class="verb">openFile</tt> is responsible to create, open or append
	to files. In addition, a few utility functions are defined to
	guess if an user supplied file is a <tt class="verb">PyTables</tt> or
	<tt class="verb">HDF5</tt> file. These are called
	<tt class="verb">isPyTablesFile</tt> and <tt class="verb">isHDF5</tt>. Finally,
	several first-level variables are also available to the user
	that informs about <tt class="verb">PyTables</tt> version, file format
	version or underlying libraries (as for example
	<tt class="verb">HDF5</tt>) version number.
      </p>

      <p>Let's start discussing the first-level variables and
	functions available to the user, then the methods in the
	classes defined in <tt class="verb">PyTables</tt>.
      </p>

      <div>
	<h2><span class="headlinenumber" id="section4.1"><a name="section4.1"></a>4.1 </span><tt>tables</tt> variables and
	  functions</h2>

	<div>
	  <h3><span class="headlinenumber" id="subsection4.1.1"><a name="subsection4.1.1"></a>4.1.1 </span>Global variables</h3>

	  <dl>

	    <dt>__version__</dt> <dd>The <tt class="verb">PyTables</tt>
	    version number.</dd>

	    <dt>HDF5Version</dt>
	    <dd>The underlying HDF5 library version number.</dd>

	    <dt>ExtVersion</dt> <dd>The Pyrex extension types
	      version. This might be useful when reporting
	      bugs.</dd>

	  </dl>
	  
	</div>

	<div id="GlobalFunctDescr"><a name="GlobalFunctDescr"></a>
	  <h3><span class="headlinenumber" id="subsection4.1.2"><a name="subsection4.1.2"></a>4.1.2 </span>Global functions</h3>

	  <dl id="openFileDescr"><a name="openFileDescr"></a>
	    <dt>openFile(filename, mode='r', title='', trMap={})</dt>
	    <dd>Open a <tt class="verb">PyTables</tt> file and returns a File
	    object.
	    
	      <dl>

		<dt>filename</dt> <dd>The name of the file
		  (supports environment variable expansion). It is
		  suggested that it should have any of
		  <tt class="verb">".h5"</tt>, <tt class="verb">".hdf"</tt> or
		  <tt class="verb">".hdf5"</tt> extensions, although this is
		  not mandatory.
		</dd>

		<dt>mode</dt> <dd>The mode to open the file. It
		  can be one of the following:

		  <dl>

		    <dt>'r'</dt> <dd>read-only; no data can be
		      modified.</dd>

		    <dt>'w'</dt> <dd>write; a new file is created
		      (an existing file with the same name is
		      deleted).</dd>

		    <dt>'a'</dt> <dd>append; an existing file is
		      opened for reading and writing, and if the file does
		      not exist it is created.</dd>

		    <dt>'r+'</dt> <dd>is similar to 'a', but the
		      file must already exist.</dd>

		  </dl>
		</dd>

		<dt>title</dt> <dd>If filename is new, this will
		  set a title for the root group in this file. If
		  filename is not new, the title will be read from
		  disk, and this will not have any effect.
		</dd>

		<dt>trMap</dt> <dd>A dictionary to map names in
		  the object tree Python namespace into different HDF5
		  names in file namespace. The keys are the Python
		  names, while the values are the HDF5 names. This is
		  useful when you need to name HDF5 nodes with invalid
		  or reserved words in Python.
		</dd>

	      </dl>

	    </dd>

	    <dt>isHDF5(filename)</dt> <dd>Determines whether
	      filename is in the HDF5 format. When successful, returns
	      a positive value, for TRUE, or 0 (zero), for
	      FALSE. Otherwise returns a negative value.  To this
	      function to work, it needs a closed file.
	    </dd>

	    <dt>isPyTablesFile(filename)</dt> <dd>Determines
	      whether a file is in the <tt class="verb">PyTables</tt> format.
	      When successful, returns the format version string, for
	      TRUE, or 0 (zero), for FALSE. Otherwise returns a
	      negative value.  To this function to work, it needs a
	      closed file.
	    </dd>

	  </dl>
	</div>
      </div>

      <div id="IsDescriptionClassDescr"><a name="IsDescriptionClassDescr"></a>
	<h2><span class="headlinenumber" id="section4.2"><a name="section4.2"></a>4.2 </span>The <tt>IsDescription</tt> class</h2>

	<p class="first">This class is in fact a so-called <em>metaclass</em>
	  object. There is nothing special on this fact, except that
	  their subclasses attributes are transformed during its
	  instantiation phase, and new methods for instances are
	  defined based on the values of the class attributes.
	</p>
	<p>It is designed to be used as an easy, yet meaningful way to
	  describe the properties of <tt class="verb">Table</tt> objects
	  through the use of classes that inherit properties from
	  it. In order to define such an special class, you have to
	  declare it as descendent from <em>IsDescription</em>, with
	  many attributes as columns you want in your table. The name
	  of these attributes will become the name of the columns,
	  while its values are the properties of the columns that are
	  obtained through the use of the <tt class="verb">Col</tt> class
	  constructor. See the <a href="#ColClassDescr">section&nbsp;4.3</a> for instructions on how
	  define the properties of the table columns.
	</p>
	<p>Then, you can pass an instance of this object to the
	  <tt class="verb">Table</tt> constructor, where all the information it
	  contains will be used to define the table structure. See
	  the <a href="usersguide-html3.html#secondExample">section&nbsp;3.3</a> for an example
	  on how that works.
	</p>

      </div>

      <div id="ColClassDescr"><a name="ColClassDescr"></a>
	<h2><span class="headlinenumber" id="section4.3"><a name="section4.3"></a>4.3 </span>The <tt>Col</tt> class</h2>

	<p class="first">
	  This class is used as a mean to declare the different
	  properties of a column of a table. The only public method
	  accesible is the constructor itself.
	</p>

	<dl>

	  <dt>Col(dtype="Float64", shape=(1,), dflt=None, pos =
	    None)
	  </dt>
	  <dd>Define properties for a <tt class="verb">Table</tt> column.

	    <dl>

	      <dt>dtype</dt> <dd>The data type for the column. See
		the <a href="usersguide-html5.html#datatypesSupported">appendix&nbsp;A</a> for a
		relation of data types supported in a <tt>IsDescription</tt> class declaration.</dd>

	      <dt>shape</dt> <dd>An integer (or, for
		multidimensional cases, a tuple, although this is not yet
		supported as for the version 0.4) that specifies the
		number of <em>dtype</em> items for each element (or shape,
		for multidimensional elements) of this column.</dd>

	      <dt>dflt</dt> <dd>The default value for elements of
		this column. If the user does not supply a value for an
		element while filling a table, this default value will be
		written to disk. If <em>dflt</em> is not supplied, a
		appropriate zero value (or <em>null</em> string) will be
		chosen by default.</dd>

	      <dt>pos</dt> <dd>By default, columns are disposed in
		memory following an alphanumerical order of the column
		names. In some situations, however, it is convenient to
		impose a user defined ordering. <em>pos</em> parameter
		allows the user to force the wanted disposition.</dd>

	    </dl>
	  </dd>
	</dl>

      </div>

      <div id="FileClassDescr"><a name="FileClassDescr"></a>
	<h2><span class="headlinenumber" id="section4.4"><a name="section4.4"></a>4.4 </span>The <tt>File</tt> class</h2>

	<p class="first">This class is returned when a <tt class="verb">PyTables</tt> file is
	  opened with the <tt class="verb">openFile()</tt> function. It has
	  methods to create, open, flush and close
	  <tt class="verb">PyTables</tt> files. Also, <tt class="verb">File</tt> class
	  offer methods to traverse the object tree, as well as to
	  create, rename and delete nodes. One of its attributes
	  (<tt class="verb">root</tt>) is quite important because represents
	  the entry point to the object tree attached to the file.
	</p>

	<p>Next, we will discuss the attributes and methods for File
	  class<a href="#footnote3" name="footnoteback3"><sup>3)</sup></a>.
	</p>

	<div id="FileInstanceVariablesDescr"><a name="FileInstanceVariablesDescr"></a>
	  <h3><span class="headlinenumber" id="subsection4.4.1"><a name="subsection4.4.1"></a>4.4.1 </span><tt>File</tt> instance
	    variables</h3>
	  <dl>

	    <dt>filename</dt> <dd>Filename opened.</dd>

	    <dt>mode</dt> <dd>Mode in which the filename was
	      opened.</dd>

	    <dt>title</dt> <dd>The title of the root group in
	      file.</dd>

	    <dt>root</dt> <dd>The root group in file. This is
	      the entry point to the object tree.</dd>

	    <dt>trMap</dt> <dd>This is a dictionary that maps
	      node names between python and HDF5 domain names. Its
	      initial values are set from the <em>trMap</em> parameter
	      passed to the <tt class="verb">openFile()</tt> function. You can
	      change its contents <em>after</em> a file is opened and
	      the new map will take effect over any new object added
	      to the tree.</dd>

	    <dt>objects</dt> <dd>Dictionary with all objects
	      (groups or leaves) on tree.</dd>

	    <dt>groups</dt> <dd>Dictionary with all object
	      groups on tree.</dd>

	    <dt>leaves</dt> <dd>Dictionary with all object
	      leaves on tree.</dd>

	  </dl>

	</div>

	<div>
	  <h3><span class="headlinenumber" id="subsection4.4.2"><a name="subsection4.4.2"></a>4.4.2 </span><tt>File</tt> methods</h3>

	  <div id="createGroupDescr"><a name="createGroupDescr"></a>
	    <h4>createGroup(where[, name [, title='']])</h4>

	    <p class="first">Create a new Group instance with name <em>name</em> in
	      <em>where</em> location.
	    </p>

	    <dl>
	      <dt>where</dt> <dd>The parent group where the new
		group will hang. <em>where</em> parameter can be a path
		string (for example
		<tt class="verb">"/Particles/TParticle1"</tt>), or another Group
		instance. </dd>

	      <dt>name</dt>
	      <dd>The name of the new group.</dd>
	      
	      <dt>title</dt> <dd>A description for this
		group.</dd>

	    </dl>

	  </div>

	  <div>
	    <h4 id="createTableDescr"><a name="createTableDescr"></a>createTable(where, name,
	      description, title='', compress=0,
	      expectedrows=10000)</h4>

	    <p class="first">Create a new <tt class="verb">Table</tt> instance with name
	      <em>name</em> in <em>where</em> location.
	    </p>

	    <dl>
		<dt>where</dt> <dd>The parent group where the
		  new table will hang. <em>where</em> parameter can be
		  a path string (for example
		  <tt class="verb">"/Particles/TParticle1"</tt>), or Group
		  instance. </dd>

		<dt>name</dt>
		<dd>The name of the new table.</dd>

		<dt>description</dt> <dd>An instance of a
		  user-defined class (derived from the
		  <tt class="verb">IsDescription</tt> class) where table fields
		  are defined. However, in certain situations, it is
		  more handy to allow this description to be supplied
		  as a dictionary (for example, when you do not know
		  beforehand which structure will have your table). In
		  such a cases, you can pass the description as a
		  dictionary as well. See <a href="usersguide-html3.html#secondExample">section&nbsp;3.3</a> for an example
		  of use. Finally, a <tt class="verb">RecArray</tt> object from
		  the <tt class="verb">numarray</tt> package is also accepted,
		  and all the information about columns and other
		  metadata is used as a basis to create the
		  <tt class="verb">Table</tt> object. Moreover, if the
		  <tt class="verb">RecArray</tt> has actual data this is also
		  injected on the newly created <tt class="verb">Table</tt>
		  object.
		</dd>

		<dt>title</dt> <dd>A description for this object.
		</dd>

		<dt>compress</dt> <dd>Specifies a compress level
		  for data. The allowed range is 0-9. A value of 0
		  disables compression. The default is that
		  compression is disabled, that balances between
		  compression effort and CPU consumption.
		</dd>

		<dt>expectedrows</dt> <dd>An user estimate of
		  the number of records that will be on table. If not
		  provided, the default value is appropriate for tables
		  until 1 MB in size (more or less, depending on the
		  record size). If you plan to save bigger tables you
		  should provide a guess; this will optimize the HDF5
		  B-Tree creation and management process time and
		  memory used. See <a href="usersguide-html3.html#expectedRowsOptim">section&nbsp;3.4.2</a> for a
		  detailed justification of that issue.
		</dd>

	    </dl>
	  </div>

	  <div>
	    <h4 id="createArrayDescr"><a name="createArrayDescr"></a>createArray(where, name,
	      ArrayObject, title='')</h4>

	    <p class="first">Create a new <tt class="verb">Array</tt> instance with name
	      <em>name</em> in <em>where</em> location.
	    </p>
	    <dl>

		<dt>where</dt> <dd>The parent group where the
		  new array will hang. <em>where</em> parameter can be
		  a path string (for example
		  <tt class="verb">"/Particles/TParticle1"</tt>), or
		  <tt class="verb">Group</tt> instance. 
		</dd>

		<dt>name</dt> <dd>The name of the new
		  array.
		</dd>

		<dt>ArrayObject</dt> <dd>The regular array to be
		  saved. Currently accepted values are: lists, tuples,
		  scalars (int and float), strings and
		  (multidimensional) <tt class="verb">Numeric</tt> and
		  <tt class="verb">NumArray</tt> arrays (including
		  <tt class="verb">CharArrays</tt> string arrays). However,
		  these objects must be regular (i.e. they cannot be
		  like, for example, [[1,2],2]). Also, objects that
		  has some of its dimension equal to zero are not
		  supported (this will be solved when unlimited arrays
		  will be implemented).
		</dd>

		<dt>title</dt> <dd>A description for this
		  object.
		</dd>

	      </dl>
	  </div>

	  <div>
	    <h4 id="getNodeDescr"><a name="getNodeDescr"></a>getNode(where, name='',
	      classname='')</h4>

	    <p class="first">Returns the object node <em>name</em> under
	      <em>where</em> location.
	    </p>

	      <dl>

		<dt>where</dt> <dd>Can be a path string or
		  <tt class="verb">Group</tt> instance. If <em>where</em>
		  doesn't exists or has not a child called
		  <em>name</em>, a <tt class="verb">ValueError</tt> error is
		  raised.
		</dd>

		<dt>name</dt> <dd>The object name desired. If
		  <em>name</em> is a null string (''), or not
		  supplied, this method assumes to find the object in
		  <em>where</em>.
		</dd>

		<dt>classname</dt> <dd>If supplied, returns only
		  an instance of this class name. Allowed names in
		  <em>classname</em> are: <tt class="verb">'Group'</tt>,
		  <tt class="verb">'Leaf'</tt>, <tt class="verb">'Table'</tt> and
		  <tt class="verb">'Array'</tt>. Note that these values are
		  strings.
		</dd>

	      </dl>
	  </div>

	  <div>
	    <h4 id="getAttrNodeDescr"><a name="getAttrNodeDescr"></a>getAttrNode(where,
	      attrname, name='' )</h4>

	    <p class="first">Returns the attribute <em>attrname</em> under
	      <em>where.name</em> location.
	    </p>
	    <dl>

		<dt>where</dt> <dd>Can be a path string or
		  <tt class="verb">Group</tt> instance. If <em>where</em>
		  doesn't exists or has not a child called
		  <em>name</em>, a <tt class="verb">ValueError</tt> error is
		  raised.
		</dd>

		<dt>attrname</dt> <dd>The name of the attribute
		  to get.
		</dd>

		<dt>name</dt> <dd>The node name desired. If
		  <em>name</em> is a null string (''), or not
		  supplied, this method assumes to find the object in
		  <em>where</em>.
		</dd>

	    </dl>
	  </div>

	  <div>
	    <h4 id="setAttrNodeDescr"><a name="setAttrNodeDescr"></a>setAttrNode(where,
	      attrname, attrvalue, name='')</h4>

	    <p class="first">Sets the attribute <em>attrname</em> with value
	      <em>attrvalue</em> under <em>where.name</em> location.
	    </p>
	    <dl>

		<dt>where</dt> <dd>Can be a path string or
		  <tt class="verb">Group</tt> instance. If <em>where</em>
		  doesn't exists or has not a child called
		  <em>name</em>, a <tt class="verb">ValueError</tt> error is
		  raised.
		</dd>

		<dt>attrname</dt> <dd>The name of the attribute
		  to set on disk.
		</dd>

		<dt>attrvalue</dt> <dd>The value of the
		  attribute to set. Only strings attributes are
		  supported natively rigth now. However, you can
		  always use <tt class="verb">(c)Pickle</tt> so as to serialize
		  any object you want save therein.
		</dd>

		<dt>name</dt> <dd>The node name desired. If
		  <em>name</em> is a null string (''), or not
		  supplied, this method assumes to find the object in
		  <em>where</em>.
		</dd>

	    </dl>
	  </div>

	  <div>
	    <h4 id="listNodesDescr"><a name="listNodesDescr"></a>listNodes(where,
	      classname='')</h4>

	    <p class="first">Returns a list with all the object nodes (Group or
	      Leaf) hanging from <em>where</em>. The list is
	      alphanumerically sorted by node name.
	    </p>
	    <dl>

		<dt>where</dt> <dd>The parent group. Can be a
		  path string or <tt class="verb">Group</tt> instance.
		</dd>

		<dt>classname</dt> <dd>If a <em>classname</em>
		  parameter is supplied, the iterator will return only
		  instances of this class (or subclasses of it). The
		  only supported classes in <em>classname</em> are
		  <tt class="verb">'Group'</tt>, <tt class="verb">'Leaf'</tt>,
		  <tt class="verb">'Table'</tt> and <tt class="verb">'Array'</tt>. Note
		  that these values are strings.
		</dd>

	    </dl>
	  </div>

	  <div>
	    <h4 id="removeNodeDescr"><a name="removeNodeDescr"></a>removeNode(where, name = "",
	      recursive=0)</h4>

	    <p class="first">Removes the object node
	      <em>name</em> under <em>where</em> location.
	    </p>
	    <dl>

		<dt>where</dt> <dd>Can be a path string or
		  <tt class="verb">Group</tt> instance.  If <em>where</em>
		  doesn't exists or has not a child called
		  <em>name</em>, a <tt class="verb">LookupError</tt> error is
		  raised.</dd>

		<dt>name</dt> <dd>The name of the node to be
		  removed. If not provided, the <em>where</em> node is
		  changed.</dd>

		<dt>recursive</dt> <dd>If not supplied, the
		  object will be removed only if it has no
		  children. If supplied with a true value, the object
		  and all its descendents will be completely
		  removed.</dd>

	    </dl>
	  </div>

	  <div>
	    <h4 id="renameNodeDescr"><a name="renameNodeDescr"></a>renameNode(where, newname,
	      name)</h4>

	    <p class="first">Rename the object node <em>name</em> under
	      <em>where</em> location.
	    </p>
	    <dl>

		<dt>where</dt> <dd>Can be a path string or
		  <tt class="verb">Group</tt> instance.  If <em>where</em>
		  doesn't exists or has not a child called
		  <em>name</em>, a <tt class="verb">LookupError</tt> error is
		  raised.</dd>

		<dt>newname</dt> <dd>Is the new name to be
		  assigned to the node.</dd>

		<dt>name</dt> <dd>The name of the node to be
		  changed. If not provided, the <em>where</em> node is
		  changed.</dd>

	    </dl>
	  </div>

	  <div>
	    <h4 id="walkGroupsDescr"><a name="walkGroupsDescr"></a>walkGroups(where='/')</h4>

	    <p class="first"><em>Iterator</em> that recursively obtains groups (not
	      leaves) hanging from <em>where</em>. If <em>where</em>
	      is not supplied, the root object is taken as origin. The
	      groups are returned from in a top to bottom order, and
	      alphanumerically sorted when they are at the same level.
	    </p>
	    <dl>

		<dt>where</dt> <dd>The origin group. Can be a
		  path string or <tt class="verb">Group</tt> instance.
		</dd>

	    </dl>
	  </div>

	  <div>
	    <h4>flush()</h4>

	    <p class="first">Flush all the leaves in the object tree.
	    </p>
	  </div>

	  <div>
	    <h4>close()</h4>

	    <p class="first">Flush all the leaves in object tree and close the file.
	    </p>
	  </div>

	</div>
      </div>

      <div id="GroupClassDescr"><a name="GroupClassDescr"></a>
	<h2><span class="headlinenumber" id="section4.5"><a name="section4.5"></a>4.5 </span>The <tt>Group</tt> class</h2>

	<p class="first">Instances of this class are a grouping structure containing
	  instances of zero or more groups or leaves, together with
	  supporting metadata.
	</p>

	<p>Working with groups and leaves is similar in many ways to
	  working with directories and files, respectively, in a Unix
	  filesystem. As with Unix directories and files, objects in
	  the object tree are often described by giving their full (or
	  absolute) path names. This full path can be specified either
	  as string (like in <tt class="verb">'/group1/group2'</tt>) or as a
	  complete object path written in the Pythonic fashion known
	  as <em>natural name</em> schema (like in
	  <tt class="verb">file.root.group1.group2</tt>) and discussed in the
	  <a href="usersguide-html1.html#ObjectTreeSection">section&nbsp;1.2</a>.
	</p>

	<p>A collateral effect of the <em>natural naming</em> schema
	  is that you must be aware when assigning a new attribute
	  variable to a Group object to not collide with existing
	  children node names. For this reason and to not pollute the
	  children namespace, it is explicitly forbidden to assign
	  "normal" attributes to Group instances, and the only ones
	  allowed must start with some reserved prefixes, like
	  "<tt class="verb">_f_</tt>" (for methods) or "<tt class="verb">_v_</tt>" (for
	  instance variables) prefixes. Any attempt to assign a new
	  attribute that does not starts with these prefixes, will
	  raise a <tt class="verb">NameError</tt> exception.
	</p>

	<p>Other effect is that you cannot use reserved Python names
	  or other non-allowed python names (like for example "$a" or
	  "44") as node names. You can, however, make use of a
	  translation map dictionary in the
	  <tt class="verb">File.openfile()</tt> method (see section <a href="#openFileDescr"><strong>??</strong></a>) so as to use non valid Python
	  names as node names in the file.
	</p>

	<div>

	  <h3><span class="headlinenumber" id="subsection4.5.1"><a name="subsection4.5.1"></a>4.5.1 </span><tt>Group</tt> instance
	    variables</h3>
	  <dl>

	    <dt>_v_title</dt>
	    <dd>A description for this group.</dd>

	    <dt>_v_name</dt>
	    <dd>The name of this group.</dd>

	    <dt>_v_hdf5name</dt> <dd>The name of this group in
	      HDF5 file namespace.</dd>

	    <dt>_v_pathname</dt>
	    <dd>A string representation of the group location
	      in tree.</dd>

	    <dt>_v_parent</dt>
	    <dd>The parent Group instance.</dd>

	    <dt>_v_rootgroup</dt>
	    <dd>Pointer to the root group object.</dd>

	    <dt>_v_file</dt>
	    <dd>Pointer to the associated File object.</dd>

	    <dt>_v_childs</dt> <dd>Dictionary with all nodes
	      (groups or leaves) hanging from this instance.</dd>

	    <dt>_v_groups</dt> <dd>Dictionary with all node
	      groups hanging from this instance.</dd>

	    <dt>_v_leaves</dt> <dd>Dictionary with all node
	      leaves hanging from this instance.</dd>

	  </dl>

	</div>

	<div>
	  <h3><span class="headlinenumber" id="subsection4.5.2"><a name="subsection4.5.2"></a>4.5.2 </span><tt>Group</tt> methods</h3>

	  <p class="first"><b>Caveat: </b>These methods are
	    documented for completeness, and they can be used without
	    any problem. However, you should use the high-level
	    counterpart methods in the <tt class="verb">File</tt> class,
	    because these are most used in documentation and examples,
	    and are a bit more powerful than ones those exposed here.
	  </p>

	  <dl>

	    <dt>_f_join(name)</dt>
	    <dd>Helper method to correctly concatenate a name child object
	      with the pathname of this group.</dd>

	    <dt>_f_rename(newname)</dt>
	    <dd>Change the name of this group to <em>newname</em>.</dd>

	    <dt>_f_remove(recursive=0)</dt> <dd>Remove this
	      object. If <em>recursive</em> is true, force the removal
	      even if this group has children.</dd>

	    <dt>_f_getAttr(attrname)</dt> <dd>Gets the HDF5
	      attribute <em>attrname</em> of this group.</dd>

	    <dt>_f_setAttr(attrname, attrvalue)</dt> <dd>Sets
	      the attribute <em>attrname</em> of this group to the
	      value <em>attrvalue</em>. Only string values are
	      allowed.</dd>

	    <dt>_f_listNodes(classname='')</dt> <dd>Returns a
	      <em>list</em> with all the object nodes hanging from
	      this instance. The list is alphanumerically sorted by
	      node name. If a <em>classname</em> parameter is
	      supplied, it will only return instances of this class
	      (or subclasses of it). The supported classes in
	      <em>classname</em> are <tt class="verb">'Group'</tt>,
	      <tt class="verb">'Leaf'</tt>, <tt class="verb">'Table'</tt> and
	      <tt class="verb">'Array'</tt>.</dd>

	    <dt>_f_walkGroups()</dt> <dd><em>Iterator</em> that
	      recursively obtains Groups (not Leaves) hanging from
	      self. The groups are returned from top to bottom, and
	      are alphanumerically sorted when they are at the same
	      level.
	    </dd>

	    <dt>_f_close()</dt> <dd>Close this group, making it
	      and its children unaccessible in the object tree.</dd>

	  </dl>

	</div>
      </div>

      <div id="LeafClassDescr"><a name="LeafClassDescr"></a>
	<h2><span class="headlinenumber" id="section4.6"><a name="section4.6"></a>4.6 </span>The <tt>Leaf</tt> class</h2>

	<p class="first">This is a helper class useful to place common functionality
	  of all Leaf objects. It is also useful for classifying
	  purposes. A Leaf object is an end-node, that is, a node that
	  can hang directly from a group object, but that is not a
	  group itself. Right now this set is composed by
	  <tt class="verb">Table</tt> and <tt class="verb">Array</tt> objects. In fact,
	  <tt class="verb">Table</tt> and <tt class="verb">Array</tt> classes inherit
	  functionality from this class using the <em>mix-in</em>
	  technique.
	</p>

	<p>The public variables and methods that <tt class="verb">Table</tt>
	  and <tt class="verb">Array</tt> inherits from <tt class="verb">Leaf</tt> are
	  listed below.</p>

	<div>
	  <h3><span class="headlinenumber" id="subsection4.6.1"><a name="subsection4.6.1"></a>4.6.1 </span><tt>Leaf</tt> instance
	    variables</h3>
	  <dl>

	    <dt>name</dt> <dd>The Leaf node name in Python
	      namespace.</dd>
	    
	    <dt>hdf5name</dt> <dd>The Leaf node name in HDF5
	      namespace.</dd>
	    
	    <dt>title</dt> <dd>The Leaf title.</dd>

	    <dt>shape</dt> <dd>The shape of the associated data
	      in the Leaf.</dd>

	    <dt>byteorder</dt> <dd>The byteorder of
	      the associated data of the Leaf.</dd>

	  </dl>
	</div>

	<div>
	  <h3><span class="headlinenumber" id="subsection4.6.2"><a name="subsection4.6.2"></a>4.6.2 </span><tt>Leaf</tt> methods</h3>
	  <dl>

	    <dt>rename(newname)</dt>
	    <dd>Change the name of this leaf to <em>newname</em>.</dd>

	    <dt>remove()</dt> <dd>Remove this
	      leaf.</dd>

	    <dt>getAttr(attrname)</dt> <dd>Gets the HDF5
	      attribute <em>attrname</em> of this leaf.</dd>

	    <dt>setAttr(attrname, attrvalue)</dt> <dd>Sets
	      the attribute <em>attrname</em> of this leaf to the
	      value <em>attrvalue</em>. Only string values are
	      allowed.</dd>

	    <dt>flush()</dt> <dd>Flush the leaf buffers.</dd>

	    <dt>close()</dt> <dd>Flush the leaf buffers and
	      close the HDF5 dataset.</dd>

	  </dl>
	</div>

      </div>

      <div id="TableClassDescr"><a name="TableClassDescr"></a>
	<h2><span class="headlinenumber" id="section4.7"><a name="section4.7"></a>4.7 </span>The <tt>Table</tt> class</h2>

	<p class="first">Instances of this class represents table objects in the
	  object tree. It provides methods to create new tables or
	  open existing ones, as well as methods to read/write data
	  and metadata from/to table objects in the file.
	</p>
	<p>Data can be read from or written to tables by accessing to
	  an special object that hangs from <tt class="verb">Table</tt>. This
	  object is an instance of the <tt class="verb">Row</tt> class (see
	  <a href="#RowClassDescr">4.8</a>). See the tutorial
	  sections <a href="usersguide-html3.html#usage">chapter&nbsp;3</a> on how to use the
	  <tt class="verb">Row</tt> interface.
	</p>
	<p>Please note that this object inherits all the public
	  attributes and methods from <tt class="verb">Leaf</tt>.
	</p>

	<div>
	  <h3><span class="headlinenumber" id="subsection4.7.1"><a name="subsection4.7.1"></a>4.7.1 </span><tt>Table</tt> instance
	    variables</h3>
	  <dl>

	    <dt>description</dt> <dd>The metaobject describing
	      this table</dd>

	    <dt>row</dt> <dd>The <tt class="verb">Row</tt> instance for
	      this table.</dd>

	    <dt>nrows</dt>
	    <dd>The number of rows in this table.</dd>

	    <dt>colnames</dt>
	    <dd>The field names for the table (list).</dd>

	    <dt>coltypes</dt>
	    <dd>The data types for the table fields (dictionary).</dd>

	    <dt>colshapes</dt>
	    <dd>The shapes for the table fields (dictionary).</dd>

	  </dl>

	</div>

	<div>
	  <h3><span class="headlinenumber" id="subsection4.7.2"><a name="subsection4.7.2"></a>4.7.2 </span><tt>Table</tt> methods</h3>

	  <div>
	    <h4 id="iterrowsDescr"><a name="iterrowsDescr"></a>iterrows(start=None,
	      stop=None, step=None)</h4>


	    <p class="first">Returns an iterator yielding Row instances built from
	      rows in table. This method is actually a
	      <em>generator</em>, i.e. it keeps track on the last
	      record returned so that next time it is invoked it
	      returns the next available row. If a range is supplied
	      (i.e. some of the <em>start</em>, <em>stop</em> or
	      <em>step</em> parameters are passed), only the
	      appropriate rows are returned. Else, all the rows are
	      returned.
	    </p>
	    <dl>
		<dt>start</dt> <dd>Sets the starting row to
		  return data. It accepts negative values meaning that
		  the count starts from the end.</dd>

		<dt>stop</dt> <dd>Sets the last row to be
		  returned to stop - 1, i.e. the end point is omitted
		  (in the Python <tt class="verb">range</tt> tradition). It
		  accepts, likewise start, negative values. A special
		  value of 0 means the last row.
		</dd>

		<dt>step</dt> <dd>When step is given, it
		  specifies the increment. Negative values are not
		  allowed right now.</dd>

	      </dl>
	  </div>

	  <div>
	    <h4 id="readDescr"><a name="readDescr"></a>read(self, start=None, stop=None,
	      step=None, field=None, flavor=None)</h4>

	    <p class="first">Returns
	      the actual data in <tt class="verb">Table</tt>. If <em>field</em>
	      is not supplied, it returns the data as a
	      <tt class="verb">RecArray</tt> object table.
	    </p>
	    <dl>

		<dt>start</dt> <dd>Sets the starting row to
		  return data. It accepts negative values meaning that
		  the count starts from the end.</dd>

		<dt>stop</dt> <dd>Sets the last row to be
		  returned to stop - 1, i.e. the end point is omitted
		  (in the Python <tt class="verb">range</tt> tradition). It
		  accepts, likewise start, negative values. A special
		  value of 0 means the last row.
		</dd>

		<dt>step</dt> <dd>When step is given, it
		  specifies the increment. Negative values are not
		  allowed right now.</dd>

		<dt>field</dt> <dd>If specified, only the column
		  <em>field</em> is returned as a
		  <tt class="verb">NumArray</tt> object. If this is not
		  supplied, all the fields are selected and a RecArray
		  is returned.</dd>

		<dt>flavor</dt> <dd>When a field in table is
		  selected, passing a <em>flavor</em> parameter make
		  an additional conversion to happen in the default
		  <tt class="verb">NumArray</tt> object. <em>flavor</em> must
		  have any of the next values: <tt class="verb">Numeric</tt>,
		  <tt class="verb">Tuple</tt> or <tt class="verb">List</tt>. </dd>

	    </dl>
	  </div>
	</div>
      </div>

      <div id="RowClassDescr"><a name="RowClassDescr"></a>
	<h2><span class="headlinenumber" id="section4.8"><a name="section4.8"></a>4.8 </span>The <tt>Row</tt>
	class</h2>

	<p class="first">This class is used to fetch and set values on the table
	  fields. It works very much like a dictionary, where the keys
	  are the field names of the associated table and the values
	  are the values of those fields in a specific row.
	</p>
	<p>This object turns out to actually be an extension type, so
	  you won't be able to access their documentation
	  interactively. Neither you won't be able to access it's
	  internal attributes (they are not directly accessible from
	  Python), although that <em>accessors</em> (i.e. methods that
	  return an internal attribute) has been defined for the most
	  important variables.
	</p>

	<div>
	  <h3><span class="headlinenumber" id="subsection4.8.1"><a name="subsection4.8.1"></a>4.8.1 </span><tt>Row</tt>
	    methods</h3>

	  <dl>

	    <dt id="appendRowDescr"><a name="appendRowDescr"></a>append()</dt> <dd>Once you
	    have filled the proper fields for the current row, calling
	    this method actually commit this data to the disk
	    (actually data is written to the output buffer).</dd>

	    <dt>nrow()</dt> <dd>Accessor that returns the current
	      row in the table. It is useful to know which row is being
	      dealt with in the middle of a loop.</dd>
	  </dl>
	</div>
      </div>

      <div id="ArrayClassDescr"><a name="ArrayClassDescr"></a>
	<h2><span class="headlinenumber" id="section4.9"><a name="section4.9"></a>4.9 </span>The <tt>Array</tt>
	class</h2>

	<p class="first">Represents an array on file. It provides methods to create
	  new arrays or open existing ones, as well as methods to
	  write/read data and metadata to/from array objects in the
	  file.
	</p>
	<p><b>Caveat:</b> All
	  <tt class="verb">Numeric</tt> and <tt class="verb">numarray</tt> typecodes are
	  supported except those that corresponds to complex data
	  types<a href="#footnote4" name="footnoteback4"><sup>4)</sup></a>. See <tt class="verb">numarray</tt> manual (<a href="usersguide-html6.html#Numarray">Greenfield <em>et&nbsp;al.</em> </a>) to know more about the
	  supported data types, or see <a href="usersguide-html5.html#datatypesSupported">appendix&nbsp;A</a>.
	</p>

	<p>Please note that this object inherits all the public
	  attributes and methods from <tt class="verb">Leaf</tt>.
	</p>

	<div id="ArrayClassInstanceVariables"><a name="ArrayClassInstanceVariables"></a>
	  <h3><span class="headlinenumber" id="subsection4.9.1"><a name="subsection4.9.1"></a>4.9.1 </span><tt>Array</tt> instance
	    variables</h3>
	  <dl>

	    <dt>type</dt> <dd>The type class of the represented
	      array.</dd>

	    <dt>flavor</dt> <dd>The string object representation
	      for this array. It can be any of <em>"NumArray"</em>,
	      <em>"CharArray"</em>, <em>"Numeric"</em>,
	      <em>"List"</em>, <em>"Tuple"</em>, <em>"String"</em>,
	      <em>"Int"</em> or <em>"Float"</em> values.</dd>

	  </dl>

	</div>

	<div>
	  <h3><span class="headlinenumber" id="subsection4.9.2"><a name="subsection4.9.2"></a>4.9.2 </span><tt>Array</tt>
	    methods</h3>

	  <p class="first">Note that, as this object has not internal I/O buffers,
	    there is no point in calling flush() method inherited from
	    <tt class="verb">Leaf</tt>.
	  </p>

	  <dl>

	    <dt id="readArrayDescr"><a name="readArrayDescr"></a>read()</dt> <dd>Read the
	      array from disk and return it as a <tt class="verb">NumArray</tt>
	      (default) object, or if possible, with the original
	      <em>flavor</em> that it was saved. The supported flavors
	      are: <tt class="verb">NumArray</tt>, <tt class="verb">CharArray</tt>,
	      <tt class="verb">Numeric</tt>, <tt class="verb">List</tt>,
	      <tt class="verb">Tuple</tt>, <tt class="verb">String</tt>,
	      <tt class="verb">Int</tt> or <tt class="verb">Float</tt>. Note that as
	      long as this method is not called, the actual array data
	      is resident on disk, not in memory.</dd>

	  </dl>
	</div>
      </div>
    </div><hr align="left" noshade="true" style="text-align: left; width: 20%; color: black"><div class="footnote"><a name="footnote3" href="#footnoteback3"><sup>3)</sup></a>&nbsp;On the following, the term <tt class="verb">Leaf</tt>
	  will refer to a <tt class="verb">Table</tt> or <tt class="verb">Array</tt>
	  node object.</div><div class="footnote"><a name="footnote4" href="#footnoteback4"><sup>4)</sup></a>&nbsp;However, these might be included in the
	  future</div></div><div class="speedbar-bottom"><hr class="speedbar"><table class="speedbar"><tr><td style="text-align: left; width: 15%"><a href="usersguide-html3.html">previous</a></td><td style="text-align: center"><a href="usersguide-html.html#tb:table-of-contents">Table of Contents</a> &#8212; <a href="usersguide-html6.html">References</a></td><td style="text-align: right; width: 15%"><a href="usersguide-html5.html">next</a></td></tr></table></div></body></html>