<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>PyTables User's Guide</title><meta http-equiv="Content-Type" content="text/html"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="generator" content="The tbook system at http://tbookdtd.sourceforge.net"><meta name="robots" content="index"><meta name="DC.Title" content="PyTables User's Guide"><meta name="DC.Description" content="PyTables User's Guide Hierarchical datasets in Python Release 0.9"><meta name="DC.Creator" content="Francesc Altet"><meta name="Author" content="Francesc Altet"><meta name="DC.Creator" content="Scott Prater"><meta name="Author" content="Scott Prater"><meta name="DC.Creator" content="Ivan Vilata"><meta name="Author" content="Ivan Vilata"><meta name="DC.Creator" content="Tom Hedley"><meta name="Author" content="Tom Hedley"><meta name="DC.Date" content="2004-11-05T12:38:42+01:00"><meta name="Date" content="2004-11-05T12:38:42+01:00"><meta name="DC.Rights" content="(c) 2002, 2003, 2004 Francesc Altet"><meta name="Copyright" content="(c) 2002, 2003, 2004 Francesc Altet"><meta name="DC.Type" content="Text"><meta name="DC.Format" content="text/html"><meta name="DC.Language" scheme="rfc3066" content="en"><meta name="Language" content="en"><meta http-equiv="Content-Style-Type" content="text/css"><style type="text/css">
    body {
      font-family: serif; text-align: justify;
      margin: 0pt; line-height: 1.3; background-color: white; color: black }
    body.letter { background-image: none }
    h1, h2, h3, h4, h5, h6, div.partheadline, div.title,
      div.title-article {
      font-family: sans-serif; font-weight: bold; font-stretch: condensed;
      text-align: left; }
    h1, h2, h3, h4, h5, h6, div.partheadline { padding-left: 18pt }
    h1 { clear: both }
    h1.toc { clear: none }
    a:link, a:visited, a:active { text-decoration: none }
    a:hover[href] { text-decoration: underline; color: #0066FF; }
    div.document, div.letter { margin-left: 80px; margin-right: 150px;
      padding-top: 3ex; padding-bottom: 5ex }
    div.authorlist { font-family: sans-serif;
      font-stretch: condensed; text-align: left; font-size: x-large;
      margin-bottom: 1ex }
    div.authorlist-article { font-size: x-large; text-align: center;
      margin-bottom: 2ex }
    div.title { font-size: xx-large; color: gray; margin-bottom: 5ex; }
    div.title-article { font-size: xx-large; text-align: center;
      margin-bottom: 1ex }
    div.date-article { font-size: large; text-align: center;
      margin-bottom: 5ex }
    div.subtitle { text-align: left; margin-bottom: 3ex }
    div.legal { text-align: right }
    div.legalnotice { margin-top: 3ex; text-align: left }
    div.partheadline { font-size: xx-large; margin-top: 1ex; margin-bottom: 1ex }
    div.footnote { }
    hr.footnoterule { text-align: left; width: 40%; margin-right: 60%; color: black }
    div.mathdisplay { text-align: center;
    margin-top: 2ex; margin-bottom: 2ex }
    div.figure, div.table, div.mathml-remark { margin-bottom: 3ex;
            margin-top: 2ex}
    div.mathml-remark { width: 50%; text-align: left; text-indent: 0pt }
    div.caption { margin-top: 1ex; width: 20em}
    div.caption-text { font-size: small;
      padding-left: 1em; text-indent: -1em; text-align: left}
    caption { max-width: 100%; min-width: 200px; margin-bottom: 1ex;
      text-align: left }
    div.verse { white-space: pre; margin-left: 2em;
      margin-top: 2ex; margin-bottom: 2ex }
    div.toc { margin-bottom: 6ex }
    div.biblio { }
    div.index { width: 100% }
    div.aphorism { margin-bottom: 2ex; font-style: italic; text-align: right;
      margin-left: 50%}
    div.aphorism-origin { margin-top: 1ex }
    div.letter { }
    div.subject { margin-top: 3ex; margin-bottom: 3ex }
    div.opening { margin-top: 3ex; margin-bottom: 3ex }
    div.closing { margin-top: 3ex; text-align: right }
    div.to { margin-top: 3ex; margin-bottom: 3ex }
    span.subject { font-weight: bold }
    div.speedbar-top, div.speedbar-bottom { margin-left: 1em; margin-right: 1em }
    div.speedbar-top { margin-top: 2ex }
    div.speedbar-bottom { margin-bottom: 3ex }
    table.speedbar { width: 100% }
    hr.speedbar { clear: both }
    div.theorem-plain, div.theorem-definition, div.theorem-remark { margin-top: 2ex;
      margin-bottom: 2ex }
    div.theorem-plain { font-style: italic }
    div.proof { margin-top: 2ex; margin-bottom: 2ex }
    span.theorem-head-plain, span.theorem-head-definition, span.theorem-head-remark
      { margin-right: 0.66em }
    span.theorem-head-plain, span.theorem-head-definition
      { font-style: normal; font-weight: bold }
    span.theorem-head-remark { font-style: italic }
    span.proof-head { font-style: italic; margin-right: 0.66em }
    acronym { font-size: 95%; letter-spacing: 0.1em; text-transform: uppercase }
    td.header { text-align: center; font-weight: bold }
    table.toc { }
    table.tabular { font-size: smaller }
    td.thickline { height: 0pt; border-bottom: medium solid; padding: 2px }
    td.thinline { height: 0pt; border-bottom: thin solid;   padding: 2px }
     /* FixMe: Following definition Still bad */
    div.part-toc { margin-top: 2ex; font-weight: bold; font-size: larger }
     /* FixMe: Following definition: How cleaner? */
    div.toplevel-toc { margin-top: 1ex; font-weight: bold }
    td.number1 { width: 1.5em }
    td.number2 { width: 2em }
    td.number3 { width: 3em }
    td.author { text-align: center; width: 50% }
    div { }  /* Must remain empty! */
    span.captionlabel { font-family: sans-serif; font-weight: bold;
      margin-right: 0.66em }
    span.captionlabel:after { content: " " }
    b.captionlabel {  }
    b.captionlabel:after { content: " " }
    span.headlinenumber { margin-right: 0.66em }
    tt.verb {font-family: monospace }
    span.bibtag { font-weight: bold; margin-right: 1em }
    span.bib-author { }
    span.bib-lastname { font-variant: small-caps }
    span.bib-title { font-style: italic }
    span.bib-booktitle { }
    span.bib-journal { }
    span.bib-journal-volume { font-weight: bold }
    span.bib-publisher { }
    span.bib-school { }
    span.bib-year { }
    span.bib-note { }
    span { } /* Muss leer bleiben! */
    li.bibitem { margin-left: 1em; text-indent: -1em }
    img.graphics { border: 0pt }
    p,div.p { margin: 0pt; text-indent: 18pt }
    ul, dl, ol { text-indent: 0pt; }
    p.first, div.p-first { margin: 0pt; text-indent: 0pt }
    p.bibitem { margin-top: 1.5ex; margin-left: 3em; text-indent: -3em }
    ul.biblio { list-style: none }
    mi.ch { font-style: normal }
    math[display="block"], div.equation {
      margin-top: 1ex; margin-bottom: 1ex }
    div.i-lettergroup { font-size: larger; font-weight: bold; padding-left: 18pt;
      margin-top: 3ex; margin-bottom: 1.5ex }
    div.i-item { }
    div.i-main { }
    dt { display: compact; font-weight: bold }
    dd { text-indent: 0pt }
    pre { text-indent: 0pt }
    span.i-see { font-style: italic; }

h1 { color: red }
h2 { color: olive }
h3 { color: navy }
h4 { color: maroon }
body { /* background-image: url("tile.jpg"); */  /* Per a imprimir millor */
 font: 14px/1.5 Verdana, Arial, Helvetica, sans-serif;
 background:#fff;
 padding:5%;
 padding-top:2%;
 margin:0px;
}
/*     body { background-image: url("tile.jpg");
         background-color: white;
         color: black;
	 font-size: 13pt; } */
hr.footnoterule { color: white }
div.title { font-size: x-large; color: maroon }
div.subtitle { font-size: x-large; color: olive }
div.title-article { font-size: x-large }
div.partheadline { font-size: x-large }
</style></head><body><div class="speedbar-top"><table class="speedbar"><tbody><tr><td style="text-align: left; width: 15%">&nbsp;</td><td style="text-align: center"><a href="usersguide.html#tb:table-of-contents">Table of Contents</a></td><td style="text-align: right; width: 15%"><a href="usersguide2.html">next</a></td></tr><tr><td colspan="3">&nbsp;</td></tr></tbody></table><hr class="speedbar"></div><div class="document"><div>
      <h1 id="chapter1"><a name="chapter1"></a>Chapter&nbsp;1: Introduction</h1>

      

      <div class="aphorism">La sabidur&iacute;a no vale la pena si no es posible servirse
	de ella para inventar una nueva manera de preparar los
	garbanzos.<br>(Wisdom isn't worth anything if you can't
	use it to come up with a new way to cook garbanzos).
	<div class="aphorism-origin">&#8212;A wise Catalan<br>in "Cien a&ntilde;os de
	soledad"<br> Gabriel Garc&iacute;a M&aacute;rquez</div>
      </div>

      <p class="first">The goal of <tt class="verb">PyTables</tt> is to enable the end user
	to manipulate easily data <b>tables</b>
	and <b>array</b> objects in a
	hierarchical structure. The foundation of the underlying
	hierarchical data organization is the excellent
	<tt class="verb">HDF5</tt> library (see <a href="#HDFWhatIs"></a>).     
      </p>
      <p>
	It should be noted that this package is not intended to
	serve as a complete wrapper for the entire HDF5 API, but only to
	provide a flexible, <em>very Pythonic</em> tool to deal with
	(arbitrarily) large amounts of data (typically bigger than
	available memory) in tables and arrays organized in a
	hierarchical and persistent disk storage structure.
      </p>

      <p>A table is defined as a collection of records whose values
	are stored in <em>fixed-length</em> fields. All records have
	the same structure and all values in each field have the same
	<em>data type</em>. The terms <em>fixed-length</em> and strict
	<em>data types</em> may seem to be a strange requirement for
	an interpreted language like Python, but they serve a useful
	function if the goal is to save very large quantities of data
	(such as is generated by many data aquisition systems,
	Internet services or scientific applications, for example) in
	an efficient manner that reduces demand on CPU time and I/O.
      </p>

      <p>In order to emulate in Python records mapped to HDF5 C
	structs <tt class="verb">PyTables</tt> implements a special
	<em>metaclass</em> object so as to easily define all its
	fields and other properties.  <tt class="verb">PyTables</tt> also
	provides a powerful interface to mine data in tables. Records
	in tables are also known in the <tt class="verb">HDF5</tt> naming
	scheme as <em>compound</em> data types.
      </p>

      <p>For example, you can define arbitrary tables in Python
	simply by declaring a class with name field and types
	information, such as in the following example:
      </p>

<pre>
class Particle(IsDescription):
    name      = StringCol(16)   # 16-character String
    idnumber  = Int64Col()      # Signed 64-bit integer
    ADCcount  = UInt16Col()     # Unsigned short integer
    TDCcount  = UInt8Col()      # unsigned byte
    grid_i    = Int32Col()      # integer
    grid_j    = IntCol()        # integer (equivalent to Int32Col)
    pressure  = Float32Col(shape=(2,3)) # 2-D float array (single-precision)
    energy    = FloatCol(shape=(2,3,4)) # 3-D float array (double-precision) 
</pre>

      <p>You then pass this class to the table constructor,
	fill its rows with your values, and save (arbitrarily large)
	collections of them to a file for persistent storage. After
	that, the data can be retrieved and post-processed quite
	easily with <tt>PyTables</tt> or even with
	another <tt class="verb">HDF5</tt> application (in C, Fortran, Java or
	whatever language that provides a library to interface with HDF5).
      </p>

      
      
      <p>Other important entities in <tt>PyTables</tt> are the <b>array</b> objects that are analogous to
        tables with the difference that all of their components are
        homogeneous.  They come in different flavors, like
        <em>generic</em> (they provide a quick and fast way to deal
        with for numerical arrays), <em>enlargeable</em> (arrays can
        be extended in any single dimension) and <em>variable
        length</em> (each row in the array can have a different number
        of elements).
      </p>

      <p>The next section describes the most interesting capabilities of
	<tt class="verb">PyTables</tt>.
      </p>

      <div>
	<h2 id="section1.1"><span class="headlinenumber"><a name="section1.1"></a>1.1 </span>Main Features</h2>
	<p class="first">
	  <tt class="verb">PyTables</tt> takes advantage of the object
	  orientation and introspection capabilities offered by
	  <tt class="verb">Python</tt>, the <tt class="verb">HDF5</tt> powerful data
	  management features and <tt class="verb">numarray</tt> flexibility
	  and high-performance manipulation of large sets of objects
	  organized in grid-like fashion to provide these features:
	</p>

	<ul>
	  <li><em>Support for table entities:</em> Allows the user
	    to work with a large number of records (up to 2**63),
	    i.e. more than will fit into memory.
	  </li>
	  <li><em>Appendable tables:</em> Supports adding records
	    to already created tables. This can be done even between
	    different Python sessions without copying the dataset or 
	    redefining its structure.
	  </li>
	  <li><em>Multidimensional table cells:</em> You can declare
	    a column to consist of general array cells as well as
	    scalars, which is the only dimensionality allowed the
	    majority of relational databases.
	  </li>
	  <li><em>User defined metadata:</em> Besides suporting
	    system metadata (number of rows of a table, shape, flavor,
	    etc.) the user may specify its own metadata (as for
	    example, room temperature, or protocol for IP traffic that
	    was collected) that complement the meaning of his actual
	    data.
	  </li>
	  <li><em>Support for numerical
	    arrays:</em> <tt class="verb">Numeric</tt> (see <a href="#Numeric"></a>) and <tt class="verb">numarray</tt> (see
	    <a href="#Numarray"></a>) arrays can be used as a
	    useful complement of tables to store homogeneous data.
	  </li>
     
          <li><em>Enlargeable arrays:</em> You can add new elements
            to existing arrays on disk in any dimension you want (but
            only one). Besides, you can access to only a slice of your
            datasets by using the powerful extended slicing mechanism,
            without need to load all your complete dataset in-memory.
          </li>
          <li><em>Variable length arrays:</em> The number of
            elements in these arrays can be variable from row to
            row. This provides a lot of flexibility when dealing with
            complex data.
          </li>

	  <li><em>Supports a hierarchical data model:</em> Allows
	    the user to clearly structure all the data. 
	    <tt class="verb">PyTables</tt> builds up an <em>object
	    tree</em> in memory that replicates the underlying file
	    data structure. Access to the file objects is achieved by
	    walking through and manipulating this object tree.
	  </li>
	  <li><em>Support of files bigger than 2 GB:</em>
            <tt class="verb">PyTables</tt> automatically inherits
	    this capability from the underlying HDF5 library (assuming 
	    your platform supports the C long long integer, or, on 
	    Windows, __int64).
	  </li>
	  <li><em>Ability to read/modify generic HDF5 files:</em>
	    <tt class="verb">PyTables</tt> can access a wide range of objects
	    in generic HDF5 files, like compound type datasets (that
	    can be mapped to <tt class="verb">Table</tt> objects), homogeneous
	    datasets (that can be mapped to <tt class="verb">Array</tt>
	    objects) or variable length record datasets (that can be
	    mapped to <tt class="verb">VLArray</tt> objects).  Besides, if a
	    dataset is not supported, it will be mapped into a special
	    <tt class="verb">UnImplemented</tt> class (see <a href="usersguide4.html#UnImplementedClassDescr">4.10</a>), that will let the
	    user see that the data is there, although it would be
	    unreachable (still, you will be able to access the
	    attributes and some metadata in the dataset).  With that,
	    <tt class="verb">PyTables</tt> probably can access and
	    <em>modify</em> most of the HDF5 files out there.
	  </li>
	  <li><em>Data compression:</em> Supports data
	    compression (using the <tt>
	    <b>Zlib</b></tt>,
            <tt><b>LZO</b></tt> 
            and <tt><b>UCL</b></tt>
	    compression libraries) out of the box. This is important 
	    when you have repetitive data patterns and don't want to
	    spend time searching for an optimized way to store them 
	    (saving you time spent analyzing your data organization).
	  </li>
	  <li><em>High performance I/O:</em> On modern systems
	    storing large amounts of data, tables and array objects can be
	    read and written at a speed only limited by the
	    performance of the underlying I/O subsystem. Moreover, if
	    your data is compressible, even that limit is surmountable!
	  </li>
	  <li><em>Architecture-independent:</em> <tt>PyTables</tt> has been carefully coded (as
	    has HDF5 itself) with little-endian/big-endian byte
	    orderings issues in mind.  In principle you can write a
	    file on a big-endian machine (like a Sparc or MIPS) and
	    read it on other little-endian machine (like an Intel or
	    Alpha) without problems. In addition, it has been tested
	    successfully with 64 bit platforms (Intel-64, AMD-64,
	    PowerPC-G5, MIPS, UltraSparc).
	  </li>

	</ul>

      </div>

      <div id="ObjectTreeSection"><a name="ObjectTreeSection"></a>
	<h2 id="section1.2"><span class="headlinenumber"><a name="section1.2"></a>1.2 </span>The Object Tree</h2>

	<p class="first">The hierarchical model of the underlying HDF5 library
	  allows <tt class="verb">PyTables</tt> to manage tables and arrays in
	  a tree-like structure. In order to achieve this, an
	  <em>object tree</em> entity is <em>dynamically</em> created
	  imitating the HDF5 structure on disk.  The HDF5 objects are
	  read by walking through this object tree.  You can get a
	  good picture of what kind of data is kept in the object by
	  examining the <em>metadata</em> nodes.
	</p>

	<p>The different nodes in the object tree are instances of
	  <tt class="verb">PyTables</tt> classes. There are several types of
	  classes, but the most important ones are the
	  <tt class="verb">Group</tt> and the <tt class="verb">Leaf</tt>
	  classes. <tt class="verb">Group</tt> instances (referred to as
	  <em>groups</em> from now on) are a grouping structure
	  containing instances of zero or more groups or leaves,
	  together with supplementary metadata.  <tt class="verb">Leaf</tt>
	  instances (referred to as <em>leaves</em>) are containers
	  for actual data and cannot contain further groups or
	  leaves. The <tt class="verb">Table</tt>, <tt class="verb">Array</tt>,
	  <tt class="verb">EArray</tt>, <tt class="verb">VLArray</tt> and
	  <tt class="verb">UnImplemented</tt> classes are descendents of
	  <tt class="verb">Leaf</tt>, and inherit all its properties.
	</p>

	<p>Working with groups and leaves is similar in many ways to
	  working with directories and files on a Unix filesystem. As 
	  is the case with Unix directories and files, objects in
	  the object tree are often described by giving their full (or
	  absolute) path names. In <tt class="verb">PyTables</tt> this full
	  path can be specified either as string (such as
	  <tt class="verb">'/subgroup2/table3'</tt>) or as a complete object
	  path written in a format known as the <em>natural name</em>
	  schema (such as <tt class="verb">file.root.subgroup2.table3</tt>).
	</p>

	<p>Support for <em>natural naming</em> is a key aspect of
	  <tt class="verb">PyTables</tt>.  It means that the names of instance
	  variables of the node objects are the same as the names of
	  the element's children<a href="#footnote1" id="footnoteback1"><sup title="I got this simple but powerful idea from the excellent Objectify module by David Mertz (see )">1)</sup></a>. This is very
          <em>Pythonic</em> and intuitive in many cases. Check the 
	  tutorial <a href="usersguide3.html#readingAndSelectingUsage">section&nbsp;3.1.6</a>
	  for usage examples.
	</p>
	<p>You should also be aware that not all the data present in a 
	  file is loaded into the object tree.  Only the <em>metadata</em>
	  (i.e. special data that describes the structure of the
	  actual data) is loaded. The actual data is not read until you 
	  request it (by calling a method on a particular node). Using
	  the object tree (the metadata) you can retrieve information
	  about the objects on disk such as table names, titles, name
	  columns, data types in columns, numbers of rows, or, in
	  the case of arrays, the shapes, typecodes, etc. of the array. 
	  You can also search through the tree for specific kinds of data
	  then read it and process it. In a certain sense, you can think of
	  <tt class="verb">PyTables</tt> as a tool that applies the same
	  introspection capabilities of Python objects to large
	  amounts of data in persistent storage.
	</p>
	<p>To better understand the dynamic nature of this object tree
	  entity, let's start with a sample <tt class="verb">PyTables</tt>
	  script (you can find it in <tt class="verb">examples/objecttree.py</tt>) 
	  to create a HDF5 file:
	</p>

	
	<pre>
from tables import *

class Particle(IsDescription):
    identity = StringCol(length=22, dflt=" ", pos = 0)  # character String
    idnumber = Int16Col(1, pos = 1)  # short integer
    speed    = Float32Col(1, pos = 2)  # single-precision

# Open a file in "w"rite mode
fileh = openFile("objecttree.h5", mode = "w")
# Get the HDF5 root group
root = fileh.root

# Create the groups:
group1 = fileh.createGroup(root, "group1")
group2 = fileh.createGroup(root, "group2")

# Now, create an array in the root group
array1 = fileh.createArray(root, "array1", 
                           ["this is", "a string array"], "String array")
# Create 2 new tables in group1 and group2
table1 = fileh.createTable(group1, "table1", Particle)
table2 = fileh.createTable("/group2", "table2", Particle)
# Create one more Array in group1
array2 = fileh.createArray("/group1", "array2", [1,2,3,4])

# Now, fill the tables:
for table in (table1, table2):
    # Get the record object associated with the table:
    row = table.row
    # Fill the table with 10 records
    for i in xrange(10):
        # First, assign the values to the Particle record
        row['identity']  = 'This is particle: %2d' % (i)
        row['idnumber'] = i
        row['speed']  = i * 2.
        # This injects the Record values
        row.append()

    # Flush the table buffers
    table.flush()

# Finally, close the file (this also will flush all the remaining buffers!)
fileh.close()
	</pre>

	<p>This small program creates a simple HDF5 file called
	  <tt class="verb">objecttree.h5</tt> with the structure that appears
	  in <a href="#objecttree-h5">figure&nbsp;1.1</a>. When the file is
	  created, the metadata in the object tree is updated in
	  memory while the actual data is saved to disk. When you
	  close the file the object tree is no longer
	  available. However, when you reopen this file the object
	  tree will be reconstructed in memory from the metadata on
	  disk, allowing you to work with it in exactly the same way
	  as when you originally created it.
	</p>

	<div class="figure" id="objecttree-h5"><a name="objecttree-h5"></a>
	  <a href="objecttree-h5.jpg"><img class="graphics" width="" height="" alt="An HDF5 example with 2 subgroups, 2 tables ... (Click for original bitmap)" src="objecttree-h5-web.jpg"></a>
	  <div class="caption" style="width: 200px"><div class="caption-text"><span class="captionlabel">Figure&nbsp;1.1:</span> An HDF5 example with 2 subgroups, 2 tables and 1
	    array.</div></div>
	</div>

	<p>In <a href="#objecttree">figure&nbsp;1.2</a> you can see an
	  example of the object tree created when the above
	  <tt class="verb">objecttree.h5</tt> file is read (in fact, such an object is
	  always created when reading any supported generic HDF5
	  file).  It's worthwhile to take your time to understand
	  it<a href="#footnote2" id="footnoteback2"><sup title="Bear in mind, however, that this diagram is not a standard UML class diagram; it is rather meant to show the connections between the PyTables objects and some of its most important attributes and methods.">2)</sup></a>. It will
	  help you to avoid programming mistakes.
	</p>

	<div class="figure" id="objecttree"><a name="objecttree"></a>
	  <img class="graphics" width="" height="" alt="A PyTables object tree&#xA;	      example.&#xA;	  " src="objecttree-web.png">
	  <div class="caption" style="width: 200px"><div class="caption-text"><span class="captionlabel">Figure&nbsp;1.2:</span> A <tt>PyTables</tt> object tree
	      example.
	  </div></div>
	</div>

      </div>

    </div><hr class="footnoterule"><div class="footnote"><a id="footnote1" href="#footnoteback1"><sup>1)</sup></a>&nbsp;I got this simple but
	  powerful idea from the excellent <tt>Objectify</tt> module by David Mertz (see
	  <a href="#Objectify"></a>)</div><div class="footnote"><a id="footnote2" href="#footnoteback2"><sup>2)</sup></a>&nbsp;Bear in mind, however, that this
	  diagram is <b>not</b> a standard UML
	  class diagram; it is rather meant to show the connections
	  between the <tt class="verb">PyTables</tt> objects and some of its
	  most important attributes and methods.</div></div><div class="speedbar-bottom"><hr class="speedbar"><table class="speedbar"><tbody><tr><td style="text-align: left; width: 15%">&nbsp;</td><td style="text-align: center"><a href="usersguide.html#tb:table-of-contents">Table of Contents</a></td><td style="text-align: right; width: 15%"><a href="usersguide2.html">next</a></td></tr></tbody></table></div></body></html>