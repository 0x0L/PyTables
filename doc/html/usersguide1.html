<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:bib="http://bibtexml.org/STSCHEMA" xmlns:adr="http://tbookdtd.sourceforge.net/addressbook" xmlns:ref="http://tbookdtd.sourceforge.net/references" xmlns:index="http://tbookdtd.sourceforge.net/index" xmlns:dimensions="http://tbookdtd.sourceforge.net/dimension-file" xmlns:depths="http://tbookdtd.sourceforge.net/depths-file" xmlns:loc="local" xmlns:CSS="http://www.w3.org/1998/Style/CSS2" xmlns:pref="http://www.w3.org/2002/Math/preference"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>PyTables User's Guide</title><meta http-equiv="Content-Type" content="text/html"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="generator" content="The tbook system at http://tbookdtd.sourceforge.net"><meta name="robots" content="index"><meta name="DC.Title" content="PyTables User's Guide"><meta name="DC.Description" content="PyTables User's Guide A hierarchical database for Python Release 0.7.1"><meta name="DC.Creator" content="Francesc Alted"><meta name="Author" content="Francesc Alted"><meta name="DC.Date" content="2003-08-08T20:38:50+02:00"><meta name="Date" content="2003-08-08T20:38:50+02:00"><meta name="DC.Rights" content="(c) 2002, 2003 Francesc Alted"><meta name="Copyright" content="(c) 2002, 2003 Francesc Alted"><meta name="DC.Type" content="Text"><meta name="DC.Format" content="text/html"><meta name="DC.Language" scheme="rfc3066" content="en"><meta name="Language" content="en"><meta http-equiv="Content-Style-Type" content="text/css"><style type="text/css">
    body {
      font-family: serif; text-align: justify;
      margin: 0pt; line-height: 1.3; background-color: white; color: black }
    body.letter { background-image: none }
    h1, h2, h3, h4, h5, h6, div.partheadline, div.title,
      div.title-article {
      font-family: sans-serif; font-weight: bold; font-stretch: condensed;
      text-align: left; }
    h1, h2, h3, h4, h5, h6, div.partheadline { padding-left: 18pt }
    h1 { clear: both }
    h1.toc { clear: none }
    a:link, a:visited, a:active { text-decoration: none }
    a:hover { text-decoration: underline; color: #0066FF; }
    div.document, div.letter { margin-left: 80px; margin-right: 150px;
      padding-top: 3ex; padding-bottom: 5ex }
    div.authorlist { font-family: sans-serif;
      font-stretch: condensed; text-align: left; font-size: x-large;
      margin-bottom: 1ex }
    div.authorlist-article { font-size: x-large; text-align: center;
      margin-bottom: 2ex }
    div.title { font-size: xx-large; color: gray; margin-bottom: 5ex; }
    div.title-article { font-size: xx-large; text-align: center;
      margin-bottom: 1ex }
    div.date-article { font-size: large; text-align: center;
      margin-bottom: 5ex }
    div.subtitle { text-align: left; margin-bottom: 3ex }
    div.legal { text-align: right }
    div.legalnotice { margin-top: 3ex; text-align: left }
    div.partheadline { font-size: xx-large; margin-top: 1ex; margin-bottom: 1ex }
    div.footnote { }
    hr.footnoterule { text-align: left; width: 20%; color: black }
    div.mathdisplay { text-align: center;
    margin-top: 2ex; margin-bottom: 2ex }
    div.figure, div.table, div.mathml-remark { margin-bottom: 3ex;
            margin-top: 2ex}
    div.mathml-remark { width: 50%; text-align: left; text-indent: 0pt }
    div.caption { margin-top: 1ex; width: 20em}
    div.caption-text { font-size: small;
      padding-left: 1em; text-indent: -1em; text-align: left}
    caption { max-width: 100%; min-width: 200px; margin-bottom: 1ex;
      text-align: left }
    div.verse { white-space: pre; margin-left: 2em;
      margin-top: 2ex; margin-bottom: 2ex }
    div.toc { margin-bottom: 6ex }
    div.biblio { }
    div.index { width: 100% }
    div.aphorism { margin-bottom: 2ex; font-style: italic; text-align: right;
      margin-left: 50%}
    div.aphorism-origin { margin-top: 1ex }
    div.letter { }
    div.subject { margin-top: 3ex; margin-bottom: 3ex }
    div.opening { margin-top: 3ex; margin-bottom: 3ex }
    div.closing { margin-top: 3ex; text-align: right }
    div.to { margin-top: 3ex; margin-bottom: 3ex }
    span.subject { font-weight: bold }
    div.speedbar-top, div.speedbar-bottom { margin-left: 1em; margin-right: 1em }
    div.speedbar-top { margin-top: 2ex }
    div.speedbar-bottom { margin-bottom: 3ex }
    table.speedbar { width: 100% }
    hr.speedbar { clear: both }
    div.theorem-plain, div.theorem-definition, div.theorem-remark { margin-top: 2ex;
      margin-bottom: 2ex }
    div.theorem-plain { font-style: italic }
    div.proof { margin-top: 2ex; margin-bottom: 2ex }
    span.theorem-head-plain, span.theorem-head-definition, span.theorem-head-remark
      { margin-right: 0.66em }
    span.theorem-head-plain, span.theorem-head-definition
      { font-style: normal; font-weight: bold }
    span.theorem-head-remark { font-style: italic }
    span.proof-head { font-style: italic; margin-right: 0.66em }
    acronym { font-size: 95%; letter-spacing: 0.1em; text-transform: uppercase }
    td.header { text-align: center; font-weight: bold }
    table.toc { }
    table.tabular { font-size: smaller }
    td.thickline { height: 0pt; border-bottom: medium solid; padding: 2px }
    td.thinline { height: 0pt; border-bottom: thin solid;   padding: 2px }
     /* FixMe: Following definition Still bad */
    div.part-toc { margin-top: 2ex; font-weight: bold; font-size: larger }
     /* FixMe: Following definition: How cleaner? */
    div.toplevel-toc { margin-top: 1ex; font-weight: bold }
    td.number1 { width: 1.5em }
    td.number2 { width: 2em }
    td.number3 { width: 3em }
    td.author { text-align: center; width: 50% }
    div { }  /* Must remain empty! */
    span.captionlabel { font-family: sans-serif; font-weight: bold;
      margin-right: 0.66em }
    span.captionlabel:after { content: " " }
    b.captionlabel {  }
    b.captionlabel:after { content: " " }
    span.headlinenumber { margin-right: 0.66em }
    tt.verb {font-family: monospace }
    span.bibtag { font-weight: bold; margin-right: 1em }
    span.bib-author { }
    span.bib-lastname { font-variant: small-caps }
    span.bib-title { font-style: italic }
    span.bib-booktitle { }
    span.bib-journal { }
    span.bib-journal-volume { font-weight: bold }
    span.bib-publisher { }
    span.bib-school { }
    span.bib-year { }
    span.bib-note { }
    span { } /* Muss leer bleiben! */
    li.bibitem { margin-left: 1em; text-indent: -1em }
    img.graphics { border: 0pt }
    p,div.p { margin: 0pt; text-indent: 18pt }
    ul, dl, ol { text-indent: 0pt; }
    p.first, div.p-first { margin: 0pt; text-indent: 0pt }
    p.bibitem { margin-top: 1.5ex; margin-left: 3em; text-indent: -3em }
    ul.biblio { list-style: none }
    mi.ch { font-style: normal }
    math[display="block"], div.equation {
      margin-top: 1ex; margin-bottom: 1ex }
    div.i-lettergroup { font-size: larger; font-weight: bold; padding-left: 18pt;
      margin-top: 3ex; margin-bottom: 1.5ex }
    div.i-item { }
    div.i-main { }
    dt { display: compact; font-weight: bold }
    dd { text-indent: 0pt }
    pre { text-indent: 0pt }
    span.i-see { font-style: italic; }

h1 { color: red }
h2 { color: olive }
h3 { color: navy }
h4 { color: maroon }
body { background-image: url("tile.jpg");
         background-color: white;
         color: black;
	 font-size: 13pt; }
hr.footnoterule { color: white }
div.title { font-size: x-large; color: maroon }
div.subtitle { font-size: x-large; color: olive }
div.title-article { font-size: x-large }
div.partheadline { font-size: x-large }
</style></head><body><div class="speedbar-top"><table class="speedbar"><tbody><tr><td style="text-align: left; width: 15%">&nbsp;</td><td style="text-align: center"><a href="usersguide.html#tb:table-of-contents">Table of Contents</a></td><td style="text-align: right; width: 15%"><a href="usersguide2.html">next</a></td></tr><tr><td colspan="3">&nbsp;</td></tr></tbody></table><hr class="speedbar"></div><div class="document"><div>
      <h1 id="chapter1"><a name="chapter1"></a>Chapter&nbsp;1: Introduction</h1>

      <div class="aphorism">La sabidur&iacute;a no vale la pena si no es posible servirse
	de ella para inventar una nueva manera de preparar los
	garbanzos.<div class="aphorism-origin">&#8212;Un sabio catal&aacute;n<br> in "Cien a&ntilde;os de
	soledad"<br> Gabriel Garc&iacute;a M&aacute;rquez</div>
      </div>

      <p class="first">The goal of <tt class="verb">PyTables</tt> is to enable the end user
	to manipulate easily scientific data <b>tables</b> and array objects objects in a
	hierarchical structure. The foundation of the underlying
	hierarchical data organization is the excellent
	<tt class="verb">HDF5</tt> library (see <a href="#HDFWhatIs"></a>).





      </p>
      <p>
	It is important to remark that this package is not intended to
	serve as a complete wrapper for the entire HDF5 API, but to
	provide a flexible, <em>very Pythonic</em> tool to deal with
	(arbitrary) large amounts of data (typically bigger than
	available memory) in tables and arrays organized in a
	hierarchical, persistent disk storage.
      </p>

      <p>A table is defined as a collection of records whose values
	are stored in <em>fixed-length</em> fields. All records have
	the same structure and all values in each field have the same
	<em>data type</em>. The terms <em>fixed-length</em> and
	strict <em>data types</em> seems to be quite a strange
	requirement for an interpreted language like Python, but they
	serve a useful function if the goal is to save very large
	quantities of data (such as is generated by many scientific
	applications, for example) in an efficient manner that reduces
	demand on CPU time and I/O.
      </p>

      <p>In order to emulate records (that will be mapped to C structs
	in HDF5) in Python <tt class="verb">PyTables</tt> implements a special
	<em>metaclass</em> object in order to easily define all its
	fields and other properties.  <tt class="verb">PyTables</tt> also
	provides a powerful interface to mine data in table. Records
	in tables are also known, in the <tt class="verb">HDF5</tt> naming
	scheme, as <em>compound</em> data types.
      </p>

      <p>For example, you can define arbitrary tables in Python
	simply by declaring a class with the name field and types
	information, like in:
      </p>

<pre>
class Particle(IsDescription):
    name      = StringCol(16)   # 16-character String
    idnumber  = Int64Col()      # Signed 64-bit integer
    ADCcount  = UInt16Col()     # Unsigned short integer
    TDCcount  = UInt8Col()      # unsigned byte
    grid_i    = Int32Col()      # integer
    grid_j    = IntCol()        # integer (equivalent to Int32Col)
    pressure  = Float32Col(shape=(2,3)) # 2-D float array (single-precision)
    energy    = FloatCol(shape=(2,3,4)) # 3-D float array (double-precision) 
</pre>

      <p>then, you have to pass this class to the table constructor,
	fill its rows with your values, and save (arbitrary large)
	collections of them in a file for persistent storage. After
	that, this data can be retrieved and post-processed quite
	easily with <tt>PyTables</tt> or even with
	another <tt class="verb">HDF5</tt> application (in C, Fortran, Java or
	whatever language that provides an interface to HDF5).
      </p>

      <p>Next section describes the most interesting capabilities of
	<tt class="verb">PyTables</tt>.
      </p>

      <div>
	<h2 id="section1.1"><span class="headlinenumber"><a name="section1.1"></a>1.1 </span>Main Features</h2>
	<p class="first">
	  <tt class="verb">PyTables</tt> take advantage of the powerful object
	  orientation and introspection capabilities offered by Python
	  to bring the next features to the user:
	</p>

	<ul>
	  <li><em>Support of table entities:</em> Allows working
	    with a large number of records, i.e. that don't fit in
	    memory.
	  </li>
	  <li><em>Appendable tables:</em> It supports adding records
	    to already created tables. This can be done without
	    copying the dataset or redefining its structure, even
	    between different Python sessions.
	  </li>
	  <li><em>Multidimensional table cells:</em> You can declare
	    a column to be formed by general array cells, in addition
	    to only scalars, as the majority of relational databases
	    do.
	  </li>
	  <li><em>Support of arrays:</em> <tt class="verb">Numeric</tt> (see
	    <a href="#Numeric"></a>) or <tt class="verb">numarray</tt>
	    (see <a href="#Numarray"></a>) arrays are a very
	    useful complement of tables to keep homogeneous table
	    slices (like selections of table columns).
	  </li>
	  <li><em>Supports a hierarchical data model:</em> That way,
	    you can structure very clearly all your
	    data. <tt class="verb">PyTables</tt> builds up an <em>object
	    tree</em> in memory that replicates the underlying file
	    data structure. Access to the file objects is achieved by
	    walking throughout this object tree, and manipulating it.
	  </li>
	  <li><em>Support of files bigger than 2 GB:</em> The
	    underlying HDF5 library already can do that (if your
	    platform supports the C long long integer, or, on Windows,
	    __int64), and <tt class="verb">PyTables</tt> automatically inherits
	    this capability.
	  </li>
	  <li><em>Can read generic HDF5 files:</em>
	    <tt class="verb">PyTables</tt> can access to objects in generic
	    HDF5 files provided they contain any combination of
	    groups, compound type datasets (that will be mapped to
	    <tt class="verb">Table</tt> objects) or homogeneous datasets (that
	    will be mapped to <tt class="verb">Array</tt> objects). However, as
	    these kind of data is the most common to be saved HDF5
	    format, <tt class="verb">PyTables</tt> can probably most of the
	    HDF5 files out there.
	  </li>
	  <li><em>Data compression:</em> It supports data
	    compression (through the use of the <tt><b>Zlib</b></tt>,
	    <tt><b>LZO</b></tt> and <tt><b>UCL</b></tt>
	    libraries) out of the box. This become important when you
	    have repetitive data patterns and don't want to loose your
	    time searching for an optimized way to save them (i.e. it
	    saves you data organization analysis time).
	  </li>
	  <li><em>High performance I/O:</em> On modern systems, and
	    for large amounts of data, tables and array objects can be
	    read and written at a speed only limited by the
	    performance of the underlying I/O subsystem. Moreover, if
	    your data is compressible, even faster than that!.
	  </li>
	  <li><em>Architecture-independent:</em> <tt>PyTables</tt> has been carefully coded (as
	    HDF5 itself) with little-endian/big-endian byte orderings
	    issues in mind . So, in principle, you can write a file in
	    a big-endian machine (like a Sparc or MIPS) and read it in
	    other little-endian (like Intel or Alpha) without
	    problems.
	  </li>

	</ul>

      </div>

      <div id="ObjectTreeSection"><a name="ObjectTreeSection"></a>
	<h2 id="section1.2"><span class="headlinenumber"><a name="section1.2"></a>1.2 </span>The Object Tree</h2>

	<p class="first">The hierarchical model of the underlying HDF5 library
	  allows <tt class="verb">PyTables</tt> to manage tables and arrays in
	  a tree-like structure. In order to achieve this, an
	  <em>object tree</em> entity is <em>dynamically</em> created
	  imitating the HDF5 structure on disk. That way, the access
	  to the HDF5 objects is made by walking throughout this
	  object tree, and, by looking at their <em>metadata</em>
	  nodes, you can get a nice picture of what kind data is kept
	  there.
	</p>

	<p>The different nodes in the object tree are instances of
	  <tt class="verb">PyTables</tt> classes. There are several types of
	  those classes, but the most important ones are the
	  <tt class="verb">Group</tt> and the
	  <tt class="verb">Leaf</tt>. <tt class="verb">Group</tt> instances (that we
	  will be calling <em>groups</em> from now on) are a grouping
	  structure containing instances of zero or more groups or
	  leaves, together with supplementary metadata.
	  <tt class="verb">Leaf</tt> instances (that will be called
	  <em>leaves</em>) are containers for actual data and cannot
	  contain further groups or leaves. The <tt class="verb">Table</tt> and
	  <tt class="verb">Array</tt> classes are descendants of
	  <tt class="verb">Leaf</tt>, and inherits all its properties.
	</p>

	<p>Working with groups and leaves is similar in many ways to
	  working with directories and files, respectively, in a Unix
	  filesystem. As with Unix directories and files, objects in
	  the object tree are often described by giving their full (or
	  absolute) path names. In <tt class="verb">PyTables</tt> this full
	  path can be specified either as string (like in
	  <tt class="verb">'/subgroup2/table3'</tt>) or as a complete object
	  path written in a certain way known as <em>natural name</em>
	  schema (like in <tt class="verb">file.root.subgroup2.table3</tt>).
	</p>

	<p>The support for <em>natural naming</em> is a key aspect of
	  <tt class="verb">PyTables</tt> and means that the names of instance
	  variables of the node objects are the same as the names of
	  the element's children<a href="#footnote1" name="footnoteback1"><sup title="I have got this simple but powerful idea from the excellent Objectify module by David Mertz (see )">1)</sup></a>. This is very
	  <em>Pythonic</em> and comfortable in many cases, as you can
	  check in the tutorial <a href="usersguide3.html#readingAndSelectingUsage">section&nbsp;3.1.6</a>.
	</p>
	<p>You should also note that not all the data present on file
	  is loaded in the object tree, but only the <em>metadata</em>
	  (i.e. special data that describes the structure of the
	  actual data). The actual data is not read until you ask for
	  it (by calling a method on a particular node). By making use
	  of the object tree (the metadata) you can get information on
	  the objects on disk such as table names, title, name
	  columns, data types in columns, the number of rows, or, in
	  the case of arrays, the shape, the typecode, and so on. You
	  can also traverse the tree in order to search for something
	  and when you find the data you are interested in you can
	  read it and process it. In some sense, you can think of
	  <tt class="verb">PyTables</tt> as a tool that provide the same
	  introspection capabilities of Python objects, but applied to
	  the persistent storage of large amounts of data.
	</p>
	<p>To better understand the dynamic nature of this object tree
	  entity, let's start by a first example and try to realize
	  what kind of object tree the next script (you can find it in
	  <tt class="verb">examples/objecttree.py</tt>) would create:
	</p>

	<pre>
from tables import *

class Particle(IsDescription):
    identity = StringCol(length=22, dflt=" ", pos = 0)  # character String
    idnumber = Int16Col(1, pos = 1)  # short integer
    speed    = Float32Col(1, pos = 1)  # single-precision

# Open a file in "w"rite mode
fileh = openFile("objecttree.h5", mode = "w")
# Get the HDF5 root group
root = fileh.root

# Create the groups:
group1 = fileh.createGroup(root, "group1")
group2 = fileh.createGroup(root, "group2")

# Now, create a table in "group0" group
array1 = fileh.createArray(root, "array1", ["string", "array"], "String array")
# Create 2 new tables in group1
table1 = fileh.createTable(group1, "table1", Particle)
table2 = fileh.createTable("/group2", "table2", Particle)
# Create the last table in group2
array2 = fileh.createArray("/group1", "array2", [1,2,3,4])

# Now, fill the tables:
for table in (table1, table2):
    # Get the record object associated with the table:
    row = table.row
    # Fill the table with 10 records
    for i in xrange(10):
        # First, assign the values to the Particle record
        row['identity']  = 'This is particle: %2d' % (i)
        row['idnumber'] = i
        row['speed']  = i * 2.
        # This injects the Record values
        row.append()

    # Flush the table buffers
    table.flush()

# Finally, close the file (this also will flush all the remaining buffers!)
fileh.close()
	</pre>

	<p>This small program creates a simple HDF5 file, called
	  <tt class="verb">objecttree.h5</tt>, with the structure that appears
	  in <a href="#objecttree-h5">figure&nbsp;1.1</a>. During creation
	  time, metadata in the object tree is updated in memory while
	  the actual data is being saved on disk and when you close
	  the file the object tree becomes unavailable. But, when you
	  will open again this file the object tree with will be
	  re-constructed in memory from the metadata existent on disk,
	  so that you can work with it exactly in the same way than
	  during the original creation process.
	</p>

	<div class="figure" id="objecttree-h5"><a name="objecttree-h5"></a>
	  <a target="_blank" href="objecttree-h5.jpg"><img class="graphics" alt="An HDF5 example with 2 subgroups, 2 tables ... (Click for original bitmap)" src="objecttree-h5-web.jpg"></a>
	  <div class="caption" style="width: 200px"><div class="caption-text"><span class="captionlabel">Figure&nbsp;1.1:</span> An HDF5 example with 2 subgroups, 2 tables and 1
	    array.</div></div>
	</div>

	<p>In <a href="#objecttree">figure&nbsp;1.2</a> you can see an
	  example of the object tree created by reading the above
	  <tt class="verb">objecttree.h5</tt> file (in fact, such an object is
	  always created when reading any supported generic HDF5
	  file). If you are going to become a <tt>PyTables</tt> user, take your time to
	  understand it<a href="#footnote2" name="footnoteback2"><sup title="Bear in mind, however, that this diagram is not a standard UML class diagram; it is rather meant to show the connections between the PyTables objects and some of its most important attributes and methods.">2)</sup></a>. That will
	  also make you more proactive by avoiding programming
	  mistakes.
	</p>

	<div class="figure" id="objecttree"><a name="objecttree"></a>
	  <img class="graphics" alt="An object tree example in PyTables.&#xA;	  " src="objecttree-web.png">
	  <div class="caption" style="width: 200px"><div class="caption-text"><span class="captionlabel">Figure&nbsp;1.2:</span> An object tree example in <tt>PyTables</tt>.
	  </div></div>
	</div>

      </div>

    </div><hr align="left" noshade="true" class="footnoterule"><div class="footnote"><a name="footnote1" href="#footnoteback1"><sup>1)</sup></a>&nbsp;I have got this simple but
	  powerful idea from the excellent <tt>Objectify</tt> module by David Mertz (see
	  <a href="#Objectify"></a>)</div><div class="footnote"><a name="footnote2" href="#footnoteback2"><sup>2)</sup></a>&nbsp;Bear in mind, however, that this
	  diagram is <b>not</b> a standard UML
	  class diagram; it is rather meant to show the connections
	  between the <tt class="verb">PyTables</tt> objects and some of its
	  most important attributes and methods.</div></div><div class="speedbar-bottom"><hr class="speedbar"><table class="speedbar"><tbody><tr><td style="text-align: left; width: 15%">&nbsp;</td><td style="text-align: center"><a href="usersguide.html#tb:table-of-contents">Table of Contents</a></td><td style="text-align: right; width: 15%"><a href="usersguide2.html">next</a></td></tr></tbody></table></div></body></html>