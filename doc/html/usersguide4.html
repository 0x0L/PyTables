<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:bib="http://bibtexml.org/STSCHEMA" xmlns:adr="http://tbookdtd.sourceforge.net/addressbook" xmlns:ref="http://tbookdtd.sourceforge.net/references" xmlns:index="http://tbookdtd.sourceforge.net/index" xmlns:dimensions="http://tbookdtd.sourceforge.net/dimension-file" xmlns:depths="http://tbookdtd.sourceforge.net/depths-file" xmlns:loc="local" xmlns:CSS="http://www.w3.org/1998/Style/CSS2" xmlns:pref="http://www.w3.org/2002/Math/preference" id="libraryReference"><a name="libraryReference"></a><head>
      <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>PyTables User's Guide</title><meta http-equiv="Content-Type" content="text/html"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="generator" content="The tbook system at http://tbookdtd.sourceforge.net"><meta name="robots" content="index"><meta name="DC.Title" content="PyTables User's Guide"><meta name="DC.Description" content="PyTables User's Guide A hierarchical database for Python Release 0.7.2"><meta name="DC.Creator" content="Francesc Alted"><meta name="Author" content="Francesc Alted"><meta name="DC.Date" content="2003-09-22T13:38:59+02:00"><meta name="Date" content="2003-09-22T13:38:59+02:00"><meta name="DC.Rights" content="(c) 2002, 2003 Francesc Alted"><meta name="Copyright" content="(c) 2002, 2003 Francesc Alted"><meta name="DC.Type" content="Text"><meta name="DC.Format" content="text/html"><meta name="DC.Language" scheme="rfc3066" content="en"><meta name="Language" content="en"><meta http-equiv="Content-Style-Type" content="text/css"><style type="text/css">
    body {
      font-family: serif; text-align: justify;
      margin: 0pt; line-height: 1.3; background-color: white; color: black }
    body.letter { background-image: none }
    h1, h2, h3, h4, h5, h6, div.partheadline, div.title,
      div.title-article {
      font-family: sans-serif; font-weight: bold; font-stretch: condensed;
      text-align: left; }
    h1, h2, h3, h4, h5, h6, div.partheadline { padding-left: 18pt }
    h1 { clear: both }
    h1.toc { clear: none }
    a:link, a:visited, a:active { text-decoration: none }
    a:hover { text-decoration: underline; color: #0066FF; }
    div.document, div.letter { margin-left: 80px; margin-right: 150px;
      padding-top: 3ex; padding-bottom: 5ex }
    div.authorlist { font-family: sans-serif;
      font-stretch: condensed; text-align: left; font-size: x-large;
      margin-bottom: 1ex }
    div.authorlist-article { font-size: x-large; text-align: center;
      margin-bottom: 2ex }
    div.title { font-size: xx-large; color: gray; margin-bottom: 5ex; }
    div.title-article { font-size: xx-large; text-align: center;
      margin-bottom: 1ex }
    div.date-article { font-size: large; text-align: center;
      margin-bottom: 5ex }
    div.subtitle { text-align: left; margin-bottom: 3ex }
    div.legal { text-align: right }
    div.legalnotice { margin-top: 3ex; text-align: left }
    div.partheadline { font-size: xx-large; margin-top: 1ex; margin-bottom: 1ex }
    div.footnote { }
    hr.footnoterule { text-align: left; width: 20%; color: black }
    div.mathdisplay { text-align: center;
    margin-top: 2ex; margin-bottom: 2ex }
    div.figure, div.table, div.mathml-remark { margin-bottom: 3ex;
            margin-top: 2ex}
    div.mathml-remark { width: 50%; text-align: left; text-indent: 0pt }
    div.caption { margin-top: 1ex; width: 20em}
    div.caption-text { font-size: small;
      padding-left: 1em; text-indent: -1em; text-align: left}
    caption { max-width: 100%; min-width: 200px; margin-bottom: 1ex;
      text-align: left }
    div.verse { white-space: pre; margin-left: 2em;
      margin-top: 2ex; margin-bottom: 2ex }
    div.toc { margin-bottom: 6ex }
    div.biblio { }
    div.index { width: 100% }
    div.aphorism { margin-bottom: 2ex; font-style: italic; text-align: right;
      margin-left: 50%}
    div.aphorism-origin { margin-top: 1ex }
    div.letter { }
    div.subject { margin-top: 3ex; margin-bottom: 3ex }
    div.opening { margin-top: 3ex; margin-bottom: 3ex }
    div.closing { margin-top: 3ex; text-align: right }
    div.to { margin-top: 3ex; margin-bottom: 3ex }
    span.subject { font-weight: bold }
    div.speedbar-top, div.speedbar-bottom { margin-left: 1em; margin-right: 1em }
    div.speedbar-top { margin-top: 2ex }
    div.speedbar-bottom { margin-bottom: 3ex }
    table.speedbar { width: 100% }
    hr.speedbar { clear: both }
    div.theorem-plain, div.theorem-definition, div.theorem-remark { margin-top: 2ex;
      margin-bottom: 2ex }
    div.theorem-plain { font-style: italic }
    div.proof { margin-top: 2ex; margin-bottom: 2ex }
    span.theorem-head-plain, span.theorem-head-definition, span.theorem-head-remark
      { margin-right: 0.66em }
    span.theorem-head-plain, span.theorem-head-definition
      { font-style: normal; font-weight: bold }
    span.theorem-head-remark { font-style: italic }
    span.proof-head { font-style: italic; margin-right: 0.66em }
    acronym { font-size: 95%; letter-spacing: 0.1em; text-transform: uppercase }
    td.header { text-align: center; font-weight: bold }
    table.toc { }
    table.tabular { font-size: smaller }
    td.thickline { height: 0pt; border-bottom: medium solid; padding: 2px }
    td.thinline { height: 0pt; border-bottom: thin solid;   padding: 2px }
     /* FixMe: Following definition Still bad */
    div.part-toc { margin-top: 2ex; font-weight: bold; font-size: larger }
     /* FixMe: Following definition: How cleaner? */
    div.toplevel-toc { margin-top: 1ex; font-weight: bold }
    td.number1 { width: 1.5em }
    td.number2 { width: 2em }
    td.number3 { width: 3em }
    td.author { text-align: center; width: 50% }
    div { }  /* Must remain empty! */
    span.captionlabel { font-family: sans-serif; font-weight: bold;
      margin-right: 0.66em }
    span.captionlabel:after { content: " " }
    b.captionlabel {  }
    b.captionlabel:after { content: " " }
    span.headlinenumber { margin-right: 0.66em }
    tt.verb {font-family: monospace }
    span.bibtag { font-weight: bold; margin-right: 1em }
    span.bib-author { }
    span.bib-lastname { font-variant: small-caps }
    span.bib-title { font-style: italic }
    span.bib-booktitle { }
    span.bib-journal { }
    span.bib-journal-volume { font-weight: bold }
    span.bib-publisher { }
    span.bib-school { }
    span.bib-year { }
    span.bib-note { }
    span { } /* Muss leer bleiben! */
    li.bibitem { margin-left: 1em; text-indent: -1em }
    img.graphics { border: 0pt }
    p,div.p { margin: 0pt; text-indent: 18pt }
    ul, dl, ol { text-indent: 0pt; }
    p.first, div.p-first { margin: 0pt; text-indent: 0pt }
    p.bibitem { margin-top: 1.5ex; margin-left: 3em; text-indent: -3em }
    ul.biblio { list-style: none }
    mi.ch { font-style: normal }
    math[display="block"], div.equation {
      margin-top: 1ex; margin-bottom: 1ex }
    div.i-lettergroup { font-size: larger; font-weight: bold; padding-left: 18pt;
      margin-top: 3ex; margin-bottom: 1.5ex }
    div.i-item { }
    div.i-main { }
    dt { display: compact; font-weight: bold }
    dd { text-indent: 0pt }
    pre { text-indent: 0pt }
    span.i-see { font-style: italic; }

h1 { color: red }
h2 { color: olive }
h3 { color: navy }
h4 { color: maroon }
body { background-image: url("tile.jpg");
         background-color: white;
         color: black;
	 font-size: 13pt; }
hr.footnoterule { color: white }
div.title { font-size: x-large; color: maroon }
div.subtitle { font-size: x-large; color: olive }
div.title-article { font-size: x-large }
div.partheadline { font-size: x-large }
</style></head><body><div class="speedbar-top"><table class="speedbar"><tbody><tr><td style="text-align: left; width: 15%"><a href="usersguide3.html">previous</a></td><td style="text-align: center"><a href="usersguide.html#tb:table-of-contents">Table of Contents</a></td><td style="text-align: right; width: 15%"><a href="usersguide5.html">next</a></td></tr><tr><td colspan="3">&nbsp;</td></tr></tbody></table><hr class="speedbar"></div><div class="document"><div id="libraryReference"><a name="libraryReference"></a>
      <h1 id="chapter4"><a name="chapter4"></a>Chapter&nbsp;4: Library Reference</h1>
      
      <div class="aphorism">"Tenho pensamentos que, se pudesse revel&aacute;-los e
	faz&ecirc;-los viver, acrescentariam nova luminosidade &agrave;s estrelas,
	nova beleza ao mundo e maior amor ao cora&ccedil;&atilde;o dos homens."
	<div class="aphorism-origin">&#8212;Fernando Pessoa, in "O Eu Profundo"</div>
      </div>

      <p class="first"><tt class="verb">PyTables</tt> implements several classes to represent
	the different nodes in the object tree. They are named
	<tt class="verb">File</tt>, <tt class="verb">Group</tt>, <tt class="verb">Leaf</tt>,
	<tt class="verb">Table</tt> and <tt class="verb">Array</tt>. Another one is
	responsible to build record objects from a subclass user
	declaration, and performs field and type checks; its name is
	<tt class="verb">IsDescription</tt>. An important function, called
	<tt class="verb">openFile</tt> is responsible to create, open or append
	to files. In addition, a few utility functions are defined to
	guess if the user supplied file is a <tt class="verb">PyTables</tt> or
	<tt class="verb">HDF5</tt> file. These are called
	<tt class="verb">isPyTablesFile</tt> and <tt class="verb">isHDF5</tt>. Finally,
	several first-level variables are also available to the user
	that informs about <tt class="verb">PyTables</tt> version, file format
	version or underlying libraries (as for example
	<tt class="verb">HDF5</tt>) version number.
      </p>

      <p>Let's start discussing the first-level variables and
	functions available to the user, then the methods in the
	classes defined in <tt class="verb">PyTables</tt>.
      </p>

      <div>
	<h2 id="section4.1"><span class="headlinenumber"><a name="section4.1"></a>4.1 </span><tt>tables</tt> variables and
	  functions</h2>

	<div>
	  <h3 id="subsection4.1.1"><span class="headlinenumber"><a name="subsection4.1.1"></a>4.1.1 </span>Global variables</h3>

	  <dl>

	    <dt>__version__</dt> <dd>The <tt class="verb">PyTables</tt>
	    version number.</dd>

	    <dt>HDF5Version</dt>
	    <dd>The underlying HDF5 library version number.</dd>

	    <dt>ExtVersion</dt> <dd>The Pyrex extension types
	      version. This might be useful when reporting
	      bugs.</dd>

	  </dl>
	  
	</div>

	<div id="GlobalFunctDescr"><a name="GlobalFunctDescr"></a>
	  <h3 id="subsection4.1.2"><span class="headlinenumber"><a name="subsection4.1.2"></a>4.1.2 </span>Global functions</h3>

	  <dl id="openFileDescr"><a name="openFileDescr"></a>
	    <dt>openFile(filename, mode='r', title='', trMap={},
	      rootUEP="/")
	    </dt>
	    <dd>Open a <tt class="verb">PyTables</tt> file and returns a File
	    object.
	    
	      <dl>

		<dt>filename</dt> <dd>The name of the file
		  (supports environment variable expansion). It is
		  suggested that it should have any of
		  <tt class="verb">".h5"</tt>, <tt class="verb">".hdf"</tt> or
		  <tt class="verb">".hdf5"</tt> extensions, although this is
		  not mandatory.
		</dd>

		<dt>mode</dt> <dd>The mode to open the file. It
		  can be one of the following:

		  <dl>

		    <dt>'r'</dt> <dd>read-only; no data can be
		      modified.</dd>

		    <dt>'w'</dt> <dd>write; a new file is created
		      (an existing file with the same name is
		      deleted).</dd>

		    <dt>'a'</dt> <dd>append; an existing file is
		      opened for reading and writing, and if the file does
		      not exist it is created.</dd>

		    <dt>'r+'</dt> <dd>is similar to 'a', but the
		      file must already exist.</dd>

		  </dl>
		</dd>

		<dt>title</dt> <dd>If filename is new, this will
		  set a title for the root group in this file. If
		  filename is not new, the title will be read from
		  disk, and this will not have any effect.
		</dd>

		<dt>trMap</dt> <dd>A dictionary to map names in
		  the object tree Python namespace into different HDF5
		  names in file namespace. The keys are the Python
		  names, while the values are the HDF5 names. This is
		  useful when you need to name HDF5 nodes with invalid
		  or reserved words in Python.
		</dd>

		<dt>rootUEP</dt> <dd>The root User Entry
		  Point. This is a group in the HDF5 hierarchy which
		  will be taken as the starting point to create the
		  object tree. The group has to be named after its
		  HDF5 name and can be a path. If it does not exist, a
		  <tt class="verb">RuntimeError</tt> is issued. Use this if you
		  do not want to build the <b>entire</b> object tree, but rather
		  only a <b>subtree</b>.
		</dd>
	      </dl>

	    </dd>

	    <dt>isHDF5(filename)</dt> <dd>Determines whether
	      filename is in the HDF5 format or not. When successful,
	      returns a positive value, for TRUE, or 0 (zero), for
	      FALSE. Otherwise returns a negative value.  To this
	      function to work, it needs a closed file.
	    </dd>

	    <dt>isPyTablesFile(filename)</dt> <dd>Determines
	      whether a file is in the <tt class="verb">PyTables</tt> format.
	      When successful, returns the format version string, for
	      TRUE, or 0 (zero), for FALSE. Otherwise returns a
	      negative value.  To this function to work, it needs a
	      closed file.
	    </dd>

	  </dl>
	</div>
      </div>

      <div id="IsDescriptionClassDescr"><a name="IsDescriptionClassDescr"></a>
	<h2 id="section4.2"><span class="headlinenumber"><a name="section4.2"></a>4.2 </span>The <tt>IsDescription</tt> class</h2>

	<p class="first">This class is in fact a so-called <em>metaclass</em>
	  object. There is nothing special on this fact, except that
	  their subclasses attributes are transformed during its
	  instantiation phase, and new methods for instances are
	  defined based on the values of the class attributes.
	</p>
	<p>It is designed to be used as an easy, yet meaningful way to
	  describe the properties of <tt class="verb">Table</tt> objects
	  through the use of classes that inherit properties from
	  it. In order to define such an special class, you have to
	  declare it as descendant of <em>IsDescription</em>, with
	  many attributes as columns you want in your table. The name
	  of these attributes will become the name of the columns,
	  while its values are the properties of the columns that are
	  obtained through the use of the <tt class="verb">Col</tt> class
	  constructor. See the <a href="#ColClassDescr">section&nbsp;4.3</a> for instructions on how
	  define the properties of the table columns.
	</p>
	<p>Then, you can pass an instance of this object to the
	  <tt class="verb">Table</tt> constructor, where all the information it
	  contains will be used to define the table structure. See
	  the <a href="usersguide3.html#secondExample">section&nbsp;3.3</a> for an example
	  on how that works.
	</p>

      </div>

      <div id="ColClassDescr"><a name="ColClassDescr"></a>
	<h2 id="section4.3"><span class="headlinenumber"><a name="section4.3"></a>4.3 </span>The <tt>Col</tt> class and its descendants</h2>

	<p class="first">
	  The <tt class="verb">Col</tt> class is used as a mean to declare the
	  different properties of a column of a table. In addition, a
	  series of descendant classes are offered in order to make
	  these column descriptions easier to the user. In general, it
	  is recommended to use these descendants classes, as they are
	  meaningful when found in the middle of the code.
	</p>
	<p>The only public method accessible in these classes is the
	  constructor itself.
	</p>

	<dl>

	  <dt>Col(dtype="Float64", shape=1, dflt=None, pos=None)
	  </dt>
	  <dd>Define properties for a <tt class="verb">Table</tt> column.

	    <dl>

	      <dt>dtype</dt> <dd>The data type for the
		column. See the <a href="usersguide6.html#datatypesSupported">appendix&nbsp;A</a> for a
		relation of data types supported in a <tt>IsDescription</tt> class
		declaration. The type description is accepted both in
		string format and as numarray data type.</dd>

	      <dt>shape</dt> <dd>An integer or a tuple, that
		specifies the number of <em>dtype</em> items for each
		element (or shape, for multidimensional elements) of
		this column. For <tt class="verb">CharType</tt> columns, the
		first dimension is used as the length of the character
		strings. For this kind of objects, the use of
		<tt class="verb">StringCol</tt> subclass is recommended.</dd>

	      <dt>dflt</dt> <dd>The default value for elements
		of this column. If the user does not supply a value
		for an element while filling a table, this default
		value will be written to disk. If the user supplies an
		scalar value for a multidimensional column, this value
		is automatically <em>broadcasted</em> to all the
		elements in the column cell. If <em>dflt</em> is not
		supplied, a appropriate zero value (or <em>null</em>
		string) will be chosen by default.</dd>

	      <dt>pos</dt> <dd>By default, columns are disposed in
		memory following an alphanumerical order of the column
		names. In some situations, however, it is convenient to
		impose a user defined ordering. <em>pos</em> parameter
		allows the user to force the wanted disposition.</dd>

	    </dl>
	  </dd>

	  <dt>StringCol(length=None, dflt=None, shape=1, pos=None)
	  </dt>
	  <dd>Define a column to be of <tt class="verb">CharType</tt>
	    type. The <tt class="verb">length</tt> parameter sets the length of
	    the strings. The meaning of the other parameters are like
	    in the <tt class="verb">Col</tt> class.
	  </dd>
	  <dt>IntCol(dflt=0, shape=1, itemsize=4, sign=1, pos=None)
	  </dt>
	  <dd>Define a column to be of <tt class="verb">IntXXType</tt> type,
	    depending on the value of <tt class="verb">itemsize</tt>. The
	    <tt class="verb">itemsize</tt> parameter sets the number of bytes
	    of the integers in the column and the default is 4
	    bytes. <tt class="verb">sign</tt> determines if the integers are
	    signed or not. The meaning of the other parameters are
	    like in the <tt class="verb">Col</tt> class.

	    <p class="first">This class has several descendants:
	    </p>

	    <dl>
	      <dt>Int8Col(dflt=0, shape=1, pos=None)</dt>
	      <dd>Define a column as an <tt class="verb">Int8</tt> type.</dd>

	      <dt>UInt8Col(dflt=0, shape=1, pos=None)</dt>
	      <dd>Define a column as an <tt class="verb">UInt8</tt>
	      type.</dd>

	      <dt>Int16Col(dflt=0, shape=1, pos=None)</dt>
	      <dd>Define a column as an <tt class="verb">Int16</tt> type.</dd>

	      <dt>UInt16Col(dflt=0, shape=1, pos=None)</dt>
	      <dd>Define a column as an <tt class="verb">UInt16</tt>
	      type.</dd>

	      <dt>Int32Col(dflt=0, shape=1, pos=None)</dt>
	      <dd>Define a column as an <tt class="verb">Int32</tt> type.</dd>

	      <dt>UInt32Col(dflt=0, shape=1, pos=None)</dt>
	      <dd>Define a column as an <tt class="verb">UInt32</tt>
	      type.</dd>

	      <dt>Int64Col(dflt=0, shape=1, pos=None)</dt>
	      <dd>Define a column as an <tt class="verb">Int64</tt> type.</dd>

	      <dt>UInt64Col(dflt=0, shape=1, pos=None)</dt>
	      <dd>Define a column as an <tt class="verb">UInt64</tt>
	      type.</dd>

	    </dl>

	  </dd>

	  <dt>FloatCol(dflt=0, shape=1, itemsize=8, pos=None)
	  </dt>
	  <dd>Define a column to be of <tt class="verb">FloatXXType</tt>
	    type, depending on the value of <tt class="verb">itemsize</tt>. The
	    <tt class="verb">itemsize</tt> parameter sets the number of bytes
	    of the floats in the column and the default is 8 bytes
	    (double precision). The meaning of the other parameters
	    are like in the <tt class="verb">Col</tt> class.

	    <p class="first">This class has two descendants:
	    </p>

	    <dl>
	      <dt>Float32Col(dflt=0.0, shape=1, pos=None)</dt>
	      <dd>Define a column as a <tt class="verb">Float32</tt>
	      type.</dd>

	      <dt>Float64Col(dflt=0.0, shape=1, pos=None)</dt>
	      <dd>Define a column as a <tt class="verb">Float64</tt>
	      type.</dd>

	    </dl>
	  </dd>
	</dl>

      </div>

      <div id="FileClassDescr"><a name="FileClassDescr"></a>
	<h2 id="section4.4"><span class="headlinenumber"><a name="section4.4"></a>4.4 </span>The <tt>File</tt> class</h2>

	<p class="first">This class is returned when a <tt class="verb">PyTables</tt> file is
	  opened with the <tt class="verb">openFile()</tt> function. It has
	  methods to create, open, flush and close
	  <tt class="verb">PyTables</tt> files. Also, <tt class="verb">File</tt> class
	  offer methods to traverse the object tree, as well as to
	  create, rename and delete nodes. One of its attributes
	  (<tt class="verb">rootUEP</tt>) represents the <em>user entry
	  point</em> to the object tree attached to the file.
	</p>

	<p>Next, we will discuss the attributes and methods for File
	  class<a href="#footnote4" name="footnoteback4"><sup title="On the following, the term Leaf will whether refer to a Table or Array node object.">4)</sup></a>.
	</p>

	<div id="FileInstanceVariablesDescr"><a name="FileInstanceVariablesDescr"></a>
	  <h3 id="subsection4.4.1"><span class="headlinenumber"><a name="subsection4.4.1"></a>4.4.1 </span><tt>File</tt> instance
	    variables</h3>
	  <dl>

	    <dt>filename</dt> <dd>Filename opened.</dd>

	    <dt>isopen</dt> <dd>It takes the value 1 if the
	      underlying file is open. 0 otherwise.</dd>

	    <dt>mode</dt> <dd>Mode in which the filename was
	      opened.</dd>

	    <dt>title</dt> <dd>The title of the root group in
	      file.</dd>

	    <dt>rootUEP</dt> <dd>The UEP (User Entry Point)
	      group in file (see <a href="#openFileDescr"><strong>??</strong></a>).</dd>

	    <dt>trMap</dt> <dd>This is a dictionary that maps
	      node names between python and HDF5 domain names. Its
	      initial values are set from the <em>trMap</em> parameter
	      passed to the <tt class="verb">openFile()</tt> function. You can
	      change its contents <em>after</em> a file is opened and
	      the new map will take effect over any new object added
	      to the tree.</dd>

	    <dt>objects</dt> <dd>Dictionary with all objects
	      (groups or leaves) on tree.</dd>

	    <dt>groups</dt> <dd>Dictionary with all object
	      groups on tree.</dd>

	    <dt>leaves</dt> <dd>Dictionary with all object
	      leaves on tree.</dd>

	  </dl>

	</div>

	<div>
	  <h3 id="subsection4.4.2"><span class="headlinenumber"><a name="subsection4.4.2"></a>4.4.2 </span><tt>File</tt> methods</h3>

	  <div id="createGroupDescr"><a name="createGroupDescr"></a>
	    <h4 id="subsubsection4.4.2.1">createGroup(where, name, title='')</h4>

	    <p class="first">Create a new Group instance with name <em>name</em> in
	      <em>where</em> location.
	    </p>

	    <dl>
	      <dt>where</dt> <dd>The parent group where the new
		group will hang. <em>where</em> parameter can be a path
		string (for example
		<tt class="verb">"/Particles/TParticle1"</tt>), or another Group
		instance. </dd>

	      <dt>name</dt>
	      <dd>The name of the new group.</dd>
	      
	      <dt>title</dt> <dd>A description for this
		group.</dd>

	    </dl>

	  </div>

	  <div>
	    <h4 id="createTableDescr"><a name="createTableDescr"></a>createTable(where, name,
	      description, title='', compress=0, complib = 'zlib',
	      expectedrows=10000)</h4>

	    <p class="first">Create a new <tt class="verb">Table</tt> instance with name
	      <em>name</em> in <em>where</em> location.
	    </p>

	    <dl>
	      <dt>where</dt> <dd>The parent group where the
		new table will hang. <em>where</em> parameter can be
		a path string (for example
		<tt class="verb">"/Particles/TParticle1"</tt>), or Group
		instance. </dd>

	      <dt>name</dt>
	      <dd>The name of the new table.</dd>

	      <dt>description</dt> <dd>An instance of a
		user-defined class (derived from the
		<tt class="verb">IsDescription</tt> class) where table fields
		are defined. However, in certain situations, it is
		more handy to allow this description to be supplied
		as a dictionary (for example, when you do not know
		beforehand which structure will have your table). In
		such a cases, you can pass the description as a
		dictionary as well. See <a href="usersguide3.html#secondExample">section&nbsp;3.3</a> for an example
		of use. Finally, a <tt class="verb">RecArray</tt> object from
		the <tt class="verb">numarray</tt> package is also accepted,
		and all the information about columns and other
		metadata is used as a basis to create the
		<tt class="verb">Table</tt> object. Moreover, if the
		<tt class="verb">RecArray</tt> has actual data this is also
		injected on the newly created <tt class="verb">Table</tt>
		object.
	      </dd>

	      <dt>title</dt> <dd>A description for this object.
	      </dd>

	      <dt>compress</dt> <dd>Specifies a compress level
		for data. The allowed range is 0-9. A value of 0
		disables compression. The default is that
		compression is disabled, that balances between
		compression effort and CPU consumption.
	      </dd>
	      <dt>complib</dt> <dd> Specifies the compression
		library to be used. Right now, <tt class="verb">"zlib"</tt>
		(default), <tt class="verb">"lzo"</tt> and <tt class="verb">"ucl"</tt>
		values are supported. See <a href="usersguide5.html#compressionIssues">section&nbsp;5.2</a> for some advice
		on which library is better suited to your needs.
	      </dd>
	      <dt>expectedrows</dt> <dd>An user estimate of the
		number of records that will be on table. If not
		provided, the default value is appropriate for tables
		until 1 MB in size (more or less, depending on the
		record size). If you plan to save bigger tables you
		should provide a guess; this will optimize the HDF5
		B-Tree creation and management process time and memory
		used. See <a href="usersguide5.html#expectedRowsOptim">section&nbsp;5.3</a>
		for a detailed justification of that issue.
	      </dd>

	    </dl>
	  </div>

	  <div>
	    <h4 id="createArrayDescr"><a name="createArrayDescr"></a>createArray(where, name,
	      object, title='')</h4>

	    <p class="first">Create a new <tt class="verb">Array</tt> instance with name
	      <em>name</em> in <em>where</em> location.
	    </p>
	    <dl>

		<dt>where</dt> <dd>The parent group where the
		  new array will hang. <em>where</em> parameter can be
		  a path string (for example
		  <tt class="verb">"/Particles/TParticle1"</tt>), or
		  <tt class="verb">Group</tt> instance. 
		</dd>

		<dt>name</dt> <dd>The name of the new
		  array.
		</dd>

		<dt>object</dt> <dd>The regular array to be
		  saved. Currently accepted values are: lists, tuples,
		  scalars (int and float), strings and
		  (multidimensional) <tt class="verb">Numeric</tt> and
		  <tt class="verb">NumArray</tt> arrays (including
		  <tt class="verb">CharArrays</tt> string arrays). However,
		  these objects must be regular (i.e. they cannot be
		  like, for example, <tt class="verb">[[1,2],2]</tt>). Also,
		  objects that has some of its dimension equal to zero
		  are not supported (this will be solved when
		  unlimited arrays will be implemented).
		</dd>

		<dt>title</dt> <dd>A description for this
		  object.
		</dd>

	      </dl>
	  </div>

	  <div>
	    <h4 id="getNodeDescr"><a name="getNodeDescr"></a>getNode(where, name='',
	      classname='')</h4>

	    <p class="first">Returns the object node <em>name</em> under
	      <em>where</em> location.
	    </p>

	      <dl>

		<dt>where</dt> <dd>Can be a path string or
		  <tt class="verb">Group</tt> instance. If <em>where</em>
		  doesn't exists or has not a child called
		  <em>name</em>, a <tt class="verb">ValueError</tt> error is
		  raised.
		</dd>

		<dt>name</dt> <dd>The object name desired. If
		  <em>name</em> is a null string (''), or not
		  supplied, this method assumes to find the object in
		  <em>where</em>.
		</dd>

		<dt>classname</dt> <dd>If supplied, returns only
		  an instance of this class name. Allowed names in
		  <em>classname</em> are: <tt class="verb">'Group'</tt>,
		  <tt class="verb">'Leaf'</tt>, <tt class="verb">'Table'</tt> and
		  <tt class="verb">'Array'</tt>. Note that these values are
		  strings.
		</dd>

	      </dl>
	  </div>

	  <div>
	    <h4 id="getAttrNodeDescr"><a name="getAttrNodeDescr"></a>getAttrNode(where,
	      attrname, name='' )</h4>

	    <p class="first">Returns the attribute <em>attrname</em> under
	      <em>where.name</em> location.
	    </p>
	    <dl>

		<dt>where</dt> <dd>Can be a path string or
		  <tt class="verb">Group</tt> instance. If <em>where</em>
		  doesn't exists or has not a child called
		  <em>name</em>, a <tt class="verb">ValueError</tt> error is
		  raised.
		</dd>

		<dt>attrname</dt> <dd>The name of the attribute
		  to get.
		</dd>

		<dt>name</dt> <dd>The node name desired. If
		  <em>name</em> is a null string (''), or not
		  supplied, this method assumes to find the object in
		  <em>where</em>.
		</dd>

	    </dl>
	  </div>

	  <div>
	    <h4 id="setAttrNodeDescr"><a name="setAttrNodeDescr"></a>setAttrNode(where,
	      attrname, attrvalue, name='')</h4>

	    <p class="first">Sets the attribute <em>attrname</em> with value
	      <em>attrvalue</em> under <em>where.name</em> location.
	    </p>
	    <dl>

		<dt>where</dt> <dd>Can be a path string or
		  <tt class="verb">Group</tt> instance. If <em>where</em>
		  doesn't exists or has not a child called
		  <em>name</em>, a <tt class="verb">ValueError</tt> error is
		  raised.
		</dd>

		<dt>attrname</dt> <dd>The name of the attribute
		  to set on disk.
		</dd>

		<dt>attrvalue</dt> <dd>The value of the
		  attribute to set. Only strings attributes are
		  supported natively right now. However, you can
		  always use <tt class="verb">(c)Pickle</tt> so as to serialize
		  any object you want save therein.
		</dd>

		<dt>name</dt> <dd>The node name desired. If
		  <em>name</em> is a null string (''), or not
		  supplied, this method assumes to find the object in
		  <em>where</em>.
		</dd>

	    </dl>
	  </div>

	  <div>
	    <h4 id="listNodesDescr"><a name="listNodesDescr"></a>listNodes(where,
	      classname='')</h4>

	    <p class="first">Returns a list with all the object nodes (Group or
	      Leaf) hanging from <em>where</em>. The list is
	      alphanumerically sorted by node name.
	    </p>
	    <dl>

		<dt>where</dt> <dd>The parent group. Can be a
		  path string or <tt class="verb">Group</tt> instance.
		</dd>

		<dt>classname</dt> <dd>If a <em>classname</em>
		  parameter is supplied, the iterator will return only
		  instances of this class (or subclasses of it). The
		  only supported classes in <em>classname</em> are
		  <tt class="verb">'Group'</tt>, <tt class="verb">'Leaf'</tt>,
		  <tt class="verb">'Table'</tt> and <tt class="verb">'Array'</tt>. Note
		  that these values are strings.
		</dd>

	    </dl>
	  </div>

	  <div>
	    <h4 id="removeNodeDescr"><a name="removeNodeDescr"></a>removeNode(where, name = "",
	      recursive=0)</h4>

	    <p class="first">Removes the object node
	      <em>name</em> under <em>where</em> location.
	    </p>
	    <dl>

		<dt>where</dt> <dd>Can be a path string or
		  <tt class="verb">Group</tt> instance.  If <em>where</em>
		  doesn't exists or has not a child called
		  <em>name</em>, a <tt class="verb">LookupError</tt> error is
		  raised.</dd>

		<dt>name</dt> <dd>The name of the node to be
		  removed. If not provided, the <em>where</em> node is
		  changed.</dd>

		<dt>recursive</dt> <dd>If not supplied, the
		  object will be removed only if it has no
		  children. If supplied with a true value, the object
		  and all its descendants will be completely
		  removed.</dd>

	    </dl>
	  </div>

	  <div>
	    <h4 id="renameNodeDescr"><a name="renameNodeDescr"></a>renameNode(where, newname,
	      name)</h4>

	    <p class="first">Rename the object node <em>name</em> under
	      <em>where</em> location.
	    </p>
	    <dl>

		<dt>where</dt> <dd>Can be a path string or
		  <tt class="verb">Group</tt> instance.  If <em>where</em>
		  doesn't exists or has not a child called
		  <em>name</em>, a <tt class="verb">LookupError</tt> error is
		  raised.</dd>

		<dt>newname</dt> <dd>Is the new name to be
		  assigned to the node.</dd>

		<dt>name</dt> <dd>The name of the node to be
		  changed. If not provided, the <em>where</em> node is
		  changed.</dd>

	    </dl>
	  </div>

	  <div>
	    <h4 id="walkGroupsDescr"><a name="walkGroupsDescr"></a>walkGroups(where='/')</h4>

	    <p class="first"><em>Iterator</em> that returns the list of Groups (not
	      Leaves) hanging from <em>where</em>. If <em>where</em>
	      is not supplied, the root object is taken as origin. The
	      returned Group list is in a top-bottom order, and
	      alphanumerically sorted when they are at the same level.
	    </p>
	    <dl>

		<dt>where</dt> <dd>The origin group. Can be a
		  path string or <tt class="verb">Group</tt> instance.
		</dd>

	    </dl>
	  </div>

	  <div>
	    <h4 id="subsubsection4.4.2.11">flush()</h4>

	    <p class="first">Flush all the leaves in the object tree.
	    </p>
	  </div>

	  <div>
	    <h4 id="subsubsection4.4.2.12">close()</h4>

	    <p class="first">Flush all the leaves in object tree and close the file.
	    </p>
	  </div>

	</div>

	<div>
	  <h3 id="subsection4.4.3"><span class="headlinenumber"><a name="subsection4.4.3"></a>4.4.3 </span><tt>File</tt> special
	      methods</h3>

	  <p class="first">Following are described the methods that automatically
	    trigger actions when a <tt class="verb">File</tt> instance is
	    accessed in a special way (e.g.,
	    <tt class="verb">fileh("/detector")</tt> will cause a call to
	    <tt class="verb">group.__call__("/detector")</tt>).
	  </p>

	  <div>
	    <h4 id="__callFileDescr"><a name="__callFileDescr"></a>__call__(where="/",
	      classname="")</h4>

	    <p class="first">Recursively iterate over the children in the
	      <tt class="verb">File</tt> instance. It takes two parameters:</p>

	    <dl>

	      <dt>where</dt> <dd>If supplied, the iteration
	      starts from this group.</dd>

	      <dt>classname</dt> <dd><em>(String)</em> If
	      supplied, only instances of this class are
	      returned.</dd>

	    </dl>

	    <p>Example of use:</p>

	    <pre>
	      # Recursively print all the nodes hanging from '/detector'
	      print "Nodes hanging from group '/detector':"
	      for node in h5file("/detector"):
	          print node
	    </pre>

	  </div>

	  <div>
	    <h4 id="__iterFileDescr"><a name="__iterFileDescr"></a>__iter__()</h4>

	    <p class="first">Iterate over the children on the <tt class="verb">File</tt>
	      instance. However, this does not accept parameters. This
	      iterator <em>is recursive</em>.</p>

	    <p>Example of use:</p>

	    <pre>
	      # Recursively list all the nodes in the object tree
	      print "All nodes in the object tree:"
	      for node in h5file:
	          print node
	    </pre>

	  </div>

	</div>

      </div>

      <div id="GroupClassDescr"><a name="GroupClassDescr"></a>
	<h2 id="section4.5"><span class="headlinenumber"><a name="section4.5"></a>4.5 </span>The <tt>Group</tt> class</h2>

	<p class="first">Instances of this class are a grouping structure containing
	  instances of zero or more groups or leaves, together with
	  supporting metadata.
	</p>

	<p>Working with groups and leaves is similar in many ways to
	  working with directories and files, respectively, in a Unix
	  filesystem. As with Unix directories and files, objects in
	  the object tree are often described by giving their full (or
	  absolute) path names. This full path can be specified either
	  as string (like in <tt class="verb">'/group1/group2'</tt>) or as a
	  complete object path written in the Pythonic fashion known
	  as <em>natural name</em> schema (like in
	  <tt class="verb">file.root.group1.group2</tt>) and discussed in the
	  <a href="usersguide1.html#ObjectTreeSection">section&nbsp;1.2</a>.
	</p>

	<p>A collateral effect of the <em>natural naming</em> schema
	  is that you must be aware when assigning a new attribute
	  variable to a Group object to not collide with existing
	  children node names. For this reason and to not pollute the
	  children namespace, it is explicitly forbidden to assign
	  "normal" attributes to Group instances, and the only ones
	  allowed must start with some reserved prefixes, like
	  "<tt class="verb">_f_</tt>" (for methods) or "<tt class="verb">_v_</tt>" (for
	  instance variables) prefixes. Any attempt to assign a new
	  attribute that does not starts with these prefixes, will
	  raise a <tt class="verb">NameError</tt> exception.
	</p>

	<p>Other effect is that you cannot use reserved Python names
	  or other non-allowed python names (like for example "$a" or
	  "44") as node names. You can, however, make use of a
	  translation map dictionary in the
	  <tt class="verb">File.openfile()</tt> method (see section <a href="#openFileDescr"><strong>??</strong></a>) so as to use non valid Python
	  names as node names in the file.
	</p>

	<div>

	  <h3 id="subsection4.5.1"><span class="headlinenumber"><a name="subsection4.5.1"></a>4.5.1 </span><tt>Group</tt> instance
	    variables</h3>
	  <dl>

	    <dt>_v_title</dt>
	    <dd>A description for this group.</dd>

	    <dt>_v_name</dt>
	    <dd>The name of this group.</dd>

	    <dt>_v_hdf5name</dt> <dd>The name of this group in
	      HDF5 file namespace.</dd>

	    <dt>_v_pathname</dt>
	    <dd>A string representation of the group location
	      in tree.</dd>

	    <dt>_v_parent</dt>
	    <dd>The parent Group instance.</dd>

	    <dt>_v_rootgroup</dt>
	    <dd>Pointer to the root group object.</dd>

	    <dt>_v_file</dt>
	    <dd>Pointer to the associated File object.</dd>

	    <dt>_v_childs</dt> <dd>Dictionary with all nodes
	      (groups or leaves) hanging from this instance.</dd>

	    <dt>_v_groups</dt> <dd>Dictionary with all node
	      groups hanging from this instance.</dd>

	    <dt>_v_leaves</dt> <dd>Dictionary with all node
	      leaves hanging from this instance.</dd>

	    <dt>_v_attrs</dt> <dd>The associated
	    <tt class="verb">AttributeSet</tt> instance (see <a href="#AttributeSetClassDescr">4.10</a>).</dd>

	  </dl>

	</div>

	<div>
	  <h3 id="subsection4.5.2"><span class="headlinenumber"><a name="subsection4.5.2"></a>4.5.2 </span><tt>Group</tt> methods</h3>

	  <div class="p-first">This class define the <tt class="verb">__setattr__</tt>,
	    <tt class="verb">__getattr__</tt> and <tt class="verb">__delattr__</tt> and
	    they work as normally intended. So, you can access, assign
	    or delete childs to a group by just using the next
	    constructs:

	    <pre>
	      # Add a Table child instance under group with name "tablename"
	      group.tablename = Table(recordDict, "Record instance")
	      table = group.tablename     # Get the table child instance
	      del group.tablename         # Delete the table child instance
	    </pre>             

	  </div>

	  <p><b>Caveat: </b>The following
	    methods are documented for completeness, and they can be
	    used without any problem. However, you should use the
	    high-level counterpart methods in the <tt class="verb">File</tt>
	    class, because these are most used in documentation and
	    examples, and are a bit more powerful than ones those
	    exposed here.
	  </p>

	  <dl>

	    <dt>_f_join(name)</dt>
	    <dd>Helper method to correctly concatenate a name child object
	      with the pathname of this group.</dd>

	    <dt>_f_rename(newname)</dt>
	    <dd>Change the name of this group to <em>newname</em>.</dd>

	    <dt>_f_remove(recursive=0)</dt> <dd>Remove this
	      object. If <em>recursive</em> is true, force the removal
	      even if this group has children.</dd>

	    <dt>_f_getAttr(attrname)</dt> <dd>Gets the HDF5
	      attribute <em>attrname</em> of this group.</dd>

	    <dt>_f_setAttr(attrname, attrvalue)</dt> <dd>Sets
	      the attribute <em>attrname</em> of this group to the
	      value <em>attrvalue</em>. Only string values are
	      allowed.</dd>

	    <dt>_f_listNodes(classname='')</dt> <dd>Returns a
	      <em>list</em> with all the object nodes hanging from
	      this instance. The list is alphanumerically sorted by
	      node name. If a <em>classname</em> parameter is
	      supplied, it will only return instances of this class
	      (or subclasses of it). The supported classes in
	      <em>classname</em> are <tt class="verb">'Group'</tt>,
	      <tt class="verb">'Leaf'</tt>, <tt class="verb">'Table'</tt> and
	      <tt class="verb">'Array'</tt>.</dd>

	    <dt>_f_walkGroups()</dt> <dd>Iterator that returns
	      the list of Groups (not Leaves) hanging from
	      <em>self</em>. The returned Group list is in a
	      top-bottom order, and alphanumerically sorted when they
	      are at the same level. </dd>

	    <dt>_f_close()</dt> <dd>Close this group, making it
	      and its children unaccessible in the object tree.</dd>

	  </dl>

	</div>

	<div>
	  <h3 id="subsection4.5.3"><span class="headlinenumber"><a name="subsection4.5.3"></a>4.5.3 </span><tt>Group</tt> special
	      methods</h3>

	  <p class="first">Following are described the methods that automatically
	    trigger actions when a <tt class="verb">Group</tt> instance is
	    accessed in a special way (e.g.,
	    <tt class="verb">group("Table")</tt> will cause a call to
	    <tt class="verb">group.__call__("Table")</tt>).
	  </p>

	  <div>
	    <h4 id="__callGroupDescr"><a name="__callGroupDescr"></a>__call__(classname="",
	      recursive=0)</h4>

	    <p class="first">Iterate over the childs in the <tt class="verb">Group</tt>
	      instance. It takes two parameters:</p>

	    <dl>

	      <dt>classname</dt> <dd><em>(String)</em> If
	      supplied, only instances of this class are
	      returned.</dd>

	      <dt>recursive</dt> <dd><em>(Integer)</em> If
	      false, only childs hanging immediately after the group
	      are returned. If true, a recursion over all the groups
	      hanging from it is performed. </dd>

	    </dl>

	    <p>Example of use:</p>

	    <pre>
	      # Recursively print all the arrays hanging from '/'
	      print "Arrays the object tree '/':"
	      for array in h5file.root(classname="Array", recursive=1):
	          print array
	    </pre>

	  </div>

	  <div>
	    <h4 id="__iterGroupDescr"><a name="__iterGroupDescr"></a>__iter__()</h4>

	    <p class="first">Iterate over the childs on the group instance. However,
	      this does not accept parameters. This iterator is not
	      recursive.</p>

	    <p>Example of use:</p>

	    <pre>
	      # Non-recursively list all the nodes hanging from '/detector'
	      print "Nodes in '/detector' group:"
	      for node in h5file.root.detector:
	          print node
	    </pre>

	  </div>

	</div>

      </div>

      <div id="LeafClassDescr"><a name="LeafClassDescr"></a>
	<h2 id="section4.6"><span class="headlinenumber"><a name="section4.6"></a>4.6 </span>The <tt>Leaf</tt> class</h2>

	<p class="first">This is a helper class useful to place common functionality
	  of all Leaf objects. It is also useful for classifying
	  purposes. A Leaf object is an end-node, that is, a node that
	  can hang directly from a group object, but that is not a
	  group itself. Right now this set is composed by
	  <tt class="verb">Table</tt> and <tt class="verb">Array</tt> objects. In fact,
	  <tt class="verb">Table</tt> and <tt class="verb">Array</tt> classes inherit
	  functionality from this class using the <em>mix-in</em>
	  technique.
	</p>

	<p>The public variables and methods that <tt class="verb">Table</tt>
	  and <tt class="verb">Array</tt> inherits from <tt class="verb">Leaf</tt> are
	  listed below.</p>

	<div>
	  <h3 id="subsection4.6.1"><span class="headlinenumber"><a name="subsection4.6.1"></a>4.6.1 </span><tt>Leaf</tt> instance
	    variables</h3>
	  <dl>

	    <dt>name</dt> <dd>The Leaf node name in Python
	      namespace.</dd>
	    
	    <dt>hdf5name</dt> <dd>The Leaf node name in HDF5
	      namespace.</dd>
	    
	    <dt>title</dt> <dd>The Leaf title.</dd>

	    <dt>shape</dt> <dd>The shape of the associated data
	      in the Leaf.</dd>

	    <dt>byteorder</dt> <dd>The byteorder of
	      the associated data of the Leaf.</dd>

	    <dt>attrs</dt> <dd>The associated
	    <tt class="verb">AttributeSet</tt> instance (see <a href="#AttributeSetClassDescr">4.10</a>).</dd>

	  </dl>
	</div>

	<div>
	  <h3 id="subsection4.6.2"><span class="headlinenumber"><a name="subsection4.6.2"></a>4.6.2 </span><tt>Leaf</tt> methods</h3>
	  <dl>

	    <dt>rename(newname)</dt>
	    <dd>Change the name of this leaf to <em>newname</em>.</dd>

	    <dt>remove()</dt> <dd>Remove this
	      leaf.</dd>

	    <dt>getAttr(attrname)</dt> <dd>Gets the HDF5
	      attribute <em>attrname</em> of this leaf.</dd>

	    <dt>setAttr(attrname, attrvalue)</dt> <dd>Sets
	      the attribute <em>attrname</em> of this leaf to the
	      value <em>attrvalue</em>. Only string values are
	      allowed.</dd>

	    <dt>flush()</dt> <dd>Flush the leaf buffers.</dd>

	    <dt>close()</dt> <dd>Flush the leaf buffers and
	      close the HDF5 dataset.</dd>

	  </dl>
	</div>

      </div>

      <div id="TableClassDescr"><a name="TableClassDescr"></a>
	<h2 id="section4.7"><span class="headlinenumber"><a name="section4.7"></a>4.7 </span>The <tt>Table</tt> class</h2>

	<p class="first">Instances of this class represents table objects in the
	  object tree. It provides methods to create new tables or
	  open existing ones, as well as methods to read/write data
	  and metadata from/to table objects in the file.
	</p>
	<p>Data can be read from or written to tables by accessing to
	  an special object that hangs from <tt class="verb">Table</tt>. This
	  object is an instance of the <tt class="verb">Row</tt> class (see
	  <a href="#RowClassDescr">4.8</a>). See the tutorial
	  sections <a href="usersguide3.html#usage">chapter&nbsp;3</a> on how to use the
	  <tt class="verb">Row</tt> interface.
	</p>
	<p>Please note that this object inherits all the public
	  attributes and methods that <tt class="verb">Leaf</tt> has.
	</p>

	<div>
	  <h3 id="subsection4.7.1"><span class="headlinenumber"><a name="subsection4.7.1"></a>4.7.1 </span><tt>Table</tt> instance
	    variables</h3>
	  <dl>

	    <dt>description</dt> <dd>The metaobject describing
	      this table</dd>

	    <dt>row</dt> <dd>The <tt class="verb">Row</tt> instance for
	      this table (see <a href="#RowClassDescr">4.8</a>).</dd>

	    <dt>nrows</dt>
	    <dd>The number of rows in this table.</dd>

	    <dt>colnames</dt>
	    <dd>The field names for the table (list).</dd>

	    <dt>coltypes</dt>
	    <dd>The data types for the table fields (dictionary).</dd>

	    <dt>colshapes</dt>
	    <dd>The shapes for the table fields (dictionary).</dd>

	  </dl>

	</div>

	<div>
	  <h3 id="subsection4.7.2"><span class="headlinenumber"><a name="subsection4.7.2"></a>4.7.2 </span><tt>Table</tt> methods</h3>

	  <div>
	    <h4 id="iterrowsDescr"><a name="iterrowsDescr"></a>iterrows(start=None,
	      stop=None, step=None)</h4>


	    <p class="first">Returns an iterator yielding Row instances built from
	      rows in table. If a range is supplied (i.e. some of the
	      <em>start</em>, <em>stop</em> or <em>step</em>
	      parameters are passed), only the appropriate rows are
	      returned. Else, all the rows are returned.
	    </p>
	    <dl>
		<dt>start</dt> <dd>Sets the starting row to
		  return data. A value of 0 means the first row. It
		  accepts negative values meaning that the count
		  starts from the end.</dd>

		<dt>stop</dt> <dd>Sets the last row to be
		  returned to <em>stop - 1</em>, i.e. the end point is
		  omitted (in the Python <tt class="verb">range</tt>
		  tradition). It accepts, likewise <em>start</em>,
		  negative values. A special value of 0 means the last
		  row.
		</dd>

		<dt>step</dt> <dd>When step is given, it
		  specifies the increment. Negative values are not
		  allowed right now.</dd>

	      </dl>
	  </div>

	  <div>
	    <h4 id="readDescr"><a name="readDescr"></a>read(self, start=None, stop=None,
	      step=None, field=None, flavor=None)</h4>

	    <p class="first">Returns the actual data in <tt class="verb">Table</tt>. If
	      <em>field</em> is not supplied, it returns the data as a
	      <tt class="verb">RecArray</tt> object table.
	    </p>
	    <dl>

		<dt>start</dt> <dd>Sets the starting row to
		  return data. A value of 0 means the first row. It
		  accepts negative values meaning that the count
		  starts from the end.</dd>

		<dt>stop</dt> <dd>Sets the last row to be
		  returned to <em>stop - 1</em>, i.e. the end point is
		  omitted (in the Python <tt class="verb">range</tt>
		  tradition). It accepts, likewise <em>start</em>,
		  negative values. A special value of 0 means the last
		  row.
		</dd>

		<dt>step</dt> <dd>When step is given, it
		  specifies the increment. Negative values are not
		  allowed right now.</dd>

		<dt>field</dt> <dd>If specified, only the column
		  <em>field</em> is returned as a
		  <tt class="verb">NumArray</tt> object. If this is not
		  supplied, all the fields are selected and a
		  <tt class="verb">RecArray</tt> is returned.</dd>

		<dt>flavor</dt> <dd>When a field in table is
		  selected, passing a <em>flavor</em> parameter make
		  an additional conversion to happen in the default
		  <tt class="verb">NumArray</tt> object. <em>flavor</em> must
		  have any of the next values: <tt class="verb">Numeric</tt>,
		  <tt class="verb">Tuple</tt> or <tt class="verb">List</tt>. </dd>

	    </dl>
	  </div>

	  <div>
	    <h4 id="removeRowsDescr"><a name="removeRowsDescr"></a>removeRows(start=None,
	      stop=None)</h4>

	    <p class="first">Removes a range of rows in the table.  If only
	      <em>start</em> is supplied, this row is to be
	      deleted. If a range is supplied, i.e. both the
	      <em>start</em> and <em>stop</em> parameters are passed,
	      all the rows in the range are removed<a href="#footnote5" name="footnoteback5"><sup title="However, for removeRows() to work, you need that the rows after the stop parameter will fit in-memory so as to method to work. This limitation will be hopefully removed in a future version.">5)</sup></a>. A <em>step</em>
	      parameter is not supported yet.
	    </p>
	    <dl>
		<dt>start</dt> <dd>Sets the starting row to
		  be removed. It accepts negative values meaning that
		  the count starts from the end. A value of 0 means
		  the first row.</dd>

		<dt>stop</dt> <dd>Sets the last row to be
		  removed to <em>stop</em> - 1, i.e. the end point is
		  omitted (in the Python <tt class="verb">range</tt>
		  tradition). It accepts, likewise <em>start</em>,
		  negative values. A special value of 0 means the last
		  row.
		</dd>

	      </dl>
	  </div>

	</div>
	<div>
	  <h3 id="subsection4.7.3"><span class="headlinenumber"><a name="subsection4.7.3"></a>4.7.3 </span><tt>Table</tt> special
	      methods</h3>

	  <p class="first">Following are described the methods that automatically
	    trigger actions when a <tt class="verb">Table</tt> instance is
	    accessed in a special way (e.g.,
	    <tt class="verb">table["var2"]</tt> will cause a call to
	    <tt class="verb">table.__getitem__("var2")</tt>).
	  </p>

	  <div>
	    <h4 id="__callTableDescr"><a name="__callTableDescr"></a>__call__(start=None,
	    stop=None, step=None)</h4>

	    <p class="first">It returns the same iterator than
	      <tt class="verb">Table.iterrows(start, stop, step)</tt>. It is,
	      therefore, a shorter way to call it.</p>

	    <p>Example of use:</p>

	    <pre>
	      result = [ row['var2'] for row in table(step=4)
                          	      if row['var1'] &lt;= 20 ]
	    </pre>

	    <p>Which is equivalent to:</p>

	    <pre>
	      result = [ row['var2'] for row in table.iterrows(step=4) 
                          	      if row['var1'] &lt;= 20 ]
	    </pre>

	  </div>
	  <div>
	    <h4 id="__iterTableDescr"><a name="__iterTableDescr"></a>__iter__()</h4>

	    <p class="first">It returns the same iterator than
	      <tt class="verb">Table.iterrows(0,0,1)</tt>. However, this does not
	      accept parameters.</p>

	    <p>Example of use:</p>

	    <pre>
	      result = [ row['var2'] for row in table 
                                      if row['var1'] &lt;= 20 ]
	    </pre>

	    <p>Which is equivalent to:</p>

	    <pre>
	      result = [ row['var2'] for row in table.iterrows() 
                          	      if row['var1'] &lt;= 20 ]
	    </pre>

	  </div>

	  <div>
	    <h4 id="__getitemTableDescr"><a name="__getitemTableDescr"></a>__getitem__(key)</h4>

	    <p class="first">It takes different actions depending on the
	      type of the <tt class="verb">key</tt> parameter:</p>

	    <dl>
	      <dt><tt>key</tt> is an
		<tt class="verb">Integer</tt></dt> <dd>The corresponding
		table row is returned as a
		<tt class="verb">RecArray.Record</tt> object.</dd>

	      <dt><tt>key</tt> is a
		<tt class="verb">Slice</tt></dt><dd>The row slice
		determined by <tt class="verb">key</tt> is returned as a
		<tt class="verb">RecArray</tt> object.</dd>

	      <dt><tt>key</tt> is a
		<tt class="verb">String</tt></dt> <dd>The <tt class="verb">key</tt>
		is interpreted as a <em>column</em> name of the table,
		and, if it exists, it is read and returned as a
		<tt class="verb">NumArray</tt> or <tt class="verb">CharArray</tt> object
		(whatever is appropriate).</dd>
	    </dl>

	    <p>Example of use:</p>

	    <pre>
	      record = table[4]
	      recarray = table[4:1000:2]
	      narray = table["var2"]
	    </pre>

	    <p>Which is equivalent to:</p>

	    <pre>
	      record = table.read(start=4)[0]
	      recarray = table.read(start=4, stop=1000, step=2)
	      narray = table.read(field="var2")
	    </pre>

	  </div>
	</div>
      </div>

      <div id="RowClassDescr"><a name="RowClassDescr"></a>
	<h2 id="section4.8"><span class="headlinenumber"><a name="section4.8"></a>4.8 </span>The <tt>Row</tt> class</h2>

	<p class="first">This class is used to fetch and set values on the table
	  fields. It works very much like a dictionary, where the keys
	  are the field names of the associated table and the values
	  are the values of those fields in a specific row.
	</p>
	<p>This object turns out to actually be an extension type, so
	  you won't be able to access their documentation
	  interactively. Neither you won't be able to access it's
	  internal attributes (they are not directly accessible from
	  Python), although that <em>accessors</em> (i.e. methods that
	  return an internal attribute) has been defined for the most
	  important variables.
	</p>

	<div>
	  <h3 id="subsection4.8.1"><span class="headlinenumber"><a name="subsection4.8.1"></a>4.8.1 </span><tt>Row</tt>
	    methods</h3>

	  <dl>

	    <dt id="appendRowDescr"><a name="appendRowDescr"></a>append()</dt> <dd>Once you
	    have filled the proper fields for the current row, calling
	    this method actually commit this data to the disk
	    (actually data is written to the output buffer).</dd>

	    <dt>nrow()</dt> <dd>Accessor that returns the current
	      row in the table. It is useful to know which row is being
	      dealt with in the middle of a loop.</dd>
	  </dl>
	</div>
      </div>

      <div id="ArrayClassDescr"><a name="ArrayClassDescr"></a>
	<h2 id="section4.9"><span class="headlinenumber"><a name="section4.9"></a>4.9 </span>The <tt>Array</tt>
	class</h2>

	<p class="first">Represents an array on file. It provides methods to create
	  new arrays or open existing ones, as well as methods to
	  write/read data and metadata to/from array objects in the
	  file.
	</p>

	<p><b>Caveat:</b> All
	  <tt class="verb">Numeric</tt> and <tt class="verb">numarray</tt> data types
	  are supported except those that corresponds to complex data
	  types<a href="#footnote6" name="footnoteback6"><sup title="However, these might be included in the future">6)</sup></a>. See <tt class="verb">numarray</tt> manual (<a href="#Numarray"></a>) to know more about the supported
	  data types, or see <a href="usersguide6.html#datatypesSupported">appendix&nbsp;A</a>.
	</p>

	<p>Please note that this object inherits all the public
	  attributes and methods from <tt class="verb">Leaf</tt>.
	</p>

	<div id="ArrayClassInstanceVariables"><a name="ArrayClassInstanceVariables"></a>
	  <h3 id="subsection4.9.1"><span class="headlinenumber"><a name="subsection4.9.1"></a>4.9.1 </span><tt>Array</tt> instance
	    variables</h3>
	  <dl>

	    <dt>type</dt> <dd>The type class of the represented
	      array.</dd>

	    <dt>flavor</dt> <dd>The string object representation
	      for this array. It can be any of <em>"NumArray"</em>,
	      <em>"CharArray"</em>, <em>"Numeric"</em>,
	      <em>"List"</em>, <em>"Tuple"</em>, <em>"String"</em>,
	      <em>"Int"</em> or <em>"Float"</em> values.</dd>

	  </dl>

	</div>

	<div>
	  <h3 id="subsection4.9.2"><span class="headlinenumber"><a name="subsection4.9.2"></a>4.9.2 </span><tt>Array</tt>
	    methods</h3>

	  <p class="first">Note that, as this object has not internal I/O buffers,
	    there is no point in calling flush() method inherited from
	    <tt class="verb">Leaf</tt>.
	  </p>

	  <dl>

	    <dt id="readArrayDescr"><a name="readArrayDescr"></a>read()</dt> <dd>Read the
	      array from disk and return it as a <tt class="verb">NumArray</tt>
	      (default) object, or if possible, with the original
	      <em>flavor</em> that it was saved. The supported flavors
	      are: <tt class="verb">NumArray</tt>, <tt class="verb">CharArray</tt>,
	      <tt class="verb">Numeric</tt>, <tt class="verb">List</tt>,
	      <tt class="verb">Tuple</tt>, <tt class="verb">String</tt>,
	      <tt class="verb">Int</tt> or <tt class="verb">Float</tt>. Note that as
	      long as this method is not called, the actual array data
	      is resident on disk, not in memory.</dd>

	  </dl>
	</div>
      </div>

      <div id="AttributeSetClassDescr"><a name="AttributeSetClassDescr"></a>
	<h2 id="section4.10"><span class="headlinenumber"><a name="section4.10"></a>4.10 </span>The <tt>AttributeSet</tt>
	class</h2>

	<p class="first">Represents the set of attributes of a node (Leaf or
	  Group). It provides methods to create new attributes, open,
	  rename or delete existing ones.
	</p>

	<p>Like in <tt class="verb">Group</tt> instances,
           <tt class="verb">AttributeSet</tt> instances use a special feature
           called <em>natural naming</em>, i.e. you can access the
           attributes on disk like if they were <em>normal</em>
           <tt class="verb">AttributeSet</tt> attributes. This offers the user
           a very convenient way to access (but also set and delete)
           node attributes by simply specifying them like a
           <em>normal</em> attribute class.
        </p>

	<p><b>Caveat:</b> All Python data types
	  are supported. The scalar ones (i.e. String, Int and Float)
	  are mapped directly to the HDF5 counterparts, so you can
	  correctly visualize them with any HDF5 tool. However, the
	  rest of the data types and more general objects are
	  serialized using <tt class="verb">cPickle</tt>, so you will be able
	  to correctly retrieve them only from a Python-aware HDF5
	  library. Hopefully, the list of supported native attributes
	  will be extended to multidimensional arrays sometime in the
	  future.
	</p>

	<div id="AttributeSetClassInstanceVariables"><a name="AttributeSetClassInstanceVariables"></a>
	  <h3 id="subsection4.10.1"><span class="headlinenumber"><a name="subsection4.10.1"></a>4.10.1 </span><tt>AttributeSet</tt> instance
	    variables</h3>
	  <dl>

	    <dt>_v_node</dt> <dd>The parent node instance.</dd>

	    <dt>_v_attrnames</dt> <dd>List with all attribute
	      names.</dd>

	    <dt>_v_attrnamessys</dt> <dd>List with system attribute
	      names.</dd>

	    <dt>_v_attrnamesuser</dt> <dd>List with user attribute
	      names.</dd>

	  </dl>

	</div>

	<div>
	  <h3 id="subsection4.10.2"><span class="headlinenumber"><a name="subsection4.10.2"></a>4.10.2 </span><tt>AttributeSet</tt>
	    methods</h3>

	  <div class="p-first">Note that this class define the <tt class="verb">__setattr__</tt>,
	    <tt class="verb">__getattr__</tt> and <tt class="verb">__delattr__</tt> and
	    they work as normally intended. So, you can access, assign
	    or delete attributes on disk by just using the next
	    constructs:

	    <pre>
	      leaf.attrs.myattr = "string attr"  # Set the attribute myattr
	      attrib = leaf.attrs.myattr  # Get the attribute myattr
	      del leaf.attrs.myattr       # Delete the attribute myattr
	    </pre>             

	  </div>

	  <dl>
	    <dt id="listAttrDescr"><a name="listAttrDescr"></a>_f_list(attrset = "user")
	    </dt><dd>Return the list of attributes of the parent
	      node.

		<dl>
		  <dt>attrset</dt> <dd>Selects the attribute set
		    to be returned. An <tt class="verb">"user"</tt> value
		    returns only the user attributes. This is the
		    default. <tt class="verb">"sys"</tt> returns only the
		    system (some of which are read-only)
		    attributes. <tt class="verb">"readonly"</tt> returns the
		    system read-only attributes. <tt class="verb">"all"</tt>
		    returns both the system and user
		    attributes.</dd>
		</dl>
	      </dd>

	    <dt id="renameAttrDescr"><a name="renameAttrDescr"></a>_f_rename(oldattrname,
	      newattrname)</dt><dd>Rename an attribute.</dd>
	  </dl>

	</div>

      </div>
    </div><hr align="left" noshade="true" class="footnoterule"><div class="footnote"><a name="footnote4" href="#footnoteback4"><sup>4)</sup></a>&nbsp;On the following, the term <tt class="verb">Leaf</tt>
	  will whether refer to a <tt class="verb">Table</tt> or
	  <tt class="verb">Array</tt> node object.</div><div class="footnote"><a name="footnote5" href="#footnoteback5"><sup>5)</sup></a>&nbsp;However,
	      for <tt class="verb">removeRows()</tt> to work, you need that the
	      rows <b>after</b> the
	      <tt class="verb">stop</tt> parameter will fit in-memory so as to
	      method to work. This limitation will be hopefully
	      removed in a future version.</div><div class="footnote"><a name="footnote6" href="#footnoteback6"><sup>6)</sup></a>&nbsp;However, these might be included in the
	  future</div></div><div class="speedbar-bottom"><hr class="speedbar"><table class="speedbar"><tbody><tr><td style="text-align: left; width: 15%"><a href="usersguide3.html">previous</a></td><td style="text-align: center"><a href="usersguide.html#tb:table-of-contents">Table of Contents</a></td><td style="text-align: right; width: 15%"><a href="usersguide5.html">next</a></td></tr></tbody></table></div></body></html>