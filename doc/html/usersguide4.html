<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>PyTables User's Guide</title><meta http-equiv="Content-Type" content="text/html"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="generator" content="The tbook system at http://tbookdtd.sourceforge.net"><meta name="robots" content="index"><meta name="DC.Title" content="PyTables User's Guide"><meta name="DC.Description" content="PyTables User's Guide Hierarchical datasets in Python Release 0.9"><meta name="DC.Creator" content="Francesc Altet"><meta name="Author" content="Francesc Altet"><meta name="DC.Creator" content="Scott Prater"><meta name="Author" content="Scott Prater"><meta name="DC.Creator" content="Ivan Vilata"><meta name="Author" content="Ivan Vilata"><meta name="DC.Creator" content="Tom Hedley"><meta name="Author" content="Tom Hedley"><meta name="DC.Date" content="2004-11-05T16:54:26+01:00"><meta name="Date" content="2004-11-05T16:54:26+01:00"><meta name="DC.Rights" content="(c) 2002, 2003, 2004 Francesc Altet"><meta name="Copyright" content="(c) 2002, 2003, 2004 Francesc Altet"><meta name="DC.Type" content="Text"><meta name="DC.Format" content="text/html"><meta name="DC.Language" scheme="rfc3066" content="en"><meta name="Language" content="en"><meta http-equiv="Content-Style-Type" content="text/css"><style type="text/css">
    body {
      font-family: serif; text-align: justify;
      margin: 0pt; line-height: 1.3; background-color: white; color: black }
    body.letter { background-image: none }
    h1, h2, h3, h4, h5, h6, div.partheadline, div.title,
      div.title-article {
      font-family: sans-serif; font-weight: bold; font-stretch: condensed;
      text-align: left; }
    h1, h2, h3, h4, h5, h6, div.partheadline { padding-left: 18pt }
    h1 { clear: both }
    h1.toc { clear: none }
    a:link, a:visited, a:active { text-decoration: none }
    a:hover[href] { text-decoration: underline; color: #0066FF; }
    div.document, div.letter { margin-left: 80px; margin-right: 150px;
      padding-top: 3ex; padding-bottom: 5ex }
    div.authorlist { font-family: sans-serif;
      font-stretch: condensed; text-align: left; font-size: x-large;
      margin-bottom: 1ex }
    div.authorlist-article { font-size: x-large; text-align: center;
      margin-bottom: 2ex }
    div.title { font-size: xx-large; color: gray; margin-bottom: 5ex; }
    div.title-article { font-size: xx-large; text-align: center;
      margin-bottom: 1ex }
    div.date-article { font-size: large; text-align: center;
      margin-bottom: 5ex }
    div.subtitle { text-align: left; margin-bottom: 3ex }
    div.legal { text-align: right }
    div.legalnotice { margin-top: 3ex; text-align: left }
    div.partheadline { font-size: xx-large; margin-top: 1ex; margin-bottom: 1ex }
    div.footnote { }
    hr.footnoterule { text-align: left; width: 40%; margin-right: 60%; color: black }
    div.mathdisplay { text-align: center;
    margin-top: 2ex; margin-bottom: 2ex }
    div.figure, div.table, div.mathml-remark { margin-bottom: 3ex;
            margin-top: 2ex}
    div.mathml-remark { width: 50%; text-align: left; text-indent: 0pt }
    div.caption { margin-top: 1ex; width: 20em}
    div.caption-text { font-size: small;
      padding-left: 1em; text-indent: -1em; text-align: left}
    caption { max-width: 100%; min-width: 200px; margin-bottom: 1ex;
      text-align: left }
    div.verse { white-space: pre; margin-left: 2em;
      margin-top: 2ex; margin-bottom: 2ex }
    div.toc { margin-bottom: 6ex }
    div.biblio { }
    div.index { width: 100% }
    div.aphorism { margin-bottom: 2ex; font-style: italic; text-align: right;
      margin-left: 50%}
    div.aphorism-origin { margin-top: 1ex }
    div.letter { }
    div.subject { margin-top: 3ex; margin-bottom: 3ex }
    div.opening { margin-top: 3ex; margin-bottom: 3ex }
    div.closing { margin-top: 3ex; text-align: right }
    div.to { margin-top: 3ex; margin-bottom: 3ex }
    span.subject { font-weight: bold }
    div.speedbar-top, div.speedbar-bottom { margin-left: 1em; margin-right: 1em }
    div.speedbar-top { margin-top: 2ex }
    div.speedbar-bottom { margin-bottom: 3ex }
    table.speedbar { width: 100% }
    hr.speedbar { clear: both }
    div.theorem-plain, div.theorem-definition, div.theorem-remark { margin-top: 2ex;
      margin-bottom: 2ex }
    div.theorem-plain { font-style: italic }
    div.proof { margin-top: 2ex; margin-bottom: 2ex }
    span.theorem-head-plain, span.theorem-head-definition, span.theorem-head-remark
      { margin-right: 0.66em }
    span.theorem-head-plain, span.theorem-head-definition
      { font-style: normal; font-weight: bold }
    span.theorem-head-remark { font-style: italic }
    span.proof-head { font-style: italic; margin-right: 0.66em }
    acronym { font-size: 95%; letter-spacing: 0.1em; text-transform: uppercase }
    td.header { text-align: center; font-weight: bold }
    table.toc { }
    table.tabular { font-size: smaller }
    td.thickline { height: 0pt; border-bottom: medium solid; padding: 2px }
    td.thinline { height: 0pt; border-bottom: thin solid;   padding: 2px }
     /* FixMe: Following definition Still bad */
    div.part-toc { margin-top: 2ex; font-weight: bold; font-size: larger }
     /* FixMe: Following definition: How cleaner? */
    div.toplevel-toc { margin-top: 1ex; font-weight: bold }
    td.number1 { width: 1.5em }
    td.number2 { width: 2em }
    td.number3 { width: 3em }
    td.author { text-align: center; width: 50% }
    div { }  /* Must remain empty! */
    span.captionlabel { font-family: sans-serif; font-weight: bold;
      margin-right: 0.66em }
    span.captionlabel:after { content: " " }
    b.captionlabel {  }
    b.captionlabel:after { content: " " }
    span.headlinenumber { margin-right: 0.66em }
    tt.verb {font-family: monospace }
    span.bibtag { font-weight: bold; margin-right: 1em }
    span.bib-author { }
    span.bib-lastname { font-variant: small-caps }
    span.bib-title { font-style: italic }
    span.bib-booktitle { }
    span.bib-journal { }
    span.bib-journal-volume { font-weight: bold }
    span.bib-publisher { }
    span.bib-school { }
    span.bib-year { }
    span.bib-note { }
    span { } /* Muss leer bleiben! */
    li.bibitem { margin-left: 1em; text-indent: -1em }
    img.graphics { border: 0pt }
    p,div.p { margin: 0pt; text-indent: 18pt }
    ul, dl, ol { text-indent: 0pt; }
    p.first, div.p-first { margin: 0pt; text-indent: 0pt }
    p.bibitem { margin-top: 1.5ex; margin-left: 3em; text-indent: -3em }
    ul.biblio { list-style: none }
    mi.ch { font-style: normal }
    math[display="block"], div.equation {
      margin-top: 1ex; margin-bottom: 1ex }
    div.i-lettergroup { font-size: larger; font-weight: bold; padding-left: 18pt;
      margin-top: 3ex; margin-bottom: 1.5ex }
    div.i-item { }
    div.i-main { }
    dt { display: compact; font-weight: bold }
    dd { text-indent: 0pt }
    pre { text-indent: 0pt }
    span.i-see { font-style: italic; }

h1 { color: red }
h2 { color: olive }
h3 { color: navy }
h4 { color: maroon }
body { /* background-image: url("tile.jpg"); */  /* Per a imprimir millor */
 font: 14px/1.5 Verdana, Arial, Helvetica, sans-serif;
 background:#fff;
 padding:5%;
 padding-top:2%;
 margin:0px;
}
/*     body { background-image: url("tile.jpg");
         background-color: white;
         color: black;
	 font-size: 13pt; } */
hr.footnoterule { color: white }
div.title { font-size: x-large; color: maroon }
div.subtitle { font-size: x-large; color: olive }
div.title-article { font-size: x-large }
div.partheadline { font-size: x-large }
</style></head><body><div class="speedbar-top"><table class="speedbar"><tbody><tr><td style="text-align: left; width: 15%"><a href="usersguide3.html">previous</a></td><td style="text-align: center"><a href="usersguide.html#tb:table-of-contents">Table of Contents</a></td><td style="text-align: right; width: 15%"><a href="usersguide5.html">next</a></td></tr><tr><td colspan="3">&nbsp;</td></tr></tbody></table><hr class="speedbar"></div><div class="document"><div id="libraryReference"><a name="libraryReference"></a>
      <h1 id="chapter4"><a name="chapter4"></a>Chapter&nbsp;4: Library Reference</h1>
      






      <p class="first"><tt class="verb">PyTables</tt> implements several classes to represent
	the different nodes in the object tree. They are named
	<tt class="verb">File</tt>, <tt class="verb">Group</tt>, <tt class="verb">Leaf</tt>,
	<tt class="verb">Table</tt>, <tt class="verb">Array</tt>, <tt class="verb">EArray</tt>,
	<tt class="verb">VLArray</tt> and <tt class="verb">UnImplemented</tt>. Another
	one allows the user to complement the information on these
	different objects; its name is
	<tt class="verb">AttributeSet</tt>. Finally, another important class
	called <tt class="verb">IsDescription</tt> allows to build a
	<tt class="verb">Table</tt> record description by declaring a subclass
	of it. Many other classes are defined in
	<tt class="verb">PyTables</tt>, but they can be regarded as helpers
	whose goal is mainly to declare the <em>data type
	properties</em> of the different first class objects and will
	be described at the end of this chapter as well.
      </p>
      <p>An important function, called <tt class="verb">openFile</tt> is
	responsible to create, open or append to files. In addition, a
	few utility functions are defined to guess if the user
	supplied file is a <em>PyTables</em> or <em>HDF5</em>
	file. These are called <tt class="verb">isPyTablesFile</tt> and
	<tt class="verb">isHDF5</tt>, respectively. Finally, there exists a
	function called <tt class="verb">whichLibVersion</tt> that informs
	about the versions of the underlying C libraries (for example,
	the <tt class="verb">HDF5</tt> or the <tt class="verb">Zlib</tt>).
      </p>

      <p>Let's start discussing the first-level variables and
	functions available to the user, then the different classes
	defined in <tt class="verb">PyTables</tt>.
      </p>

      <div>
	<h2 id="section4.1"><span class="headlinenumber"><a name="section4.1"></a>4.1 </span><tt>tables</tt> variables and
	  functions</h2>

	<div>
	  <h3 id="subsection4.1.1"><span class="headlinenumber"><a name="subsection4.1.1"></a>4.1.1 </span>Global variables</h3>

	  <dl>

	    <dt>__version__</dt> <dd>The <tt class="verb">PyTables</tt>
	    version number.</dd>

	    <dt>ExtVersion</dt> <dd>The version of the Pyrex
	      extension module. This might be useful when reporting
	      bugs.</dd>

	    <dt>HDF5Version</dt>
	    <dd>The underlying HDF5 library version number.</dd>

	  </dl>
	  
	</div>

	<div id="GlobalFunctDescr"><a name="GlobalFunctDescr"></a>
	  <h3 id="subsection4.1.2"><span class="headlinenumber"><a name="subsection4.1.2"></a>4.1.2 </span>Global functions</h3>

	  <div id="copyFileDescr"><a name="copyFileDescr"></a>
	    <h4 id="subsubsection4.1.2.1">copyFile(srcFilename=None, dstFilename=None, title=None,
	      filters=None, copyuserattrs=1, overwrite=0)
	    </h4>

	    <p class="first">Copy a closed <tt class="verb">PyTables</tt> (or generic
	      <tt class="verb">HDF5</tt>) file specified by
	      <em>srcFilename</em> to <em>dstFilename</em>. Returns a
	      tuple in the form <tt class="verb">(ngroups, nleaves,
	      nbytes)</tt> specifiying the number of groups, leaves
	      and bytes copied.
	    </p>

	    <dl>

	      <dt>title</dt> <dd>The title for the new
		file. If not specified, the source file title will
		be copied.
	      </dd>

	      <dt>filters</dt> <dd>A Filters instance (see
		<a href="#FiltersClassDescr">4.13.1</a>). If
		specified, it will override the original filter
		properties in <b>all</b>
		source nodes.
	      </dd>

	      <dt>copyuserattrs</dt> <dd>You can prevent the
		user attributes from being copied by setting this
		parameter to 0. The default is to copy them.
	      </dd>

	      <dt>overwrite</dt><dd>If
		<tt class="verb">dstFilename</tt> file already exists and
		overwrite is 1, it will be silently overwritten. The
		default is not overwriting.
	      </dd>

	    </dl>
	    
	  </div>

	  <div id="isHDF5Descr"><a name="isHDF5Descr"></a>
	    <h4 id="subsubsection4.1.2.2">isHDF5(filename)</h4>
	    
	    <p class="first">Determines whether filename is in the HDF5 format or
	      not. When successful, returns a positive value, for
	      TRUE, or 0 (zero), for FALSE. Otherwise returns a
	      negative value. To this function to work, it needs a
	      closed file.
	    </p>
	  </div>

	  <div id="isPyTablesFileDescr"><a name="isPyTablesFileDescr"></a>
	    <h4 id="subsubsection4.1.2.3">isPyTablesFile(filename)</h4>

	    <p class="first">Determines whether a file is in the
	      <tt class="verb">PyTables</tt> format.  When successful, returns
	      the format version string, for TRUE, or 0 (zero), for
	      FALSE. Otherwise returns a negative value. To this
	      function to work, it needs a closed file.
	    </p>

	  </div>

	  <div id="openFileDescr"><a name="openFileDescr"></a>
	    <h4 id="subsubsection4.1.2.4">openFile(filename, mode='r', title='', trMap={},
	      rootUEP="/", filters=None)</h4>

	    <p class="first">Open a <tt class="verb">PyTables</tt> (or generic
	      <tt class="verb">HDF5</tt>) file and returns a <tt class="verb">File</tt>
	      object.
	    </p>
	    
	    <dl>

	      <dt>filename</dt> <dd>The name of the file
		(supports environment variable expansion). It is
		suggested that it should have any of
		<tt class="verb">".h5"</tt>, <tt class="verb">".hdf"</tt> or
		<tt class="verb">".hdf5"</tt> extensions, although this is
		not mandatory.
	      </dd>

	      <dt>mode</dt> <dd>The mode to open the file. It
		can be one of the following:

		<dl>

		  <dt>'r'</dt> <dd>read-only; no data can be
		    modified.</dd>
		  
		  <dt>'w'</dt> <dd>write; a new file is
		    created (an existing file with the same name
		    would be deleted).</dd>

		  <dt>'a'</dt> <dd>append; an existing file is
		    opened for reading and writing, and if the file
		    does not exist it is created.</dd>
		  
		  <dt>'r+'</dt> <dd>is similar to 'a', but the
		    file must already exist.</dd>
		  
		</dl>
	      </dd>

	      <dt>title</dt> <dd>If filename is new, this will
		set a title for the root group in this file. If
		filename is not new, the title will be read from
		disk, and this will not have any effect.
	      </dd>

	      <dt>trMap</dt> <dd>A dictionary to map names in
		the object tree Python namespace into different HDF5
		names in file namespace. The keys are the Python
		names, while the values are the HDF5 names. This is
		useful when you need to use HDF5 node names with
		invalid or reserved words in Python.
	      </dd>

	      <dt>rootUEP</dt> <dd>The root User Entry
		Point. This is a group in the HDF5 hierarchy which
		will be taken as the starting point to create the
		object tree. The group has to be named after its
		HDF5 name and can be a path. If it does not exist, a
		<tt class="verb">RuntimeError</tt> exception is issued. Use
		this if you do not want to build the <b>entire</b> object tree, but rather
		only a <b>subtree</b> of it.
	      </dd>

	      <dt>filters</dt><dd>An instance of the
		<tt class="verb">Filters</tt> class (see section <a href="#FiltersClassDescr">4.13.1</a>) that provides
		information about the desired I/O filters applicable
		to the leaves that hangs directly from <em>root</em>
		(unless other filters properties are specified for
		these leaves). Besides, if you do not specify filter
		properties for its child groups, they will inherit
		these ones. So, if you open a new file with this
		parameter set, all the leaves that would be created
		in the file will recursively inherit this filtering
		properties (again, if you don't prevent that from
		happening by specifying other filters on the child
		groups or leaves).
	      </dd>

	    </dl>
	  </div>

	  <div id="whichLibVersionDescr"><a name="whichLibVersionDescr"></a>
	    <h4 id="subsubsection4.1.2.5">whichLibVersion(libname)</h4>

	    <p class="first">Returns info about versions of the underlying C
	      libraries. <b>libname</b> can be
	      whether <tt class="verb">"hdf5"</tt>, <tt class="verb">"zlib"</tt>,
	      <tt class="verb">"lzo"</tt> or <tt class="verb">"ucl"</tt>. It always
	      returns a tuple of 3 elements. When successful, the
	      first element of this tuple has a positive value, and is
	      0 (zero) when library is not available (for example LZO
	      or UCL). In case the library is available, the second
	      element of tuple contains the library version and the
	      third element the date (if available) of that version.
	    </p>

	  </div>
	</div>
      </div>

      <div id="FileClassDescr"><a name="FileClassDescr"></a>
	<h2 id="section4.2"><span class="headlinenumber"><a name="section4.2"></a>4.2 </span>The <tt>File</tt> class</h2>

	<p class="first">This class is returned when a <tt class="verb">PyTables</tt> file is
	  opened with the <tt class="verb">openFile</tt> function. It has
	  methods to flush and close files. Also, the
	  <tt class="verb">File</tt> class offers methods to create, rename and
	  delete nodes, as well as to traverse the object tree. One of
	  its attributes (<tt class="verb">rootUEP</tt>) represents the
	  <em>user entry point</em> to the object tree attached to the
	  file.
	</p>

	<p>Next, we will discuss the attributes and methods for File
	  class<a href="#footnote6" id="footnoteback6"><sup title="On the following, the term Leaf will refer to either a Table, Array, EArray, VLArray or UnImplemented node object.">6)</sup></a>.
	</p>

	<div id="FileInstanceVariablesDescr"><a name="FileInstanceVariablesDescr"></a>
	  <h3 id="subsection4.2.1"><span class="headlinenumber"><a name="subsection4.2.1"></a>4.2.1 </span><tt>File</tt> instance
	    variables</h3>
	  <dl>

	    <dt>filename</dt> <dd>Filename opened.</dd>

	    <dt>format_version</dt> <dd>The
	    <tt class="verb">PyTables</tt> version number of this file.</dd>

	    <dt>isopen</dt> <dd>It takes the value 1 if the
	      underlying file is open. 0 otherwise.</dd>

	    <dt>mode</dt> <dd>Mode in which the filename was
	      opened.</dd>

	    <dt>root</dt> <dd>The <em>root</em> of the object
	       tree hierarchy. It is a <tt class="verb">Group</tt> instance.
	    </dd>

	    <dt>rootUEP</dt> <dd>The UEP (User Entry Point)
	      group in file (see <a href="#openFileDescr">4.1.2</a>).</dd>

	    <dt>title</dt> <dd>The title of the root group in
	      file.</dd>

	    <dt>trMap</dt> <dd>This is a dictionary that maps
	      node names between python and HDF5 domain names. Its
	      initial values are set from the <em>trMap</em> parameter
	      passed to the <tt class="verb">openFile</tt> function. You can
	      change its contents <em>after</em> a file is opened and
	      the new map will take effect over any new object added
	      to the tree.
	    </dd>

	    <dt>filters</dt> <dd>Container for filter properties
	      associated to this file.  See <a href="#FiltersClassDescr">section&nbsp;4.13.1</a> for more
	      information on this object.
	    </dd>

	    <dt>objects</dt> <dd>Dictionary with all objects
	      (groups or leaves) on tree.</dd>

	    <dt>groups</dt> <dd>Dictionary with all object
	      groups on tree.</dd>

	    <dt>leaves</dt> <dd>Dictionary with all object
	      leaves on tree.</dd>

	  </dl>

	</div>

	<div>
	  <h3 id="subsection4.2.2"><span class="headlinenumber"><a name="subsection4.2.2"></a>4.2.2 </span><tt>File</tt> methods</h3>

	  <div id="FilecopyChildrenDescr"><a name="FilecopyChildrenDescr"></a>

	    <h4 id="subsubsection4.2.2.1">copyChildren(whereSrc, whereDst, recursive=0,
                   filters=None, copyuserattrs=1, start=0, stop=None,
                   step=1, overwrite = 0)
	    </h4>

	    <p class="first">Copy (recursively) the children of a group into another
	      location. Returns a tuple in the form <tt class="verb">(ngroups,
	      nleaves, nbytes)</tt> specifiying the number of
	      groups, leaves and bytes copied.
	    </p>

	    <dl>
	      <dt>whereSrc</dt> <dd>The parent group where the
		children to be copied are hanging on. This parameter
		can be a path string (for example
		<tt class="verb">"/level1/group5"</tt>), or another
		<tt class="verb">Group</tt> instance.
	      </dd>

	      <dt>whereDst</dt> <dd>The parent group where the
		source children will be copied to. This group must exist
		or a <tt class="verb">LookupError</tt> will be issued. This
		parameter can be a path string (for example
		<tt class="verb">"/level1/group6"</tt>), or another
		<tt class="verb">Group</tt> instance.
	      </dd>

	      <dt>recursive</dt> <dd>Specifies whether the copy
		should recurse into subgroups or not. The default is
		not recurse.
	      </dd>
	      
	      <dt>filters</dt> <dd>Whether or not override the
		original filter properties present in source nodes.
		This parameter must be an instance of the
		<tt class="verb">Filters</tt> class (see section<a href="#FiltersClassDescr">4.13.1</a>). The default is to
		copy the filter attributes from source children.
	      </dd>

	      <dt>copyuserattrs</dt> <dd>You can prevent the
		user attributes from being copied by setting this
		parameter to 0. The default is to copy them.
	      </dd>

	      <dt>start, stop, step</dt><dd>Specifies the range
		of rows in child leaves to be copied; the default is
		to copy all the rows.
	      </dd>

	      <dt>overwrite</dt><dd>Whether the possible
		existing children hanging from <tt class="verb">whereDst</tt>
		and having the same names than <tt class="verb">whereSrc</tt>
		children should overwrite the destination nodes or
		not.
	      </dd>
	    </dl>
	  </div> 

	  <div id="FilecopyFileDescr"><a name="FilecopyFileDescr"></a>
	    <h4 id="subsubsection4.2.2.2">copyFile(dstFilename=None, title=None,
                 filters=None, copyuserattrs=1, overwrite=0)
	    </h4>

	    <p class="first">Copy the contents of this file to <em>dstFilename</em>.
	      If the filename already exists it won't be overwritten
	      unless <em>overwrite</em> is set to true (see later).
	      Returns a tuple in the form <tt class="verb">(ngroups, nleaves,
	      nbytes)</tt> specifiying the number of groups, leaves
	      and bytes copied.
	    </p>

	    <dl>
	      <dt>title</dt> <dd>The title for the new file. If
		not specified, the source file title will be copied.
	      </dd>

	      <dt>filters</dt> <dd>Whether or not override the
		original filter properties present in source nodes.
		This parameter must be an instance of the
		<tt class="verb">Filters</tt> class (see section<a href="#FiltersClassDescr">4.13.1</a>). The default is to
		copy the filter attributes from source children.
	      </dd>

	      <dt>copyuserattrs</dt> <dd>You can prevent the
		user attributes from being copied by setting this
		parameter to 0. The default is to copy them.
	      </dd>

	      <dt>copyuserattrs</dt> <dd>You can prevent the
		user attributes from being copied by setting this
		parameter to 0. The default is to copy them.
	      </dd>

	      <dt>overwrite</dt><dd>Whether overwrite or not the
		possibly existing <em>dstFilename</em> file. The
		default is not overwrite it.
	      </dd>
	    </dl>
	  </div> 

	  <div id="createGroupDescr"><a name="createGroupDescr"></a>
	    <h4 id="subsubsection4.2.2.3">createGroup(where, name, title='', filters=None)
	    </h4>

	    <p class="first">Create a new Group instance with name <em>name</em> in
	      <em>where</em> location.
	    </p>

	    <dl>
	      <dt>where</dt> <dd>The parent group where the new
		group will hang from. <em>where</em> parameter can be
		a path string (for example
		<tt class="verb">"/level1/group5"</tt>), or another Group
		instance. </dd>

	      <dt>name</dt>
	      <dd>The name of the new group.</dd>
	      
	      <dt>title</dt> <dd>A description for this
		group.</dd>

	      <dt>filters</dt><dd>An instance of the
		<tt class="verb">Filters</tt> class (see section<a href="#FiltersClassDescr">4.13.1</a>) that provides
		information about the desired I/O filters applicable
		to the leaves that hangs directly from this new group
		(unless other filters properties are specified for
		these leaves). Besides, if you do not specify filter
		properties for its child groups, they will inherit
		these ones.
	      </dd>

	    </dl>

	  </div>

	  <div id="createTableDescr"><a name="createTableDescr"></a>
	    <h4 id="subsubsection4.2.2.4">createTable(where, name,
	      description, title='', filters=None,
	      expectedrows=10000)
	    </h4>
	    <p class="first">Create a new <tt class="verb">Table</tt> instance with name
	      <em>name</em> in <em>where</em> location.
	    </p>
	    <dl>
	      <dt>where</dt> <dd>The parent group where the new
		table will hang from. <em>where</em> parameter can be
		a path string (for example
		<tt class="verb">"/level1/leaf5"</tt>), or Group instance.
               </dd>
	      <dt>name</dt> <dd>The name of the new table.
              </dd>
	      <dt>description</dt> <dd>An instance of a
		user-defined class (derived from the
		<tt class="verb">IsDescription</tt> class) where table fields
		are defined. However, in certain situations, it is
		more handy to allow this description to be supplied as
		a dictionary (for example, when you do not know
		beforehand which structure will have your table). In
		such a cases, you can pass the description as a
		dictionary as well. See <a href="usersguide3.html#secondExample">section&nbsp;3.3</a> for an example of
		use. Finally, a <tt class="verb">RecArray</tt> object from the
		<tt class="verb">numarray</tt> package is also accepted, and
		all the information about columns and other metadata
		is used as a basis to create the <tt class="verb">Table</tt>
		object. Moreover, if the <tt class="verb">RecArray</tt> has
		actual data this is also injected on the newly created
		<tt class="verb">Table</tt> object.
	      </dd>
	      <dt>title</dt> <dd>A description for this object.
	      </dd>
	      <dt>filters</dt> <dd>An instance of the
		<tt class="verb">Filters</tt> class (see <a href="#FiltersClassDescr">section&nbsp;4.13.1</a>) that provides
		information about the desired I/O filters to be
		applied during the life of this object.
	      </dd>
	      <dt>expectedrows</dt> <dd>An user estimate of the
		number of records that will be on table. If not
		provided, the default value is appropriate for tables
		until 10 MB in size (more or less). If you plan to
		save bigger tables you should provide a guess; this
		will optimize the HDF5 B-Tree creation and management
		process time and memory used. See <a href="usersguide6.html#expectedRowsOptim">section&nbsp;6.1</a> for a
		discussion on that issue.
	      </dd>
	    </dl>
	  </div>

	  <div id="createArrayDescr"><a name="createArrayDescr"></a>
	    <h4 id="subsubsection4.2.2.5">createArray(where, name,
	      object, title='')</h4>

	    <p class="first">Create a new <tt class="verb">Array</tt> instance with name
	      <em>name</em> in <em>where</em> location.
	    </p>
	    <dl>
	      <dt>object</dt> <dd>The regular array to be
		saved. Currently accepted values are: lists, tuples,
		scalars (int and float), strings and
		(multidimensional) <tt class="verb">Numeric</tt> and
		<tt class="verb">NumArray</tt> arrays (including
		<tt class="verb">CharArrays</tt> string arrays). However, these
		objects must be regular (i.e. they cannot be like, for
		example, <tt class="verb">[[1,2],2]</tt>). Also, objects that
		have some of their dimensions equal to zero are not
		supported (use an <tt class="verb">EArray</tt> object if you
		want to create an array with one of its dimensions
		equal to 0).
	      </dd>
	    </dl>
	    <p>See <a href="#createTableDescr"><tt class="verb">createTable</tt>
	      description&nbsp;4.2.2</a> for more information on the
	      <em>where</em>, <em>name</em> and <em>title</em>,
	      parameters.
	    </p>
	  </div>

	  <div id="createEArrayDescr"><a name="createEArrayDescr"></a>
	    <h4 id="subsubsection4.2.2.6">createEArray(where, name,
	      atom, title='', filters=None, expectedrows=1000)
	    </h4>

	    <p class="first">Create a new <tt class="verb">EArray</tt> instance with name
	      <em>name</em> in <em>where</em> location.
	    </p>

	    <dl>

	      <dt>atom</dt> <dd>An <tt class="verb">Atom</tt> instance
		representing the <em>shape</em>, <em>type</em> and
		<em>flavor</em> of the atomic objects to be saved.
		One (and only one) of the shape dimensions <b>must</b> be 0. The dimension being 0
		means that the resulting <tt class="verb">EArray</tt> object
		can be extended along it. Multiple enlargeable
		dimensions are not supported right now.  See <a href="#AtomClassDescr">section&nbsp;4.12.3</a> for the supported
		set of <tt class="verb">Atom</tt> class descendants.
              </dd>
	      <dt>expectedrows</dt> <dd>In the case of
                enlargeable arrays this represents an user estimate
                about the number of row elements that will be added to
                the growable dimension in the EArray object. If not
                provided, the default value is 1000 rows. If you plan
                to create both much smaller or much bigger EArrays try
                providing a guess; this will optimize the HDF5 B-Tree
                creation and management process time and the amount of
                memory used.
	      </dd>
	    </dl>
	    <p>See <a href="#createTableDescr"><tt class="verb">createTable</tt>
	      description&nbsp;4.2.2</a> for more information on the
	      <em>where</em>, <em>name</em>, <em>title</em>,
	      and <em>filters</em> parameters.
	    </p>
	  </div>

	  <div id="createVLArrayDescr"><a name="createVLArrayDescr"></a>
	    <h4 id="subsubsection4.2.2.7">createVLArray(where,
	      name, atom=None, title='', filters=None,
	      expectedsizeinMB=1.0)
	    </h4>

	    <p class="first">Create a new <tt class="verb">VLArray</tt> instance with name
	      <em>name</em> in <em>where</em> location. See the <a href="#VLArrayClassDescr">section&nbsp;4.9</a> for a
	      description of the <tt class="verb">VLArray</tt> class.
	    </p>

	    <dl>
	      <dt>atom</dt> <dd>An <tt class="verb">Atom</tt> instance
                representing the shape, type and flavor of the atomic
                object to be saved. See <a href="#AtomClassDescr">section&nbsp;4.12.3</a> for the supported set
                of <tt class="verb">Atom</tt> class descendants.
              </dd>
              <dt>expectedsizeinMB</dt> <dd>An user estimate
                about the size (in MB) in the final
                <tt class="verb">VLArray</tt> object. If not provided, the
                default value is 1 MB.  If you plan to create both
                much smaller or much bigger VLA's try providing a
                guess; this will optimize the HDF5 B-Tree creation and
                management process time and the amount of memory used.
              </dd>
	    </dl>
	    <p>See <a href="#createTableDescr"><tt class="verb">createTable</tt>
	      description&nbsp;4.2.2</a> for more information on the
	      <em>where</em>, <em>name</em>, <em>title</em>, and
	      <em>filters</em> parameters.
	    </p>
	  </div>

	  <div id="getNodeDescr"><a name="getNodeDescr"></a>
	    <h4 id="subsubsection4.2.2.8">getNode(where, name='',
	      classname='')</h4>

	    <p class="first">Returns the object node <em>name</em> under
	      <em>where</em> location.
	    </p>

	      <dl>

		<dt>where</dt> <dd>Can be a path string or
		  <tt class="verb">Group</tt> instance. If <em>where</em>
		  doesn't exist or has already a child called
		  <em>name</em>, a <tt class="verb">ValueError</tt> error is
		  raised.
		</dd>

		<dt>name</dt> <dd>The object name desired. If
		  <em>name</em> is a null string (''), or not
		  supplied, this method assumes to find the object in
		  <em>where</em>.
		</dd>

		<dt>classname</dt> <dd>If supplied, returns only
		  an instance of this class name. Possible values are:
		  <tt class="verb">'Group'</tt>, <tt class="verb">'Leaf'</tt>,
		  <tt class="verb">'Table'</tt>, <tt class="verb">'Array'</tt>,
		  <tt class="verb">'EArray'</tt>, <tt class="verb">'VLArray'</tt> and
		  <tt class="verb">'UnImplemented'</tt>. Note that these values
		  are strings.
		</dd>

	      </dl>
	  </div>

	  <div id="getAttrNodeDescr"><a name="getAttrNodeDescr"></a>
	    <h4 id="subsubsection4.2.2.9">getAttrNode(where,
	      attrname, name='' )</h4>

	    <p class="first">Returns the attribute <em>attrname</em> under
	      <em>where.name</em> location.
	    </p>
	    <dl>

		<dt>where</dt> <dd>Can be a path string or
		  <tt class="verb">Group</tt> instance. If <em>where</em>
		  doesn't exist or has not a child called
		  <em>name</em>, a <tt class="verb">ValueError</tt> error is
		  raised.
		</dd>

		<dt>attrname</dt> <dd>The name of the attribute
		  to get.
		</dd>

		<dt>name</dt> <dd>The node name desired. If
		  <em>name</em> is a null string (''), or not
		  supplied, this method assumes to find the object in
		  <em>where</em>.
		</dd>

	    </dl>
	  </div>

	  <div id="setAttrNodeDescr"><a name="setAttrNodeDescr"></a>
	    <h4 id="subsubsection4.2.2.10">setAttrNode(where,
	      attrname, attrvalue, name='')</h4>

	    <p class="first">Sets the attribute <em>attrname</em> with value
	      <em>attrvalue</em> under <em>where.name</em> location.
	    </p>
	    <dl>

		<dt>where</dt> <dd>Can be a path string or
		  <tt class="verb">Group</tt> instance. If <em>where</em>
		  doesn't exist or has not a child called
		  <em>name</em>, a <tt class="verb">ValueError</tt> error is
		  raised.
		</dd>

		<dt>attrname</dt> <dd>The name of the attribute
		  to set on disk.
		</dd>

		<dt>attrvalue</dt> <dd>The value of the
		  attribute to set. Any scalar (string, ints or
		  floats) attribute is supported natively. However,
		  <tt class="verb">(c)Pickle</tt> is automatically used so as
		  to serialize other kind of objects (like lists,
		  tuples, dicts, small Numeric/numarray objects, ...)
		  that you might want to save.
		</dd>

		<dt>name</dt> <dd>The node name desired. If
		  <em>name</em> is a null string (''), or not
		  supplied, this method assumes to find the object in
		  <em>where</em>.
		</dd>

	    </dl>
	  </div>

	  <div id="delAttrNodeDescr"><a name="delAttrNodeDescr"></a>
	    <h4 id="subsubsection4.2.2.11">delAttrNode(where, attrname, name = "")
	    </h4>

	    <p class="first">Delete the attribute <em>attrname</em> in
	      <em>where.name</em> location.
	    </p>
	    <dl>

		<dt>where</dt> <dd>Can be a path string or
		  <tt class="verb">Group</tt> instance. If <em>where</em>
		  doesn't exist or has not a child called
		  <em>name</em>, a <tt class="verb">ValueError</tt> error is
		  raised.
		</dd>

		<dt>attrname</dt> <dd>The name of the attribute
		  to delete on disk.
		</dd>

		<dt>name</dt> <dd>The node name desired. If
		  <em>name</em> is a null string (''), or not
		  supplied, this method assumes to find the object in
		  <em>where</em>.
		</dd>

	    </dl>
	  </div>

	  <div id="listNodesDescr"><a name="listNodesDescr"></a>
	    <h4 id="subsubsection4.2.2.12">listNodes(where,
	      classname='')</h4>

	    <p class="first">Returns a list with all the object nodes (Group or
	      Leaf) hanging from <em>where</em>. The list is
	      alpha-numerically sorted by node name.
	    </p>
	    <dl>

		<dt>where</dt> <dd>The parent group. Can be a
		  path string or <tt class="verb">Group</tt> instance.
		</dd>

		<dt>classname</dt> <dd>If a <em>classname</em>
		  parameter is supplied, the iterator will return only
		  instances of this class (or subclasses of it). The
		  only supported classes in <em>classname</em> are
		  <tt class="verb">'Group'</tt>, <tt class="verb">'Leaf'</tt>,
		  <tt class="verb">'Table'</tt>, <tt class="verb">'Array'</tt>,
		  <tt class="verb">'EArray'</tt>, <tt class="verb">'VLArray'</tt> and
		  <tt class="verb">'UnImplemented'</tt>. Note that these values
		  are strings.
		</dd>

	    </dl>
	  </div>

	  <div id="removeNodeDescr"><a name="removeNodeDescr"></a>
	    <h4 id="subsubsection4.2.2.13">removeNode(where, name = "",
	      recursive=0)</h4>

	    <p class="first">Removes the object node
	      <em>name</em> under <em>where</em> location.
	    </p>
	    <dl>

		<dt>where</dt> <dd>Can be a path string or
		  <tt class="verb">Group</tt> instance.  If <em>where</em>
		  doesn't exist or has not a child called
		  <em>name</em>, a <tt class="verb">LookupError</tt> error is
		  raised.</dd>

		<dt>name</dt> <dd>The name of the node to be
		  removed. If not provided, the <em>where</em> node is
		  changed.</dd>

		<dt>recursive</dt> <dd>If not supplied, the
		  object will be removed only if it has no
		  children. If supplied with a true value, the object
		  and all its descendants will be completely
		  removed.</dd>

	    </dl>
	  </div>

	  <div id="renameNodeDescr"><a name="renameNodeDescr"></a>
	    <h4 id="subsubsection4.2.2.14">renameNode(where, newname,
	      name)</h4>

	    <p class="first">Rename the object node <em>name</em> under
	      <em>where</em> location.
	    </p>
	    <dl>

		<dt>where</dt> <dd>Can be a path string or
		  <tt class="verb">Group</tt> instance.  If <em>where</em>
		  doesn't exist or has not a child called
		  <em>name</em>, a <tt class="verb">LookupError</tt> error is
		  raised.</dd>

		<dt>newname</dt> <dd>Is the new name to be
		  assigned to the node.</dd>

		<dt>name</dt> <dd>The name of the node to be
		  changed. If not provided, the <em>where</em> node is
		  changed.</dd>

	    </dl>
	  </div>

	  <div id="walkGroupsDescr"><a name="walkGroupsDescr"></a>
	    <h4 id="subsubsection4.2.2.15">walkGroups(where='/')</h4>

	    <p class="first"><em>Iterator</em> that returns the list of Groups (not
	      Leaves) hanging from <em>where</em>. If <em>where</em>
	      is not supplied, the root object is taken as origin. The
	      returned Group list is in a top-bottom order, and
	      alpha-numerically sorted when they are at the same level.
	    </p>
	    <dl>

		<dt>where</dt> <dd>The origin group. Can be a
		  path string or <tt class="verb">Group</tt> instance.
		</dd>

	    </dl>
	  </div>

	  <div id="walkNodesFileDescr"><a name="walkNodesFileDescr"></a>
	    <h4 id="subsubsection4.2.2.16">walkNodes(where="/", classname="")</h4>

	    <p class="first">Recursively iterate over the nodes in the
	      <tt class="verb">File</tt> instance. It takes two parameters:</p>

	    <dl>

	      <dt>where</dt> <dd>If supplied, the iteration
	      starts from this group.</dd>

	      <dt>classname</dt> <dd><em>(String)</em> If
	      supplied, only instances of this class are
	      returned.</dd>

	    </dl>

	    <p>Example of use:</p>

	    <pre>
	      # Recursively print all the nodes hanging from '/detector'
	      print "Nodes hanging from group '/detector':"
	      for node in h5file.walkNodes("/detector"):
	          print node
	    </pre>

	  </div>

	  <div>
	    <h4 id="subsubsection4.2.2.17">flush()</h4>

	    <p class="first">Flush all the leaves in the object tree.
	    </p>
	  </div>

	  <div>
	    <h4 id="subsubsection4.2.2.18">close()</h4>

	    <p class="first">Flush all the leaves in object tree and close the file.
	    </p>
	  </div>

	</div>

	<div>
	  <h3 id="subsection4.2.3"><span class="headlinenumber"><a name="subsection4.2.3"></a>4.2.3 </span><tt>File</tt> special
	      methods</h3>

	  <p class="first">Following are described the methods that automatically
	    trigger actions when a <tt class="verb">File</tt> instance is
	    accessed in a special way.
	  </p>

	  <div id="__iterFileDescr"><a name="__iterFileDescr"></a>
	    <h4 id="subsubsection4.2.3.1">__iter__()</h4>

	    <p class="first">Iterate over the children on the <tt class="verb">File</tt>
	      instance. However, this does not accept parameters. This
	      iterator <em>is recursive</em>.</p>

	    <p>Example of use:</p>

	    <pre>
	      # Recursively list all the nodes in the object tree
	      h5file = tables.openFile("vlarray1.h5")
	      print "All nodes in the object tree:"
	      for node in h5file:
	          print node
	    </pre>

	  </div>

	  <div id="__strFileDescr"><a name="__strFileDescr"></a>
	    <h4 id="subsubsection4.2.3.2">__str__()</h4>

	    <p class="first">Prints a short description of the <tt class="verb">File</tt>
	      object.</p>

	    <p>Example of use:</p>

	    <pre>
&gt;&gt;&gt; f=tables.openFile("data/test.h5")
&gt;&gt;&gt; print f
data/test.h5 (File) 'Table Benchmark'
Last modif.: 'Mon Sep 20 12:40:47 2004'
Object Tree:
/ (Group) 'Table Benchmark'
/tuple0 (Table(100L,)) 'This is the table title'
/group0 (Group) ''
/group0/tuple1 (Table(100L,)) 'This is the table title'
/group0/group1 (Group) ''
/group0/group1/tuple2 (Table(100L,)) 'This is the table title'
/group0/group1/group2 (Group) ''
	    </pre>
	  </div>

	  <div id="__reprFileDescr"><a name="__reprFileDescr"></a>
	    <h4 id="subsubsection4.2.3.3">__repr__()</h4>

	    <p class="first">Prints a detailed description of the <tt class="verb">File</tt>
	      object.</p>

	  </div>

	</div>


      </div>

      <div id="GroupClassDescr"><a name="GroupClassDescr"></a>
	<h2 id="section4.3"><span class="headlinenumber"><a name="section4.3"></a>4.3 </span>The <tt>Group</tt> class</h2>

	<p class="first">Instances of this class are a grouping structure containing
	  instances of zero or more groups or leaves, together with
	  supporting metadata.
	</p>

	<p>Working with groups and leaves is similar in many ways to
	  working with directories and files, respectively, in a Unix
	  filesystem. As with Unix directories and files, objects in
	  the object tree are often described by giving their full (or
	  absolute) path names. This full path can be specified either
	  as a string (like in <tt class="verb">'/group1/group2'</tt>) or as a
	  complete object path written in <em>natural name</em> schema
	  (like in <br><tt class="verb">file.root.group1.group2</tt>) as
	  discussed in the <a href="usersguide1.html#ObjectTreeSection">section&nbsp;1.2</a>.
	</p>

	<p>A collateral effect of the <em>natural naming</em> schema
	  is that you must be aware when assigning a new attribute
	  variable to a Group object to not collide with existing
	  children node names. For this reason and to not pollute the
	  children namespace, it is explicitly forbidden to assign
	  "normal" attributes to Group instances, and the only ones
	  allowed must start with some reserved prefixes, like
	  "<tt class="verb">_f_</tt>" (for methods) or "<tt class="verb">_v_</tt>" (for
	  instance variables) prefixes. Any attempt to assign a new
	  attribute that does not starts with these prefixes, will
	  raise a <tt class="verb">NameError</tt> exception.
	</p>

	<p>Other effect is that you cannot use reserved Python names
	  or other non-allowed python names (like for example "$a" or
	  "44") as node names. You can, however, make use of the
	  <tt class="verb">trMap</tt> (translation map dictionary) parameter in
	  the <tt class="verb">openFile</tt> function (see section <a href="#openFileDescr">4.1.2</a>) in order to use non-valid
	  Python names as node names in the file.
	</p>

	<div>

	  <h3 id="subsection4.3.1"><span class="headlinenumber"><a name="subsection4.3.1"></a>4.3.1 </span><tt>Group</tt> instance
	    variables</h3>
	  <dl>

	    <dt>_v_title</dt>
	    <dd>A description for this group.</dd>

	    <dt>_v_name</dt>
	    <dd>The name of this group.</dd>

	    <dt>_v_hdf5name</dt> <dd>The name of this group in
	      HDF5 file namespace.</dd>

	    <dt>_v_pathname</dt>
	    <dd>A string representation of the group location
	      in tree.</dd>

	    <dt>_v_parent</dt>
	    <dd>The parent Group instance.</dd>

	    <dt>_v_rootgroup</dt>
	    <dd>Pointer to the root group object.</dd>

	    <dt>_v_file</dt>
	    <dd>Pointer to the associated File object.</dd>

	    <dt>_v_depth</dt> <dd>The depth level in tree for
	      this group.</dd>

	    <dt>_v_nchildren</dt> <dd>The number of children
	      (groups or leaves) hanging from this instance.</dd>

	    <dt>_v_children</dt> <dd>Dictionary with all nodes
	      (groups or leaves) hanging from this instance.</dd>

	    <dt>_v_groups</dt> <dd>Dictionary with all node
	      groups hanging from this instance.</dd>

	    <dt>_v_leaves</dt> <dd>Dictionary with all node
	      leaves hanging from this instance.</dd>

	    <dt>_v_attrs</dt> <dd>The associated
	    <tt class="verb">AttributeSet</tt> instance (see <a href="#AttributeSetClassDescr">4.11</a>).</dd>

	    <dt>_v_filters</dt> <dd>Container for filter
	      properties.  See <a href="#FiltersClassDescr">section&nbsp;4.13.1</a> for more
	      information on this object.
	    </dd>

	  </dl>

	</div>

	<div>
	  <h3 id="subsection4.3.2"><span class="headlinenumber"><a name="subsection4.3.2"></a>4.3.2 </span><tt>Group</tt> methods</h3>

	  <div class="p-first">This class define the <tt class="verb">__setattr__</tt>,
	    <tt class="verb">__getattr__</tt> and <tt class="verb">__delattr__</tt> and
	    they work as normally intended. So, you can access, assign
	    or delete children to a group by just using the next
	    constructs:

	    <pre>
	      # Add a Table child instance under group with name "tablename"
	      group.tablename = Table(recordDict, "Record instance")
	      table = group.tablename     # Get the table child instance
	      del group.tablename         # Delete the table child instance
	    </pre>             

	  </div>

	  <p><b>Caveat: </b>The following
	    methods are documented for completeness, and they can be
	    used without any problem. However, you should use the
	    high-level counterpart methods in the <tt class="verb">File</tt>
	    class, because these are most used in documentation and
	    examples, and are a bit more powerful than those exposed
	    here.
	  </p>

	  <div id="Group_f_join"><a name="Group_f_join"></a>
	    <h4 id="subsubsection4.3.2.1">_f_join(name)
	    </h4>
	    <p class="first">Helper method to correctly concatenate a name child object
	      with the pathname of this group.
	    </p>
	  </div>
	  <div id="Group_f_rename"><a name="Group_f_rename"></a>
	    <h4 id="subsubsection4.3.2.2">_f_rename(newname)
	    </h4>
	    <p class="first">Change the name of this group to <em>newname</em>.
	    </p>
	  </div>
	  <div id="Group_f_remove"><a name="Group_f_remove"></a>
	    <h4 id="subsubsection4.3.2.3">_f_remove(recursive=0)
	    </h4>
	    <p class="first">Remove this object. If <em>recursive</em> is true,
	      force the removal even if this group has children.
	    </p>
	  </div>
	  <div id="Group_f_getAttr"><a name="Group_f_getAttr"></a>
	    <h4 id="subsubsection4.3.2.4">_f_getAttr(attrname)
	    </h4>
	    <p class="first">Gets the HDF5 attribute <em>attrname</em> of this
	      group.
	    </p>
	  </div>

	  <div id="Group_f_setAttr"><a name="Group_f_setAttr"></a>
	    <h4 id="subsubsection4.3.2.5">_f_setAttr(attrname, attrvalue)
	    </h4>
	    <p class="first">Sets the attribute <em>attrname</em> of this group to
	      the value <em>attrvalue</em>. Any scalar (string, ints
	      or floats) attribute is supported natively. However,
	      <tt class="verb">(c)Pickle</tt> is automatically used so as to
	      serialize other kind of objects (like lists, tuples,
	      dicts, small Numeric/numarray objects, ...)  that you
	      might want to save.
	    </p>
	  </div>

	  <div id="Group_f_delAttr"><a name="Group_f_delAttr"></a>
	    <h4 id="subsubsection4.3.2.6">_f_delAttr(attrname)
	    </h4>
	    <p class="first">Delete the attribute <em>attrname</em> of this
	      group.
	    </p>
	  </div>

	  <div id="Group_f_listNodes"><a name="Group_f_listNodes"></a>
	    <h4 id="subsubsection4.3.2.7">_f_listNodes(classname='')
	    </h4>
	    <p class="first">Returns a <em>list</em> with all the object nodes
	      hanging from this instance. The list is
	      alpha-numerically sorted by node name. If a
	      <em>classname</em> parameter is supplied, it will only
	      return instances of this class (or subclasses of
	      it). The supported classes in <em>classname</em> are
	      <tt class="verb">'Group'</tt>, <tt class="verb">'Leaf'</tt>,
	      <tt class="verb">'Table'</tt> and <tt class="verb">'Array'</tt>,
	      <tt class="verb">'EArray'</tt>, <tt class="verb">'VLArray'</tt> and
	      <tt class="verb">'UnImplemented'</tt>.
	    </p>
	  </div>
	  <div id="_f_walkGroupsGroupDescr"><a name="_f_walkGroupsGroupDescr"></a>
	    <h4 id="subsubsection4.3.2.8">_f_walkGroups()
	    </h4>
	    <p class="first">Iterate over the list of Groups (not Leaves) hanging
	      from <em>self</em>. The returned Group list is in a
	      top-bottom order, and alpha-numerically sorted when they
	      are at the same level.
	    </p>
	  </div>

	  <div id="_f_walkNodesGroupDescr"><a name="_f_walkNodesGroupDescr"></a>
	    <h4 id="subsubsection4.3.2.9">_f_walkNodes(classname="",
	      recursive=0)</h4>

	    <p class="first">Iterate over the nodes in the <tt class="verb">Group</tt>
	      instance. It takes two parameters:</p>

	    <dl>

	      <dt>classname</dt> <dd><em>(String)</em> If
	      supplied, only instances of this class are
	      returned.</dd>

	      <dt>recursive</dt> <dd><em>(Integer)</em> If
	      false, only children hanging immediately after the group
	      are returned. If true, a recursion over all the groups
	      hanging from it is performed. </dd>

	    </dl>

	    <p>Example of use:</p>

	    <pre>
	      # Recursively print all the arrays hanging from '/'
	      print "Arrays the object tree '/':"
	      for array in h5file.root._f_walkNodes("Array", recursive=1):
	          print array
	    </pre>

	  </div>

	  <div id="Group_f_close"><a name="Group_f_close"></a>
	    <h4 id="subsubsection4.3.2.10">_f_close()
	    </h4>
	    <p class="first">Close this group, making it and its children
	      unaccessible in the object tree.
	    </p>
	  </div>

	  <div id="Group_f_copyChildrenDescr"><a name="Group_f_copyChildrenDescr"></a>

	    <h4 id="subsubsection4.3.2.11">_f_copyChildren(where, recursive=0, filters=None,
	      copyuserattrs=1, start=0, stop=None, step=1,
	      overwrite=0)
	    </h4>

	    <p class="first">Copy (recursively) the children of this group into
	      another location specified by <em>where</em> (it can be
	      a path string or a <tt class="verb">Group</tt> object). Returns a
	      tuple in the form <tt class="verb">(ngroups, nleaves,
	      nbytes)</tt> specifiying the number of groups, leaves
	      and bytes copied.
	    </p>

	    <dl>
	      <dt>recursive</dt> <dd>Specifies whether the copy
		should recurse into subgroups or not. The default is
		not recurse.
	      </dd>
	      
	      <dt>filters</dt> <dd>Whether or not override the
		original filter properties present in source nodes.
		This parameter must be an instance of the
		<tt class="verb">Filters</tt> class (see section<a href="#FiltersClassDescr">4.13.1</a>). The default is to
		copy the filter attributes from source children.
	      </dd>

	      <dt>copyuserattrs</dt> <dd>You can prevent the
		user attributes from being copied by setting this
		parameter to 0. The default is to copy them.
	      </dd>

	      <dt>start, stop, step</dt><dd>Specifies the range
		of rows in child leaves to be copied; the default is
		to copy all the rows.
	      </dd>

	      <dt>overwrite</dt><dd>Whether the possible
		existing children hanging from this group and having
		the same names than <tt class="verb">where</tt> children should
		overwrite the destination nodes or not.
	      </dd>
	    </dl>
	  </div> 

	</div>

	<div>
	  <h3 id="subsection4.3.3"><span class="headlinenumber"><a name="subsection4.3.3"></a>4.3.3 </span><tt>Group</tt> special
	      methods</h3>

	  <p class="first">Following are described the methods that automatically
	    trigger actions when a <tt class="verb">Group</tt> instance is
	    accessed in a special way.
	  </p>

	  <div id="__iterGroupDescr"><a name="__iterGroupDescr"></a>
	    <h4 id="subsubsection4.3.3.1">__iter__()</h4>

	    <p class="first">Iterate over the children on the group instance. However,
	      this does not accept parameters. This iterator is
	      <b>not</b> recursive.</p>

	    <p>Example of use:</p>

	    <pre>
	      # Non-recursively list all the nodes hanging from '/detector'
	      print "Nodes in '/detector' group:"
	      for node in h5file.root.detector:
	          print node
	    </pre>

	  </div>

	  <div id="__strGroupDescr"><a name="__strGroupDescr"></a>
	    <h4 id="subsubsection4.3.3.2">__str__()</h4>

	    <p class="first">Prints a short description of the <tt class="verb">Group</tt>
	      object.</p>

	    <p>Example of use:</p>

	    <pre>
&gt;&gt;&gt; f=tables.openFile("data/test.h5")
&gt;&gt;&gt; print f.root.group0
/group0 (Group) 'First Group'
&gt;&gt;&gt;
	    </pre>
	  </div>

	  <div id="__reprGroupDescr"><a name="__reprGroupDescr"></a>
	    <h4 id="subsubsection4.3.3.3">__repr__()</h4>

	    <p class="first">Prints a detailed description of the <tt class="verb">Group</tt>
	      object.</p>

	    <p>Example of use:</p>

	    <pre>
&gt;&gt;&gt; f=tables.openFile("data/test.h5")
&gt;&gt;&gt; f.root.group0
/group0 (Group) 'First Group'
  children := ['tuple1' (Table), 'group1' (Group)]
&gt;&gt;&gt;
	    </pre>
	  </div>
	</div>
      </div>

      <div id="LeafClassDescr"><a name="LeafClassDescr"></a>
	<h2 id="section4.4"><span class="headlinenumber"><a name="section4.4"></a>4.4 </span>The <tt>Leaf</tt> class</h2>

	<p class="first">The goal of this class is to provide a place to put common
	  functionality of all its descendants as well as provide a
	  way to help classifying objects on the tree. A
	  <tt class="verb">Leaf</tt> object is an end-node, that is, a node
	  that can hang directly from a group object, but that is not
	  a group itself and, thus, it cannot have descendents. Right
	  now, the set of end-nodes is composed by <tt class="verb">Table</tt>,
	  <tt class="verb">Array</tt>, <tt class="verb">EArray</tt>,
	  <tt class="verb">VLArray</tt> and <tt class="verb">UnImplemented</tt> class
	  instances. In fact, all the previous classes inherit from
	  the <tt class="verb">Leaf</tt> class.
	</p>

	<div>
	  <h3 id="subsection4.4.1"><span class="headlinenumber"><a name="subsection4.4.1"></a>4.4.1 </span><tt>Leaf</tt> instance
	    variables</h3>

	  <p class="first">The public variables and methods that class descendants
	    inherits from <tt class="verb">Leaf</tt> are listed below.
	  </p>

	  <dl>

	    <dt>name</dt> <dd>The Leaf node name in Python
	      namespace.
	    </dd>
	    <dt>hdf5name</dt> <dd>The Leaf node name in HDF5
	      namespace.
	    </dd>
	    <dt>objectID</dt> <dd>The HDF5 object ID of the Leaf
	      node.
	    </dd>
	    <dt>title</dt> <dd>The Leaf title (actually a
	      property rather than a plain attribute).
	    </dd>
	    <dt>shape</dt> <dd>The shape of the associated data
	      in the Leaf.
	    </dd>
	    <dt>byteorder</dt> <dd>The byteorder of
	      the associated data of the Leaf.
	    </dd>
	    <dt>attrs</dt><dd>The associated
	      <tt class="verb">AttributeSet</tt> instance (see <a href="#AttributeSetClassDescr">4.11</a>).
	    </dd>
	    <dt>filters</dt> <dd>Container for filter
	      properties.  See <a href="#FiltersClassDescr">section&nbsp;4.13.1</a> for more
	      information on this object.
	    </dd>
	  </dl>

	  <p>Besides, the next instance variables are also defined and
	    have similar meaning as its counterparts in the
	    <tt class="verb">Group</tt> class:
	  </p>

	  <dl>
	    <dt>_v_hdf5name</dt> <dd>The name of this leaf in
	      HDF5 file namespace.</dd>

	    <dt>_v_pathname</dt>
	    <dd>A string representation of the leaf location
	      in tree.</dd>

	    <dt>_v_parent</dt>
	    <dd>The parent <tt class="verb">Group</tt> instance.</dd>

	    <dt>_v_rootgroup</dt> <dd>Pointer to the root
	    <tt class="verb">Group</tt> object.</dd>

	    <dt>_v_file</dt> <dd>Pointer to the associated
	    <tt class="verb">File</tt> object.</dd>

	    <dt>_v_depth</dt> <dd>The depth level in tree for
	      this leaf.</dd>

	  </dl>
	</div>

	<div>
	  <h3 id="subsection4.4.2"><span class="headlinenumber"><a name="subsection4.4.2"></a>4.4.2 </span><tt>Leaf</tt> methods</h3>

	  <div id="copyLeafDescr"><a name="copyLeafDescr"></a>

	    <h4 id="subsubsection4.4.2.1">copy(where, name, title=None,
	      filters=None, copyuserattrs=1, start=0, stop=None,
	      step=1, overwrite=0)
	    </h4>

	    <div class="p-first">Copy this leaf into another location. It returns a
	      tuple <tt class="verb">(object, nbytes)</tt> where
	      <tt class="verb">object</tt> is the newly created object and
	      <tt class="verb">nbytes</tt> is the number of bytes copied. The
	      meaning of the parameters is explained below:
	      <dl>
		<dt>where</dt> <dd>Can be a path string or
		  <tt class="verb">Group</tt> instance.  If <em>where</em>
		  doesn't exist or has not a child called
		  <em>name</em>, a <tt class="verb">LookupError</tt> error is
		  raised.
		</dd>
		<dt>name</dt> <dd>The name of the destination
		  node.
		</dd>
		<dt>title</dt><dd>The new title for
		  destination. If None, the original title is copied.
		</dd>
		<dt>filters</dt><dd>An instance of the
		  <tt class="verb">Filters</tt> (see <a href="#FiltersClassDescr">section&nbsp;4.13.1</a>) class. A
		  None value means that the source properties are
		  copied <em>as is</em>.
		</dd>
		<dt>copyuserattrs</dt><dd>Whether copy the user
		  attributes of the source leaf to the destination or
		  not. The default is to copy them.
		</dd>
		<dt>start, stop, step</dt><dd>Specifies the
		  range of rows to be copied; the default is to copy
		  all the rows.
		</dd>
		<dt>overwrite</dt><dd>If the destination node
		  <em>name</em> already exists this specifies whether
		  it should be overwritten or not. The default is not
		  overwrite it.
		</dd>
	      </dl>
	    </div>

	  </div>

	  <div id="removeLeafDescr"><a name="removeLeafDescr"></a>
	    <h4 id="subsubsection4.4.2.2">remove()</h4>
	    <p class="first">Remove this leaf.</p>
	  </div>
	  <div id="renameLeafDescr"><a name="renameLeafDescr"></a>
	    <h4 id="subsubsection4.4.2.3">rename(newname)</h4>
	    <p class="first">Change the name of this leaf to <em>newname</em>.</p>
	  </div>
	  <div id="getAttrLeafDescr"><a name="getAttrLeafDescr"></a>
	    <h4 id="subsubsection4.4.2.4">getAttr(attrname)</h4>
	    <p class="first">Gets the HDF5 attribute <em>attrname</em> of this leaf.
	    </p>
	  </div>
	  <div id="setAttrLeafDescr"><a name="setAttrLeafDescr"></a>
	    <h4 id="subsubsection4.4.2.5">setAttr(attrname,
	      attrvalue)
	    </h4>
	    <p class="first">Sets the attribute <em>attrname</em> of this leaf to
	      the value <em>attrvalue</em>.
	    </p>
	  </div>
	  <div id="delAttrLeafDescr"><a name="delAttrLeafDescr"></a>
	    <h4 id="subsubsection4.4.2.6">delAttr(attrname)</h4> <p class="first">Delete the HDF5
	      attribute <em>attrname</em> of this leaf.
	    </p>
	  </div>
	  <div id="flushLeafDescr"><a name="flushLeafDescr"></a>
	    <h4 id="subsubsection4.4.2.7">flush()</h4>
	    <p class="first">Flush the leaf buffers (if any).</p>
	  </div>
	  <div id="closeLeafDescr"><a name="closeLeafDescr"></a>
	    <h4 id="subsubsection4.4.2.8">close()</h4> <p class="first">Flush
	    the leaf buffers (if any) and close the dataset.</p>
	  </div>
	</div>

      </div>

      <div id="TableClassDescr"><a name="TableClassDescr"></a>
	<h2 id="section4.5"><span class="headlinenumber"><a name="section4.5"></a>4.5 </span>The <tt>Table</tt> class</h2>

	<p class="first">Instances of this class represents table objects in the
	  object tree. It provides methods to read/write data and
	  from/to table objects in the file.
	</p>
	<p>Data can be read from or written to tables by accessing to
	  an special object that hangs from <tt class="verb">Table</tt>. This
	  object is an instance of the <tt class="verb">Row</tt> class (see
	  <a href="#RowClassDescr">4.5.4</a>). See the tutorial
	  sections <a href="usersguide3.html#usage">chapter&nbsp;3</a> on how to use the
	  <tt class="verb">Row</tt> interface. The columns of the tables can
	  also be easily accessed (and more specifically, they can be
	  read but not written) by making use of the
	  <tt class="verb">Column</tt> class, through the use of an
	  <em>extension</em> of the natural naming schema applied
	  inside the tables. See the <a href="#ColumnClassDescr">section&nbsp;4.6</a> for some examples of
	  use of this capability.
	</p>
	<p>Note that this object inherits all the public attributes
	  and methods that <tt class="verb">Leaf</tt> already has.
	</p>

	<div>
	  <h3 id="subsection4.5.1"><span class="headlinenumber"><a name="subsection4.5.1"></a>4.5.1 </span><tt>Table</tt> instance
	    variables</h3>
	  <dl>
	    <dt>description</dt> <dd>The metaobject describing
	      this table.
	    </dd>
	    <dt>row</dt> <dd>The <tt class="verb">Row</tt> instance for
	      this table (see <a href="#RowClassDescr">4.5.4</a>).
	    </dd>
	    <dt>nrows</dt> <dd>The number of rows in this table.
	    </dd>
	    <dt>rowsize</dt> <dd>The size, in bytes, of each
	      row.
	    </dd>

	    <dt>cols</dt> <dd>A <tt class="verb">Cols</tt> (see <a href="#ColsClassDescr">section&nbsp;4.5.5</a>) instance that
		serves as accessor to <tt class="verb">Column</tt> (see <a href="#ColumnClassDescr">section&nbsp;4.6</a>) objects.
	    </dd>
	    <dt>colnames</dt> <dd>The field names for the table
	      (list).
	    </dd>
	    <dt>coltypes</dt> <dd>The data types for the table
	      fields (dictionary).
	    </dd>
	    <dt>colshapes</dt> <dd>The shapes for the table
	      fields (dictionary).
	    </dd>
	    <dt>colindexed</dt> <dd>Whether the table fields are
	      indexed (dictionary).
	    </dd>
	    <dt>indexed</dt> <dd>Whether the table fields are
	      indexed (dictionary).
	    </dd>
	    <dt>indexprops</dt> <dd>Properties of an indexed
		Table (see <a href="#IndexPropsClassDescr">4.13.2</a>). This attribute
		(dictionary) exists only if the Table is indexed.
	    </dd>
	  </dl>
	</div>

	<div>
	  <h3 id="subsection4.5.2"><span class="headlinenumber"><a name="subsection4.5.2"></a>4.5.2 </span><tt>Table</tt> methods
	  </h3>
	  <div id="appendTableDescr"><a name="appendTableDescr"></a>
	    <h4 id="subsubsection4.5.2.1">append(rows=None)
	    </h4>
	    <p class="first">Append a series of rows to this <tt class="verb">Table</tt>
	      instance. <em>rows</em> is an object that can keep the
	      rows to be append in several formats, like a
	      <tt class="verb">RecArray</tt>, a list of tuples, list of
	      <tt class="verb">Numeric</tt>/<tt class="verb">NumArray</tt>/<tt class="verb">CharArray</tt>
	      objects, string, Python buffer or None (no append will
	      result). Of course, this <em>rows</em> object has to be
	      compliant with the underlying format of the
	      <tt class="verb">Table</tt> instance or a <tt class="verb">ValueError</tt>
	      will be issued.
	    </p>

	    <div class="p">Example of use:
	      <pre>
from tables import *
class Particle(IsDescription):
    name        = StringCol(16, pos=1)   # 16-character String
    lati        = IntCol(pos=2)        # integer
    longi       = IntCol(pos=3)        # integer
    pressure    = Float32Col(pos=4)    # float  (single-precision)
    temperature = FloatCol(pos=5)      # double (double-precision)

fileh = openFile("test4.h5", mode = "w")
table = fileh.createTable(fileh.root, 'table', Particle, "A table")
# Append several rows in only one call
table.append([("Particle:     10", 10, 0, 10*10, 10**2),
              ("Particle:     11", 11, -1, 11*11, 11**2),
              ("Particle:     12", 12, -2, 12*12, 12**2)])
fileh.close()
	      </pre>
	    </div>
	  </div>

	  <div id="iterrowsTableDescr"><a name="iterrowsTableDescr"></a>
	    <h4 id="subsubsection4.5.2.2">iterrows(start=None,
	      stop=None, step=1)</h4>

	    <p class="first">Returns an iterator yielding <tt class="verb">Row</tt> (see <a href="#RowClassDescr">section&nbsp;4.5.4</a>) instances built
	      from rows in table. If a range is supplied (i.e. some of
	      the <em>start</em>, <em>stop</em> or <em>step</em>
	      parameters are passed), only the appropriate rows are
	      returned. Else, all the rows are returned. See also the
	      <tt class="verb">__iter__()</tt> special method in <a href="#TableSpecialMethods">section&nbsp;4.5.3</a> for a shorter
	      way to call this iterator.
	    </p>
	    <p>The meaning of the <em>start</em>, <em>stop</em> and
	      <em>step</em> parameters is the same as in the
	      <tt class="verb">range()</tt> python function, except that
	      negative values of <tt class="verb">step</tt> are not
	      allowed. Moreover, if only <tt class="verb">start</tt> is
	      specified, then <tt class="verb">stop</tt> will be set to
	      <tt class="verb">start+1</tt>. If you do not specify neither
	      <em>start</em> nor <em>stop</em>, then <b>all the rows</b> in the object are
	      selected.
	    </p>

	    <p>Example of use:</p>
	    <pre>
	      result = [ row['var2'] for row in table.iterrows(step=5)
                                     if row['var1'] &lt;= 20 ]
	    </pre>

	  </div>

	  <div id="itersequenceDescr"><a name="itersequenceDescr"></a>
	    <h4 id="subsubsection4.5.2.3">itersequence(sequence=None)</h4>

	    <p class="first">Iterate over a <em>sequence</em> of row
	      coordinates. <em>sequence</em> can be any object that
	      supports the <tt class="verb">__getitem__</tt> special method,
	      like lists, tuples, Numeric/numarray objects, etc.
	    </p>

	  </div>

	  <div id="readTableDescr"><a name="readTableDescr"></a>
	    <h4 id="subsubsection4.5.2.4">read(start=None, stop=None,
	      step=1, field=None, flavor="numarray")</h4>

	    <p class="first">Returns the actual data in <tt class="verb">Table</tt>. If
	      <em>field</em> is not supplied, it returns the data as a
	      <tt class="verb">RecArray</tt> object table.
	    </p>

	    <p>The meaning of the <em>start</em>, <em>stop</em> and
	      <em>step</em> parameters is the same as in the
	      <tt class="verb">range()</tt> python function, except that
	      negative values of <tt class="verb">step</tt> are not
	      allowed. Moreover, if only <tt class="verb">start</tt> is
	      specified, then <tt class="verb">stop</tt> will be set to
	      <tt class="verb">start+1</tt>. If you do not specify neither
	      <em>start</em> nor <em>stop</em>, then all the rows in
	      the object are selected.
	    </p>
	    <p>The rest of the parameters are described next:</p>

	    <dl>
	      <dt>field</dt> <dd>If specified, only the column
		<em>field</em> is returned as a <tt class="verb">NumArray</tt>
		object. If this is not supplied, all the fields are
		selected and a <tt class="verb">RecArray</tt> is returned.
	      </dd>
	      <dt>flavor</dt> <dd>When a field in table is
		selected, passing a <em>flavor</em> parameter make an
		additional conversion to happen in the default
		<tt class="verb">"numarray"</tt> returned
		object. <em>flavor</em> must have any of the next
		values: <tt class="verb">"numarray"</tt> (i.e. no conversion is
		made), <tt class="verb">"Numeric"</tt>, <tt class="verb">"Tuple"</tt> or
		<tt class="verb">"List"</tt>.
	      </dd>
	    </dl>
	  </div>

	  <div id="modifyRowsDescr"><a name="modifyRowsDescr"></a>
	    <h4 id="subsubsection4.5.2.5">modifyRows(start=None, stop=None, step=1,
	      rows=None)</h4>

	    <p class="first">Modify a series of rows in the
	      <tt class="verb">[start:stop:step]</tt> <em>extended slice</em>
	      range. If you pass <tt class="verb">None</tt> to <em>stop</em>,
	      all the rows existing in <em>rows</em> will be used.
	    </p>

	    <p><em>rows</em> can be either a <tt class="verb">RecArray</tt>
	      object or a structure that is able to be converted to a
	      <tt class="verb">RecArray</tt> and compliant with the table
	      format.
	    </p>

	    <p>Returns the number of modified rows.
	    </p>

	    <p>It raises an <tt class="verb">ValueError</tt> in case the rows
	      parameter could not be converted to an object compliant
	      with table description.
	    </p>

	    <p>It raises an <tt class="verb">IndexError</tt> in case the
	      modification will exceed the length of the table.
	    </p>

	  </div>

	  <div id="modifyColumnsDescr"><a name="modifyColumnsDescr"></a>
	    <h4 id="subsubsection4.5.2.6">modifyColumns(start=None, stop=None, step=1,
	      columns=None, names=None)</h4>

	    <p class="first">Modify a series of rows in the
	      <tt class="verb">[start:stop:step]</tt> <em>extended slice</em>
	      row range. If you pass <tt class="verb">None</tt> to <em>stop</em>,
	      all the rows existing in <em>columns</em> will be used.
	    </p>

	    <p><em>columns</em> can be either a RecArray<tt class="verb"></tt>
	      or a list of arrays (the columns) that is able to be
	      converted to a <tt class="verb">RecArray</tt> compliant with the
	      specified column <em>names</em> subset of the table
	      format.
	    </p>

	    <p><em>names</em> specifies the column names of the table
	      to be modified.
	    </p>

	    <p>Returns the number of modified rows.
	    </p>

	    <p>It raises an <tt class="verb">ValueError</tt> in case the
	      <em>columns</em> parameter could not be converted to an
	      object compliant with table description.
	    </p>

	    <p>It raises an <tt class="verb">IndexError</tt> in case the
	      modification will exceed the length of the table.
	    </p>

	  </div>

	  <div id="removeRowsDescr"><a name="removeRowsDescr"></a>
	    <h4 id="subsubsection4.5.2.7">removeRows(start=None,
	      stop=None)</h4>

	    <p class="first">Removes a range of rows in the table.  If only
	      <em>start</em> is supplied, this row is to be
	      deleted. If a range is supplied, i.e. both the
	      <em>start</em> and <em>stop</em> parameters are passed,
	      all the rows in the range are removed. A <em>step</em>
	      parameter is not supported, and it is not foreseen to
	      implement it anytime soon.
	    </p>
	    <dl>
		<dt>start</dt> <dd>Sets the starting row to
		  be removed. It accepts negative values meaning that
		  the count starts from the end. A value of 0 means
		  the first row.</dd>

		<dt>stop</dt> <dd>Sets the last row to be
		  removed to <em>stop</em> - 1, i.e. the end point is
		  omitted (in the Python <tt class="verb">range</tt>
		  tradition). It accepts, likewise <em>start</em>,
		  negative values. A special value of
		  <tt class="verb">None</tt> (the default) means removing just
		  the row supplied in start.
		</dd>

	      </dl>
	  </div>

	  <div id="removeIndexDescr"><a name="removeIndexDescr"></a>
	    <h4 id="subsubsection4.5.2.8">removeIndex(index=None)</h4>

	    <p class="first">Remove the index associated with the specified
	      column. Only <tt class="verb">Index</tt> instances (see <a href="#IndexClassDescr">4.13.3</a>) are accepted as
	      parameter.  This index can be recreated again by calling
	      the <tt class="verb">createIndex</tt> (see <a href="#createIndexColumnDescr">4.6.2</a>) method of the
	      appropriate <tt class="verb">Column</tt> object.
	    </p>
	  </div>

	  <div id="flushRowsToIndexDescr"><a name="flushRowsToIndexDescr"></a>
	    <h4 id="subsubsection4.5.2.9">flushRowsToIndex()</h4>

	    <p class="first"> Add remaining rows in buffers to non-dirty
	      indexes. This can be useful when you have chosen
	      non-automatic indexing for the table (see <a href="#IndexPropsClassDescr">section&nbsp;4.13.2</a>) and want to
	      update the indexes on it.
	    </p>
	  </div>

	  <div id="reIndexDescr"><a name="reIndexDescr"></a>
	    <h4 id="subsubsection4.5.2.10">reIndex()</h4>

	    <p class="first">Recompute all the existing indexes in table. This can
	      be useful when you suspect that, for any reason, the
	      index information for columns is no longer valid and
	      want to rebuild the indexes on it.
	    </p>
	  </div>

	  <div id="reIndexDirtyDescr"><a name="reIndexDirtyDescr"></a>
	    <h4 id="subsubsection4.5.2.11">reIndexDirty()</h4>

	    <p class="first">Recompute the existing indexes in table, but
	      <em>only</em> if they are dirty. This can be useful when
	      you have set the <tt class="verb">reindex</tt> parameter to 0 in
	      <tt class="verb">IndexProps</tt> constructor (see <a href="#IndexPropsInitDescr">4.13.2</a>) for the table and
	      want to update the indexes after a invalidating index
	      operation (<tt class="verb">Table.removeRows</tt>, for example).
	    </p>
	  </div>

	  <div id="whereTableDescr"><a name="whereTableDescr"></a>
	    <h4 id="subsubsection4.5.2.12">where(condition, start=None, stop=None,
	      step=None)</h4>

	    <p class="first">Returns an iterator yielding <tt class="verb">Row</tt> (see <a href="#RowClassDescr">section&nbsp;4.5.4</a>) instances built
	      from rows in table that satisfy a <em>condition</em>
	      over a column. If the column to which the condition is
	      applied is indexed, this index will be used in order to
	      accelerate the search. Else, the <em>in-kernel</em>
	      iterator (with better performance than the regular
	      iterator) will be choosed instead.
	    </p>
	    <p>Moreover, if a range is supplied (i.e. some of the
	      <em>start</em>, <em>stop</em> or <em>step</em>
	      parameters are passed), only the rows in that range
	      <em>and</em> fullfilling the <em>condition</em> are
	      returned. Else, all the rows that fullfill the
	      <em>condition</em> are returned.
	    </p>
	    <p>The meaning of the <em>start</em>, <em>stop</em> and
	      <em>step</em> parameters is the same as in the
	      <tt class="verb">range()</tt> python function, except that
	      negative values of <tt class="verb">step</tt> are not
	      allowed. Moreover, if only <tt class="verb">start</tt> is
	      specified, then <tt class="verb">stop</tt> will be set to
	      <tt class="verb">start+1</tt>. If you do not specify neither
	      <em>start</em> nor <em>stop</em>, then <b>all the rows</b> that fullfill the
	      <em>condition</em> are selected.
	    </p>

	    <p>You can mix this method with regular selections in
	      order to have complex queries. It is strongly
	      recommended that you pass the most restrictive condition
	      as the parameter to this method if you want to achieve
	      maximum performance.
	    </p>

	    <p>Example of use:</p>
	    <pre>
              passvalues=[]
              for row in table.iterrows(0&gt;table.cols.col1&lt;0.3, step=5):
                  if row['var1'] &lt;= 20:
                      passvalues.append(row['var2']
              print "Values that passes the cuts:", passvalues
	    </pre>

	    <p>See also the <tt class="verb">whereIndexed</tt> and
	      <tt class="verb">whereInRange</tt> methods below for more
	      specific ways to call this iterator.
	    </p>

	  </div>

	  <div id="whereIndexedTableDescr"><a name="whereIndexedTableDescr"></a>
	    <h4 id="subsubsection4.5.2.13">whereIndexed(condition, start=None, stop=None,
	      step=None)</h4>

	    <p class="first">Iterator that selects values fulfilling the
	      <em>condition</em> parameter. This <em>only</em> works
	      for conditions over a <em>indexed</em> column. If you
	      try to use it over non-indexed column, an
	      <tt class="verb">AssertionError</tt> will be raised.
	    </p>

	    <p>The meaning of the <em>condition</em>, <em>start</em>,
	      <em>stop</em> and <em>step</em> parameters is the same
	      as in the <tt class="verb">where</tt> method (see <a href="#whereTableDescr">4.5.2</a>) described above.
	    </p>

	  </div>

	  <div id="whereInRangeTableDescr"><a name="whereInRangeTableDescr"></a>
	    <h4 id="subsubsection4.5.2.14">whereInRange(condition, start=None, stop=None,
	      step=None)</h4>

	    <p class="first">Iterator that selects values fulfilling the
	      <em>condition</em> parameter.  This method will use the
	      <em>in-kernel</em> search method, i.e. it won't take
	      advantage of a possible indexed column.
	    </p>

	    <p>The meaning of the <em>condition</em>, <em>start</em>,
	      <em>stop</em> and <em>step</em> parameters is the same
	      as in the <tt class="verb">where</tt> method (see <a href="#whereTableDescr">4.5.2</a>) described above.
	    </p>

	  </div>

	  <div id="getWhereListTableDescr"><a name="getWhereListTableDescr"></a>
	    <h4 id="subsubsection4.5.2.15">getWhereList(condition, flavor="List")</h4>

	    <p class="first">Get the row coordinates that fulfill the
	      <em>condition</em> param. This method will take
	      advantage of an indexed column to speed-up the search.
	    </p>

	    <p><em>flavor</em> is the desired type of the returned
	      list. It can take the <tt class="verb">'List'</tt> (the default),
	      <tt class="verb">'Tuple'</tt> or <tt class="verb">'NumArray'</tt> values.
	    </p>

	  </div>

	</div>
	<div id="TableSpecialMethods"><a name="TableSpecialMethods"></a>
	  <h3 id="subsection4.5.3"><span class="headlinenumber"><a name="subsection4.5.3"></a>4.5.3 </span><tt>Table</tt> special methods
	  </h3>

	  <p class="first">Following are described the methods that automatically
	    trigger actions when a <tt class="verb">Table</tt> instance is
	    accessed in a special way (e.g.,
	    <tt class="verb">table["var2"]</tt> will be equivalent to a call to
	    <tt class="verb">table.__getitem__("var2")</tt>).
	  </p>

	  <div id="__iterTableDescr"><a name="__iterTableDescr"></a>
	    <h4 id="subsubsection4.5.3.1">__iter__()</h4>

	    <p class="first">It returns the same iterator than
	      <tt class="verb">Table.iterrows(0,0,1)</tt>. However, this does not
	      accept parameters.</p>

	    <p>Example of use:</p>

	    <pre>
	      result = [ row['var2'] for row in table 
                                     if row['var1'] &lt;= 20 ]
	    </pre>

	    <p>Which is equivalent to:</p>

	    <pre>
	      result = [ row['var2'] for row in table.iterrows() 
                                     if row['var1'] &lt;= 20 ]
	    </pre>

	  </div>

	  <div id="__getitemTableDescr"><a name="__getitemTableDescr"></a>
	    <h4 id="subsubsection4.5.3.2">__getitem__(key)</h4>

	    <p class="first">It takes different actions depending on the
	      type of the <tt class="verb">key</tt> parameter:</p>

	    <dl>
	      <dt><tt>key</tt> is an
		<tt class="verb">Integer</tt></dt> <dd>The corresponding
		table row is returned as a
		<tt class="verb">RecArray.Record</tt> object.</dd>

	      <dt><tt>key</tt> is a
		<tt class="verb">Slice</tt></dt><dd>The row slice
		determined by <tt class="verb">key</tt> is returned as a
		<tt class="verb">RecArray</tt> object.</dd>

	      <dt><tt>key</tt> is a
		<tt class="verb">String</tt></dt> <dd>The <tt class="verb">key</tt>
		is interpreted as a <em>column</em> name of the table,
		and, if it exists, it is read and returned as a
		<tt class="verb">NumArray</tt> or <tt class="verb">CharArray</tt> object
		(whatever is appropriate).</dd>
	    </dl>

	    <p>Example of use:</p>

	    <pre>
	      record = table[4]
	      recarray = table[4:1000:2]
	      narray = table["var2"]
	    </pre>

	    <p>Which is equivalent to:</p>

	    <pre>
	      record = table.read(start=4)[0]
	      recarray = table.read(start=4, stop=1000, step=2)
	      narray = table.read(field="var2")
	    </pre>

	  </div>

	  <div id="__setitemTableDescr"><a name="__setitemTableDescr"></a>
	    <h4 id="subsubsection4.5.3.3">__setitem__(key, value)</h4>

	    <p class="first">It takes different actions depending on the
	      type of the <tt class="verb">key</tt> parameter:</p>

	    <dl>
	      <dt><tt>key</tt> is an
		<tt class="verb">Integer</tt></dt> <dd>The corresponding
		table row is set to <em>value</em>. <em>value</em>
		must be a <tt class="verb">List</tt> or <tt class="verb">Tuple</tt>
		capable of being converted to the table field format.
		</dd>

	      <dt><tt>key</tt> is a
		<tt class="verb">Slice</tt></dt><dd>The row slice
		determined by key is set to
		<em>value</em>. <em>value</em> must be a
		<tt class="verb">RecArray</tt> object or a list of rows capable
		of being converted to the table field format.
	      </dd>
	    </dl>

	    <p>Example of use:</p>

	    <pre>
	      # Modify just one existing row
	      table[2] = [456,'db2',1.2]
	      # Modify two existing rows
	      rows = numarray.records.array([[457,'db1',1.2],[6,'de2',1.3]],
	                                    formats="i4,a3,f8")
	      table[1:3:2] = rows
	    </pre>

	    <p>Which is equivalent to:</p>

	    <pre>
	      table.modifyRows(start=2, [456,'db2',1.2])
	      rows = numarray.records.array([[457,'db1',1.2],[6,'de2',1.3]],
	                                    formats="i4,a3,f8")
	      table.modifyRows(start=1, step=2, rows)
	    </pre>

	  </div>
	</div> 

	<div id="RowClassDescr"><a name="RowClassDescr"></a>
	  <h3 id="subsection4.5.4"><span class="headlinenumber"><a name="subsection4.5.4"></a>4.5.4 </span>The <tt>Row</tt> class</h3>

	  <p class="first">This class is used to fetch and set values on the table
	    fields. It works very much like a dictionary, where the keys
	    are the field names of the associated table and the values
	    are the values of those fields in a specific row.
	  </p>
	  <p>This object turns out to actually be an extension type,
	    so you won't be able to access its documentation
	    interactively. Neither you won't be able to access its
	    internal attributes (they are not directly accessible from
	    Python), although <em>accessors</em> (i.e. methods that
	    return an internal attribute) have been defined for the most
	    important variables.
	  </p>

	  <div>
	    <h4 id="subsubsection4.5.4.1"><tt>Row</tt> methods
	    </h4>

	    <dl>

	      <dt id="appendRowDescr"><a name="appendRowDescr"></a>append()</dt> <dd>Once you
		have filled the proper fields for the current row,
		calling this method actually commits these data to the
		disk (actually data are written to the output
		buffer).</dd>

	      <dt>nrow()</dt> <dd>Accessor that returns the
		current row number in the table. It is useful to know
		which row is being dealt with in the middle of a
		loop.</dd>
	    </dl>
	  </div>
	</div> 

	<div id="ColsClassDescr"><a name="ColsClassDescr"></a>
	  <h3 id="subsection4.5.5"><span class="headlinenumber"><a name="subsection4.5.5"></a>4.5.5 </span>The <tt>Cols</tt> class</h3>

	  <p class="first">This class is used as an <em>accessor</em> to the table
	    columns following the natural name convention, so that you
	    can access the different columns because there exist one
	    attribute with the name of the columns for each associated
	    <tt class="verb">Column</tt> instances. Besides, and like the
	    <tt class="verb">Row</tt> class, it works similar to a dictionary,
	    where the keys are the column names of the associated
	    table and the values are <tt class="verb">Column</tt>
	    instances. See <a href="#ColumnClassDescr">section&nbsp;4.6</a>
	    for examples of use.
	  </p>
	</div> 
      </div> 

      <div id="ColumnClassDescr"><a name="ColumnClassDescr"></a>
	<h2 id="section4.6"><span class="headlinenumber"><a name="section4.6"></a>4.6 </span>The <tt>Column</tt> class</h2>

	<p class="first">Each instance of this class is associated with one column
	  of every table. These instances are mainly used to fetch and
	  set actual data from the table columns, but there are a few
	  other associated methods to deal with indexes.
	</p>

	<div>
	  <h3 id="subsection4.6.1"><span class="headlinenumber"><a name="subsection4.6.1"></a>4.6.1 </span><tt>Column</tt> instance
	    variables
	  </h3>
	  <dl>
	    <dt>table</dt> <dd>The parent <tt class="verb">Table</tt>
	      instance.
	    </dd>
	    <dt>name</dt> <dd>The name of the associated
	      column.
	    </dd>
	    <dt>type</dt> <dd>The data type of the column.
	    </dd>
	    <dt>index</dt> <dd>The associated <tt class="verb">Index</tt>
	      object (see <a href="#IndexClassDescr">4.13.3</a>) to this
	      column (<tt class="verb">None</tt> if doesn't exist).
	    </dd>
	    <dt>dirty</dt> <dd>Whether the index is dirty or not
	      (property).
	    </dd>
	  </dl>
	</div>

	<div>
	  <h3 id="subsection4.6.2"><span class="headlinenumber"><a name="subsection4.6.2"></a>4.6.2 </span><tt>Column</tt> methods
	  </h3>

	  <div id="createIndexColumnDescr"><a name="createIndexColumnDescr"></a>
	    <h4 id="subsubsection4.6.2.1"><tt>createIndex()</tt>
	    </h4>

	    <p class="first">Create an <tt class="verb">Index</tt> (see <a href="#IndexClassDescr">4.13.3</a>) object for this
		column.
	    </p>

	  </div>

	  <div id="reIndexColumnDescr"><a name="reIndexColumnDescr"></a>
	    <h4 id="subsubsection4.6.2.2"><tt>reIndex()</tt>
	    </h4>

	    <p class="first">Recompute the index associated with this column. This
	      can be useful when you suspect that, for any reason, the
	      index information is no longer valid and want to rebuild
	      it.
	    </p>

	  </div>

	  <div id="reIndexDirtyColumnDescr"><a name="reIndexDirtyColumnDescr"></a>
	    <h4 id="subsubsection4.6.2.3"><tt>reIndexDirty()</tt>
	    </h4>

	    <p class="first">Recompute the existing index only if it is dirty. This
	      can be useful when you have set the <tt class="verb">reindex</tt>
	      parameter to 0 in <tt class="verb">IndexProps</tt> constructor
	      (see <a href="#IndexPropsInitDescr">4.13.2</a>) for the
	      table and want to update the column's index after a
	      invalidating index operation
	      (<tt class="verb">Table.removeRows</tt>, for example).
	    </p>

	  </div>

	  <div id="removeIndexColumnDescr"><a name="removeIndexColumnDescr"></a>
	    <h4 id="subsubsection4.6.2.4"><tt>removeIndex()</tt>
	    </h4>

	    <p class="first">Delete the associated column's index. After doing that,
	      you will loose the indexation information on
	      disk. However, you can always re-create it using the
	      <tt class="verb">createIndex()</tt> method (see <a href="#createIndexColumnDescr">4.6.2</a>).
	    </p>

	  </div>

	  <div id="closeIndexColumnDescr"><a name="closeIndexColumnDescr"></a>
	    <h4 id="subsubsection4.6.2.5"><tt>closeIndex()</tt>
	    </h4>

	    <p class="first">Close the index of this column. After that, the column
	      will look as if it has no index, although it will
	      re-appear when the file would be re-opened later on.
	    </p>

	  </div>

	</div> 
	
	<div>
	  <h3 id="subsection4.6.3"><span class="headlinenumber"><a name="subsection4.6.3"></a>4.6.3 </span><tt>Column</tt> special methods
	  </h3>

	  <div id="__getitemColumnDescr"><a name="__getitemColumnDescr"></a>
	    <h4 id="subsubsection4.6.3.1"><tt>__getitem__(key)</tt>
	    </h4>

	    <p class="first">Returns a column element or slice. It takes different
	      actions depending on the type of the <em>key</em>
	      parameter:
	    </p>

	    <dl>
	      <dt><tt>key</tt> is an
		<tt class="verb">Integer</tt></dt> <dd>The corresponding
		element in the column is returned as a scalar object
		or as a <tt class="verb">NumArray</tt>/<tt class="verb">CharArray</tt>
		object, depending on its shape.
	      </dd>

	      <dt><tt>key</tt> is a
		<tt class="verb">Slice</tt></dt><dd>The row range
		determined by this slice is returned as a
		<tt class="verb">NumArray</tt> or <tt class="verb">CharArray</tt> object
		(whichever is appropriate).
	      </dd>

	    </dl>

	    <div class="p">Example of use:
	      <pre>
print "Column handlers:"
for name in table.colnames:
    print table.cols[name]
print
print "Some selections:"
print "Select table.cols.name[1]--&gt;", table.cols.name[1]
print "Select table.cols.name[1:2]--&gt;", table.cols.name[1:2]
print "Select table.cols.lati[1:3]--&gt;", table.cols.lati[1:3]
print "Select table.cols.pressure[:]--&gt;", table.cols.pressure[:]
print "Select table.cols['temperature'][:]--&gt;", table.cols['temperature'][:]
	      </pre>
	      and the output of this for a certain arbitrary table is:
	      <pre>
Column handlers:
/table.cols.name (Column(1,), CharType)
/table.cols.lati (Column(2,), Int32)
/table.cols.longi (Column(1,), Int32)
/table.cols.pressure (Column(1,), Float32)
/table.cols.temperature (Column(1,), Float64)

Some selections:
Select table.cols.name[1]--&gt; Particle:     11
Select table.cols.name[1:2]--&gt; ['Particle:     11']
Select table.cols.lati[1:3]--&gt; [[11 12]
 [12 13]]
Select table.cols.pressure[:]--&gt; [  90.  110.  132.]
Select table.cols['temperature'][:]--&gt; [ 100.  121.  144.]
	      </pre>
	      See the <tt class="verb">examples/table2.py</tt> for a more
	      complete example.
	    </div>

	  </div> 

	  <div id="__setitemColumnDescr"><a name="__setitemColumnDescr"></a>
	    <h4 id="subsubsection4.6.3.2">__setitem__(key, value)</h4>

	    <p class="first">It takes different actions depending on the
	      type of the <tt class="verb">key</tt> parameter:</p>

	    <dl>
	      <dt><tt>key</tt> is an
		<tt class="verb">Integer</tt></dt> <dd>The corresponding
		element in the column is set to
		<em>value</em>. <em>value</em> must be a scalar or
		<tt class="verb">NumArray</tt>/<tt class="verb">CharArray</tt>,
		depending on column's shape.
		</dd>

	      <dt><tt>key</tt> is a
		<tt class="verb">Slice</tt></dt><dd>The row slice
		determined by <em>key</em> is set to
		<em>value</em>. <em>value</em> must be a list of
		elements or a
		<tt class="verb">NumArray</tt>/<tt class="verb">CharArray</tt>.
	      </dd>
	    </dl>

	    <p>Example of use:</p>

	    <pre>
	      # Modify row 1
	      table.cols.col1[1] = -1
	      # Modify rows 1 and 3
	      table.cols.col1[1::2] = [2,3]
	    </pre>

	    <p>Which is equivalent to:</p>

	    <pre>
	      # Modify row 1
	      table.modifyColumns(start=1, columns=[[-1]], names=["col1"])
	      # Modify rows 1 and 3
	      columns = numarray.records.fromarrays([[2,3]], formats="i4")
	      table.modifyColumns(start=1, step=2, columns=columns, names=["col1"])
	    </pre>
	  </div> 

	</div> 
      </div> 

      <div id="ArrayClassDescr"><a name="ArrayClassDescr"></a>
	<h2 id="section4.7"><span class="headlinenumber"><a name="section4.7"></a>4.7 </span>The <tt>Array</tt>
	class</h2>

	<p class="first">Represents an array on file. It provides methods to
	  write/read data to/from array objects in the file. This
	  class does not allow you to enlarge the datasets on disk;
	  see the <tt class="verb">EArray</tt> descendant in <a href="#EArrayClassDescr">section&nbsp;4.8</a> if you want
	  enlargeable dataset support and/or compression features.
	</p>

	<p>The array data types supported are the same as the set
	  provided by <tt class="verb">Numeric</tt> and <tt class="verb">numarray</tt>.
	  For details of these data types see <a href="usersguide7.html#datatypesSupported">appendix&nbsp;A</a>, or the
	  <tt class="verb">numarray</tt> reference manual (<a href="#Numarray"></a>).
	</p>

	<p>Note that this object inherits all the public attributes
	  and methods that <tt class="verb">Leaf</tt> already provides.
	</p>

	<div id="ArrayClassInstanceVariables"><a name="ArrayClassInstanceVariables"></a>
	  <h3 id="subsection4.7.1"><span class="headlinenumber"><a name="subsection4.7.1"></a>4.7.1 </span><tt>Array</tt> instance
	    variables</h3>
	  <dl>
	    <dt>flavor</dt> <dd>The object representation for
	      this array. It can be any of <em>"NumArray"</em>,
	      <em>"CharArray"</em> <em>"Numeric"</em>,
	      <em>"List"</em>, <em>"Tuple"</em>, <em>"String"</em>,
	      <em>"Int"</em> or <em>"Float"</em> values.
	    </dd>
	    <dt>nrows</dt> <dd>The length of the first dimension
	      of Array.
	    </dd>
	    <dt>nrow</dt> <dd>On iterators, this is the index of
	      the current row.
	    </dd>

	    <dt>type</dt> <dd>The type class of the represented
	      array.
	    </dd>

	    <dt>itemsize</dt> <dd>The size of the base
              items. Specially useful for <tt class="verb">CharArray</tt>
              objects.
	    </dd>
	  </dl>

	</div>

	<div>
	  <h3 id="subsection4.7.2"><span class="headlinenumber"><a name="subsection4.7.2"></a>4.7.2 </span><tt>Array</tt>
	    methods</h3>

	  <p class="first">Note that, as this object has no internal I/O buffers, it
	    is not necessary to use the flush() method inherited from
	    <tt class="verb">Leaf</tt> in order to save its internal state to
	    disk. When a writing method call returns, all the data is
	    already on disk.
	  </p>

	  <div id="iterrowsArrayDescr"><a name="iterrowsArrayDescr"></a>
	    <h4 id="subsubsection4.7.2.1">iterrows(start=None,
	      stop=None, step=1)</h4>

	    <p class="first">Returns an iterator yielding <tt class="verb">numarray</tt>
	      instances built from rows in array. The return rows are
	      taken from the first dimension in case of an
	      <tt class="verb">Array</tt> instance and the enlargeable
	      dimension in case of an <tt class="verb">EArray</tt> instance. If
	      a range is supplied (i.e. some of the <em>start</em>,
	      <em>stop</em> or <em>step</em> parameters are passed),
	      only the appropriate rows are returned. Else, all the
	      rows are returned. See also the and
	      <tt class="verb">__iter__()</tt> special methods in <a href="#ArraySpecialMethods">section&nbsp;4.7.3</a> for a shorter
	      way to call this iterator.
	    </p>

	    <p>The meaning of the <em>start</em>, <em>stop</em> and
	      <em>step</em> parameters is the same as in the
	      <tt class="verb">range()</tt> python function, except that
	      negative values of <tt class="verb">step</tt> are not
	      allowed. Moreover, if only <tt class="verb">start</tt> is
	      specified, then <tt class="verb">stop</tt> will be set to
	      <tt class="verb">start+1</tt>. If you do not specify neither
	      <em>start</em> nor <em>stop</em>, then all the rows in
	      the object are selected.
	    </p>

	    <p>Example of use:</p>
	    <pre>
	      result = [ row for row in arrayInstance.iterrows(step=4) ]
	    </pre>

	  </div>

	  <div id="readArrayDescr"><a name="readArrayDescr"></a>
	    <h4 id="subsubsection4.7.2.2">read(start=None, stop=None, step=1)</h4>

	    <p class="first">Read the array from disk and return it as a
	      <tt class="verb">numarray</tt> (default) object, or an object
	      with the same original <em>flavor</em> that it was
	      saved. It accepts start, stop and step parameters to
	      select rows (the first dimension in the case of an
	      <tt class="verb">Array</tt> instance and the <em>enlargeable</em>
	      dimension in case of an <tt class="verb">EArray</tt>) for
	      reading.
	    </p>
	    <p>The meaning of the <em>start</em>, <em>stop</em> and
	      <em>step</em> parameters is the same as in the
	      <tt class="verb">range()</tt> python function, except that
	      negative values of <tt class="verb">step</tt> are not
	      allowed. Moreover, if only <tt class="verb">start</tt> is
	      specified, then <tt class="verb">stop</tt> will be set to
	      <tt class="verb">start+1</tt>. If you do not specify neither
	      <em>start</em> nor <em>stop</em>, then all the rows in
	      the object are selected.
	    </p>
	  </div> 
	</div> 

	<div id="ArraySpecialMethods"><a name="ArraySpecialMethods"></a>
	  <h3 id="subsection4.7.3"><span class="headlinenumber"><a name="subsection4.7.3"></a>4.7.3 </span><tt>Array</tt> special
	      methods</h3>

	  <p class="first">Following are described the methods that automatically
	    trigger actions when an <tt class="verb">Array</tt> instance is
	    accessed in a special way (e.g.,
	    <tt class="verb">array[2:3,...,::2]</tt> will be equivalent to a
	    call to <br><tt class="verb">array.__getitem__(slice(2,3, None),
	    Ellipsis, slice(None, None, 2))</tt>).
	  </p>

	  <div id="__iterArrayDescr"><a name="__iterArrayDescr"></a>
	    <h4 id="subsubsection4.7.3.1">__iter__()</h4>

	    <p class="first">It returns the same iterator than
	      <tt class="verb">Array.iterrows(0,0,1)</tt>. However, this does not
	      accept parameters.</p>

	    <p>Example of use:</p>

	    <pre>
	      result = [ row[2] for row in array ]

	    </pre>

	    <p>Which is equivalent to:</p>

	    <pre>
	      result = [ row[2] for row in array.iterrows(0, 0, 1) ]
	    </pre>

	  </div>

	  <div id="__getitemArrayDescr"><a name="__getitemArrayDescr"></a>
	    <h4 id="subsubsection4.7.3.2">__getitem__(key)</h4>

	    <p class="first">It returns a <tt class="verb">numarray</tt> (default) object (or
	      an object with the same original <em>flavor</em> that it
	      was saved) containing the slice of rows stated in the
	      <tt class="verb">key</tt> parameter. The set of allowed tokens in
	      <tt class="verb">key</tt> is the same as extended slicing in
	      python (the <tt class="verb">Ellipsis</tt> token included).
	    </p>

	    <p>Example of use:</p>

	    <pre>
	      array1 = array[4]   # array1.shape == array.shape[1:]
	      array2 = array[4:1000:2]  # len(array2.shape) == len(array.shape)
	      array3 = array[::2, 1:4, :]
	      array4 = array[1, ..., ::2, 1:4, 4:] # General slice selection
	    </pre>

	  </div> 

	  <div id="__setitemArrayDescr"><a name="__setitemArrayDescr"></a>
	    <h4 id="subsubsection4.7.3.3">__setitem__(key, value)</h4>

	    <p class="first">Sets an Array element, row or extended slice. It takes
	      different actions depending on the type of the
	      <tt class="verb">key</tt> parameter:
	    </p>
	    <dl>
	      <dt><tt class="verb">key</tt> is an integer:</dt> <dd>The
		corresponding row is assigned to value. If needed,
		this <tt class="verb">value</tt> is broadcasted to fit the
		specified row.</dd>
	      
	      <dt><tt class="verb">key</tt> is a slice:</dt> <dd>The row
		slice determined by it is assigned to
		<tt class="verb">value</tt>. If needed, this <tt class="verb">value</tt>
		is broadcasted to fit in the desired range. If the
		slice to be updated exceeds the actual shape of the
		array, only the values in the existing range are
		updated, i.e. the index error will be silently
		ignored. If <tt class="verb">value</tt> is a multidimensional
		object, then its shape must be compatible with the
		slice specified in <tt class="verb">key</tt>, otherwhise, a
		<tt class="verb">ValueError</tt> will be issued.</dd>

	    </dl>

	    <p>Example of use:</p>

	    <pre>
	      a1[0] = 333       # Assign an integer to a Integer Array row
	      a2[0] = "b"       # Assign a string to a string Array row
	      a3[1:4] = 5       # Broadcast 5 to slice 1:4
	      a4[1:4:2] = "xXx" # Broadcast "xXx" to slice 1:4:2
	      # General slice update (a5.shape = (4,3,2,8,5,10)
	      a5[1, ..., ::2, 1:4, 4:] = arange(1728, shape=(4,3,2,4,3,6))
	    </pre>

	  </div> 

	</div> 
      </div> 

      <div id="EArrayClassDescr"><a name="EArrayClassDescr"></a>
	<h2 id="section4.8"><span class="headlinenumber"><a name="section4.8"></a>4.8 </span>The <tt>EArray</tt> class</h2>

	<p class="first">This is a child of the <tt class="verb">Array</tt> class (see <a href="#ArrayClassDescr">4.7</a>) and as such,
	  <tt class="verb">EArray</tt> represents an array on the file. The
	  difference is that <tt class="verb">EArray</tt> allows to enlarge
	  datasets along any single dimension<a href="#footnote7" id="footnoteback7"><sup title="In the future, multiple enlargeable dimensions might be implemented as well.">7)</sup></a> you select. Another important difference is
	  that it also supports compression.
	 </p>

	<p>So, in addition to the attributes and methods that
	  <tt class="verb">EArray</tt> inherits from <tt class="verb">Array</tt>, it
	  supports a few more that provide a way to enlarge the
	  arrays on disk. Following are described the new variables
	  and methods as well as some that already exist in
	  <tt class="verb">Array</tt> but that differ somewhat on the meaning
	  and/or functionality in the <tt class="verb">EArray</tt> context.
	</p>

	<div id="EArrayClassInstanceVariables"><a name="EArrayClassInstanceVariables"></a>
	  <h3 id="subsection4.8.1"><span class="headlinenumber"><a name="subsection4.8.1"></a>4.8.1 </span><tt>EArray</tt> instance
	    variables</h3>
	  <dl>
	    <dt>atom</dt> <dd>The class instance chosen for the
	      atom object (see <a href="#AtomClassDescr">section&nbsp;4.12.3</a>).
	    </dd>
	    <dt>extdim</dt> <dd>The enlargeable dimension.
	    </dd>
	    <dt>nrows</dt> <dd>The length of the enlargeable
	      dimension.
	    </dd>
	  </dl>
	</div>

	<div id="EArrayMethodsDescr"><a name="EArrayMethodsDescr"></a>
	  <h3 id="subsection4.8.2"><span class="headlinenumber"><a name="subsection4.8.2"></a>4.8.2 </span><tt>EArray</tt>
	    methods</h3>

	  <div id="EArrayAppendDescr"><a name="EArrayAppendDescr"></a>
	    <h4 id="subsubsection4.8.2.1">append(object)</h4>

	    <p class="first">Appends an <tt class="verb">object</tt> to the underlying
	      dataset. Obviously, this object has to have the same
	      type as the <tt class="verb">EArray</tt> instance; otherwise a
	      <tt class="verb">TypeError</tt> is issued. In the same way, the
	      dimensions of the <tt class="verb">object</tt> have to conform to
	      those of <tt class="verb">EArray</tt>, that is, all the
	      dimensions have to be the same except, of course, that of
	      the enlargeable dimension which can be of any length
	      (even 0!).
	    </p>
	    <p>Example of use (code available in
	      <tt class="verb">examples/earray1.py</tt>):
	    </p>
	    <pre>
import tables
from numarray import strings

fileh = tables.openFile("earray1.h5", mode = "w")
a = tables.StringAtom(shape=(0,), length=8)
# Use 'a' as the object type for the enlargeable array
array_c = fileh.createEArray(fileh.root, 'array_c', a, "Chars")
array_c.append(strings.array(['a'*2, 'b'*4], itemsize=8))
array_c.append(strings.array(['a'*6, 'b'*8, 'c'*10], itemsize=8))

# Read the string EArray we have created on disk
for s in array_c:
    print "array_c[%s] =&gt; '%s'" % (array_c.nrow, s)
# Close the file
fileh.close()
	    </pre>

	    <p>and the output is:
	    </p>

	    <pre>
	      array_c[0] =&gt; 'aa'
	      array_c[1] =&gt; 'bbbb'
	      array_c[2] =&gt; 'aaaaaa'
	      array_c[3] =&gt; 'bbbbbbbb'
	      array_c[4] =&gt; 'cccccccc'
	    </pre>

	  </div> 
	</div> 
      </div> 

      <div id="VLArrayClassDescr"><a name="VLArrayClassDescr"></a>
	<h2 id="section4.9"><span class="headlinenumber"><a name="section4.9"></a>4.9 </span>The <tt>VLArray</tt> class</h2>

	<p class="first">Instances of this class represents array objects in the
	  object tree with the property that their rows can have a
	  <b>variable</b> number of
	  (homogeneous) elements (called <em>atomic</em> objects, or
	  just <em>atoms</em>). Variable length arrays (or
	  <em>VLA's</em> for short), similarly to <tt class="verb">Table</tt>
	  instances, can have only one dimension, and likewise
	  <tt class="verb">Table</tt>, the compound elements (the
	  <em>atoms</em>) of the rows of <tt class="verb">VLArrays</tt> can be
	  fully multidimensional objects.
	</p>
	<p><tt class="verb">VLArray</tt> provides methods to read/write data
	  from/to variable length array objects residents on disk.
	  Also, note that this object inherits all the public
	  attributes and methods that <tt class="verb">Leaf</tt> already has.
	</p>

	<div>
	  <h3 id="subsection4.9.1"><span class="headlinenumber"><a name="subsection4.9.1"></a>4.9.1 </span><tt>VLArray</tt> instance
	    variables</h3>
	  <dl>
	    <dt>atom</dt> <dd>The class instance chosen for the
	      atom object (see <a href="#AtomClassDescr">section&nbsp;4.12.3</a>).
	    </dd>
	    <dt>nrow</dt> <dd>On iterators, this is the index of
	      the current row.
	    </dd>
	    <dt>nrows</dt> <dd>The total number of rows.
	    </dd>
	  </dl>
	</div>

	<div>
	  <h3 id="subsection4.9.2"><span class="headlinenumber"><a name="subsection4.9.2"></a>4.9.2 </span><tt>VLArray</tt> methods</h3>

	  <div>
	    <h4 id="appendVLArrayDescr"><a name="appendVLArrayDescr"></a>append(object1, object2, ...)</h4>

	    <p class="first">Append the <tt class="verb">objects</tt> passed as parameters to
	      a single row in the <tt class="verb">VLArray</tt> instance. The
	      type of the objects has to be compliant with the
	      <tt class="verb">VLArray.atom</tt> instance type.
	    </p>

	    <p>Example of use (code available in
	      <tt class="verb">examples/vlarray1.py</tt>):
	    </p>

	    <pre>
	      import tables
	      from Numeric import *   # or, from numarray import *

	      # Create a VLArray:
	      fileh = tables.openFile("vlarray1.h5", mode = "w")
	      vlarray = fileh.createVLArray(fileh.root, 'vlarray1',
	      tables.Int32Atom(flavor="Numeric"),
	                       "ragged array of ints", Filters(complevel=1))
	      # Append some (variable length) rows
	      # All these different parameter specification are accepted:
	      vlarray.append(array([5, 6]))
	      vlarray.append(array([5, 6, 7]))
	      vlarray.append([5, 6, 9, 8])
	      vlarray.append(5, 6, 9, 10, 12)

	      # Now, read it through an iterator
	      for x in vlarray:
	          print vlarray.name+"["+str(vlarray.nrow)+"]--&gt;", x

	      # Close the file
	      fileh.close()
	    </pre>

	    <p>And the output for this looks like:</p>

	    <pre>
	      vlarray1[0]--&gt; [5 6]
	      vlarray1[1]--&gt; [5 6 7]
	      vlarray1[2]--&gt; [5 6 9 8]
	      vlarray1[3]--&gt; [ 5  6  9 10 12]
	    </pre>

	  </div> 

	  <div id="iterrowsVLArrayDescr"><a name="iterrowsVLArrayDescr"></a>
	    <h4 id="subsubsection4.9.2.2">iterrows(start=None,
	      stop=None, step=1)</h4>

	    <p class="first">Returns an iterator yielding one row per iteration. If
	      a range is supplied (i.e. some of the <em>start</em>,
	      <em>stop</em> or <em>step</em> parameters are passed),
	      only the appropriate rows are returned. Else, all the
	      rows are returned. See also the <tt class="verb">__iter__()</tt>
	      special methods in <a href="#VLArraySpecialMethods">section&nbsp;4.9.3</a> for a
	      shorter way to call this iterator.
	    </p>
	    <p>The meaning of the <em>start</em>, <em>stop</em> and
	      <em>step</em> parameters is the same as in the
	      <tt class="verb">range()</tt> python function, except that
	      negative values of <tt class="verb">step</tt> are not
	      allowed. Moreover, if only <tt class="verb">start</tt> is
	      specified, then <tt class="verb">stop</tt> will be set to
	      <tt class="verb">start+1</tt>. If you do not specify neither
	      <em>start</em> nor <em>stop</em>, then all the rows in
	      the object are selected.
	    </p>

	    <p>Example of use:</p>

	    <pre>
	      for row in vlarray.iterrows(step=4):
	          print vlarray.name+"["+str(vlarray.nrow)+"]--&gt;", row
	    </pre>

	  </div> 

	  <div id="readVLArrayDescr"><a name="readVLArrayDescr"></a>
	    <h4 id="subsubsection4.9.2.3">read(start=None, stop=None,
	      step=1)</h4>

	    <p class="first">Returns the actual data in <tt class="verb">VLArray</tt>. As the
	      lengths of the different rows are variable, the returned
	      value is a python list, with as many entries as
	      specified rows in the range parameters.
	    </p>
	    <p>The meaning of the <em>start</em>, <em>stop</em> and
	      <em>step</em> parameters is the same as in the
	      <tt class="verb">range()</tt> python function, except that
	      negative values of <tt class="verb">step</tt> are not
	      allowed. Moreover, if only <tt class="verb">start</tt> is
	      specified, then <tt class="verb">stop</tt> will be set to
	      <tt class="verb">start+1</tt>. If you do not specify neither
	      <em>start</em> nor <em>stop</em>, then all the rows in
	      the object are selected.
	    </p>
	  </div>

	</div> 

	<div id="VLArraySpecialMethods"><a name="VLArraySpecialMethods"></a>
	  <h3 id="subsection4.9.3"><span class="headlinenumber"><a name="subsection4.9.3"></a>4.9.3 </span><tt>VLArray</tt> special
	      methods</h3>

	  <p class="first">Following are described the methods that automatically
	    trigger actions when a <tt class="verb">VLArray</tt> instance is
	    accessed in a special way (e.g., <tt class="verb">vlarray[2:5]</tt>
	    will be equivalent to a call to
	    <tt class="verb">vlarray.__getitem__(slice(2,5,None)</tt>).
	  </p>

	  <div id="__iterVLArrayDescr"><a name="__iterVLArrayDescr"></a>
	    <h4 id="subsubsection4.9.3.1">__iter__()</h4>

	    <p class="first">It returns the same iterator than
	      <tt class="verb">VLArray.iterrows(0,0,1)</tt>. However, this does
	      not accept parameters.</p>

	    <p>Example of use:</p>

	    <pre>
	      result = [ row for row in vlarray ]
	    </pre>

	    <p>Which is equivalent to:</p>

	    <pre>
	      result = [ row for row in vlarray.iterrows() ]
	    </pre>

	  </div>

	  <div id="__getitemVLArrayDescr"><a name="__getitemVLArrayDescr"></a>
	    <h4 id="subsubsection4.9.3.2">__getitem__(key)</h4>

	    <p class="first">It returns the slice of rows determined by
	      <tt class="verb">key</tt>, which can be an integer index or an
	      extended slice. The returned value is a list of objects
	      of type <tt class="verb">array.atom.type</tt>.
	    </p>

	    <p>Example of use:</p>

	    <pre>
	      list1 = vlarray[4]
	      list2 = vlarray[4:1000:2]
	    </pre>

	  </div> 

	  <div id="__setitemVLArrayDescr"><a name="__setitemVLArrayDescr"></a>
	    <h4 id="subsubsection4.9.3.3">__setitem__(keys, value)</h4>

	    <p class="first">Updates a vlarray row described by <tt class="verb">keys</tt> by
	      setting it to <tt class="verb">value</tt>. Depending on the value
	      of <tt class="verb">keys</tt>, the action taken is different:
	    </p>
	    <dl>
	      <dt><tt class="verb">keys</tt> is an integer:</dt> <dd>It
		refers to the number of row to be modified. The
		<tt class="verb">value</tt> object must be type and shape
		compatible with the object that exists in the vlarray
		row.</dd>

	      <dt><tt class="verb">keys</tt> is a tuple:</dt> <dd>The
		first element refers to the row to be modified, and
		the second element to the range (so, it can be an
		integer or an slice) of the row that will be
		updated. As above, the <tt class="verb">value</tt> object must
		be type and shape compatible with the object specified
		in the vlarray row <em>and</em> range.</dd>
	    </dl>


	    <p><b>Note:</b> When updating
	      <tt class="verb">VLStrings</tt> (codification UTF-8) or
	      <tt class="verb">Objects</tt> atoms, there is a problem: one can
	      only update values with <em>exactly</em> the same bytes
	      than in the original row. With UTF-8 encoding this is
	      problematic because, for instance, '<tt class="verb">c</tt>'
	      takes 1 byte, but '<tt class="verb">&ccedil;</tt>' takes two. The same
	      applies when using <tt class="verb">Objects</tt> atoms, because
	      when cPickle applies to a class instance (for example),
	      it does not guarantee to return the same number of bytes
	      than over other instance, even of the same class than
	      the former. These facts effectively limit the number of
	      objects than can be updated in <tt class="verb">VLArrays</tt>.
	    </p>

	    <p>Example of use:</p>

	    <pre>
	      vlarray[0] = vlarray[0]*2+3
	      vlarray[99,3:] = arange(96)*2+3
	      # Negative values for start and stop (but not step) are supported
	      vlarray[99,-99:-89:2] = vlarray[5]*2+3 
	    </pre>

	  </div> 

	</div>  
      </div> 

      <div id="UnImplementedClassDescr"><a name="UnImplementedClassDescr"></a>
	<h2 id="section4.10"><span class="headlinenumber"><a name="section4.10"></a>4.10 </span>The <tt>UnImplemented</tt> class</h2>

	<p class="first">Instances of this class represents an unimplemented dataset
	  in a generic HDF5 file. When reading such a file (i.e. one
	  that has not been created with <tt class="verb">PyTables</tt>, but
	  with some other HDF5 library based tool), chances are that
	  the specific combination of <em>datatypes</em> and/or
	  <em>dataspaces</em> in some dataset might not be supported
	  by <tt class="verb">PyTables</tt> yet. In such a case, this dataset
	  will be mapped into the <tt class="verb">UnImplemented</tt> class and
	  hence, the user will still be able to build the complete
	  object tree of this generic HDF5 file, as well as enabling
	  the access (both read and <em>write</em>) of the attributes
	  of this dataset and some metadata. Of course, the user won't
	  be able to read the actual data on it.
	</p>

	<p>This is an elegant way to allow users to work with generic
	  HDF5 files despite the fact that some of its datasets would
	  not be supported by <tt class="verb">PyTables</tt>. However, if you
	  are really interested in having access to an unimplemented
	  dataset, please, get in contact with the developer team.
	</p>
	<p>This class does not have any public instance variables,
	  except those inherited from the <tt class="verb">Leaf</tt> class
	  (<a href="#LeafClassDescr">see&nbsp;4.4</a>).
	</p>
      </div> 

      <div id="AttributeSetClassDescr"><a name="AttributeSetClassDescr"></a>
	<h2 id="section4.11"><span class="headlinenumber"><a name="section4.11"></a>4.11 </span>The <tt>AttributeSet</tt>
	class</h2>

	<p class="first">Represents the set of attributes of a node (Leaf or
	  Group). It provides methods to create new attributes, open,
	  rename or delete existing ones.
	</p>

	<p>Like in <tt class="verb">Group</tt> instances,
           <tt class="verb">AttributeSet</tt> instances make use of the
           <em>natural naming</em> convention, i.e. you can access the
           attributes on disk like if they were <em>normal</em>
           <tt class="verb">AttributeSet</tt> attributes. This offers the user
           a very convenient way to access (but also to set and
           delete) node attributes by simply specifying them like a
           <em>normal</em> attribute class.
        </p>

	<p><b>Caveat:</b> All Python data types
	  are supported. The scalar ones (i.e. String, Int and Float)
	  are mapped directly to the HDF5 counterparts, so you can
	  correctly visualize them with any HDF5 tool. However, the
	  rest of the data types and more general objects are
	  serialized using <tt class="verb">cPickle</tt>, so you will be able
	  to correctly retrieve them only from a Python-aware HDF5
	  library. Hopefully, the list of supported native attributes
	  will be extended to fully multidimensional arrays sometime
	  in the future.
	</p>

	<div id="AttributeSetClassInstanceVariables"><a name="AttributeSetClassInstanceVariables"></a>
	  <h3 id="subsection4.11.1"><span class="headlinenumber"><a name="subsection4.11.1"></a>4.11.1 </span><tt>AttributeSet</tt> instance
	    variables</h3>
	  <dl>

	    <dt>_v_node</dt> <dd>The parent node instance.</dd>

	    <dt>_v_attrnames</dt> <dd>List with all attribute
	      names.</dd>

	    <dt>_v_attrnamessys</dt> <dd>List with system attribute
	      names.</dd>

	    <dt>_v_attrnamesuser</dt> <dd>List with user attribute
	      names.</dd>

	  </dl>

	</div>

	<div>
	  <h3 id="subsection4.11.2"><span class="headlinenumber"><a name="subsection4.11.2"></a>4.11.2 </span><tt>AttributeSet</tt>
	    methods</h3>

	  <p class="first">Note that this class define the <tt class="verb">__setattr__</tt>,
	    <tt class="verb">__getattr__</tt> and <tt class="verb">__delattr__</tt> and
	    they work as normally intended. Any scalar (string, ints
	    or floats) attribute is supported natively as an
	    attribute. However, <tt class="verb">(c)Pickle</tt> is
	    automatically used so as to serialize other kind of
	    objects (like lists, tuples, dicts, small Numeric/numarray
	    objects, ...)  that you might want to save.
	  </p>
	  <div class="p">With these special methods, you can access, assign or
	    delete attributes on disk by just using the next
	    constructs:

	    <pre>
	      leaf.attrs.myattr = "str attr"  # Set a string (native support)
	      leaf.attrs.myattr2 = 3          # Set an integer (native support)
	      leaf.attrs.myattr3 = [3,(1,2)]  # A generic object (Pickled)
	      attrib = leaf.attrs.myattr      # Get the attribute myattr
	      del leaf.attrs.myattr           # Delete the attribute myattr
	    </pre>             

	  </div>

	  <dl>
	    <dt id="copyAttrDescr"><a name="copyAttrDescr"></a>_f_copy(where)</dt><dd>Copy
	      the user attributes to <em>where</em>
	      object. <em>where</em> has to be a <tt class="verb">Group</tt> or
	      <tt class="verb">Leaf</tt> instance.
	    </dd>
	    <dt id="listAttrDescr"><a name="listAttrDescr"></a>_f_list(attrset = "user")</dt>
	    <dd>Return the list of attributes of the parent
	    node. <em>attrset</em> selects the attribute set to be
	    returned. An <tt class="verb">"user"</tt> value returns only the
	    user attributes and this is the
	    default. <tt class="verb">"sys"</tt> returns only the system (some
	    of which are read-only)
	    attributes. <tt class="verb">"readonly"</tt> returns the system
	    read-only attributes. <tt class="verb">"all"</tt> returns both the
	    system and user attributes.
	    </dd>

	    <dt id="renameAttrDescr"><a name="renameAttrDescr"></a>_f_rename(oldattrname,
	      newattrname)</dt><dd>Rename an attribute.</dd>
	  </dl>
	  
	</div>

      </div> 

      <div id="declarativeClasses"><a name="declarativeClasses"></a>
	<h2 id="section4.12"><span class="headlinenumber"><a name="section4.12"></a>4.12 </span>Declarative classes
	</h2>
	<p class="first">In this section a series of classes that are meant to
	  <em>declare</em> datatypes that are required for primary
	  <tt class="verb">PyTables</tt> (like <tt class="verb">Table</tt> or
	  <tt class="verb">VLArray</tt> ) objects are described.
	</p>

	<div id="IsDescriptionClassDescr"><a name="IsDescriptionClassDescr"></a>
	  <h3 id="subsection4.12.1"><span class="headlinenumber"><a name="subsection4.12.1"></a>4.12.1 </span>The <tt>IsDescription</tt>
	    class</h3>

	  <p class="first">This class is in fact a so-called <em>metaclass</em>
	    object. There is nothing special on this fact, except that
	    their subclasses attributes are transformed during its
	    instantiation phase, and new methods for instances are
	    defined based on the values of the class attributes.
	  </p>
	  <p>It is designed to be used as an easy, yet meaningful way
	    to describe the properties of <tt class="verb">Table</tt> objects
	    through the use of classes that inherit properties from
	    it. In order to define such a special class, you have to
	    declare it as descendant of <em>IsDescription</em>, with
	    many attributes as columns you want in your table. The
	    name of these attributes will become the name of the
	    columns, while its values are the properties of the
	    columns that are obtained through the use of the <a href="#ColClassDescr">Col&nbsp;4.12.2</a> class constructor.
	  </p>
	  <p>Then, you can pass an instance of this object to the
	    <tt class="verb">Table</tt> constructor, where all the information it
	    contains will be used to define the table structure. See
	    the <a href="usersguide3.html#secondExample">section&nbsp;3.3</a> for an example
	    on how that works.
	  </p>
	  <p>Moreover, you can change the properties of the index
	    creation process by using an instance of the <a href="#IndexPropsClassDescr">IndexProps&nbsp;4.13.2</a> class and
	    assign it to a special attribute called
	    <tt class="verb">_v_indexprops</tt>.
	  </p>

	</div> 

	<div id="ColClassDescr"><a name="ColClassDescr"></a>
	  <h3 id="subsection4.12.2"><span class="headlinenumber"><a name="subsection4.12.2"></a>4.12.2 </span>The <tt>Col</tt> class and its descendants</h3>

	  <p class="first">The <tt class="verb">Col</tt> class is used as a mean to declare
	    the different properties of a table column. In addition, a
	    series of descendant classes are offered in order to make
	    these column descriptions easier to the user. In general,
	    it is recommended to use these descendant classes, as they
	    are more meaningful when found in the middle of the code.
	  </p>
	  <p>Note that the only public method accessible in these
	    classes is the constructor itself.
	  </p>

	  <dl>

	    <dt>Col(dtype="Float64", shape=1, dflt=None, pos=None,
	      indexed=0)
	    </dt>
	    <dd>Declare the properties of a <tt class="verb">Table</tt>
	      column.

	      <dl>

		<dt>dtype</dt> <dd>The data type for the
		  column. All types listed in <a href="usersguide7.html#datatypesSupported"> appendix&nbsp;A</a> are valid
		  data types for columns.  The type description is
		  accepted both in string format and as a numarray
		  data type.</dd>

		<dt>shape</dt> <dd>An integer or a tuple, that
		  specifies the number of <em>dtype</em> items for
		  each element (or shape, for multidimensional
		  elements) of this column. For <tt class="verb">CharType</tt>
		  columns, the last dimension is used as the length
		  of the character strings. However, for this kind of
		  objects, the use of <tt class="verb">StringCol</tt> subclass
		  is strongly recommended.</dd>

		<dt>dflt</dt> <dd>The default value for elements
		  of this column. If the user does not supply a value
		  for an element while filling a table, this default
		  value will be written to disk. If the user supplies an
		  scalar value for a multidimensional column, this value
		  is automatically <em>broadcasted</em> to all the
		  elements in the column cell. If <em>dflt</em> is not
		  supplied, an appropriate zero value (or <em>null</em>
		  string) will be chosen by default.</dd>

		<dt>pos</dt> <dd>By default, columns are arranged
		  in memory following an alpha-numerical order of the
		  column names. In some situations, however, it is
		  convenient to impose a user defined
		  ordering. <em>pos</em> parameter allows the user to
		  force the desired ordering.</dd>

		<dt>indexed</dt> <dd>Whether this column should
		  be indexed for better performance in table
		  selections. </dd>

	      </dl>
	    </dd>

	    <dt>StringCol(length=None, dflt=None, shape=1, pos=None,
	      indexed=0)
	    </dt>
	    <dd>Declare a column to be of type
	      <tt class="verb">CharType</tt>. The <em>length</em> parameter
	      sets the length of the strings. The meaning of the other
	      parameters are like in the <tt class="verb">Col</tt> class.
	    </dd>

	    <dt>BoolCol(dflt=0, shape=1, pos=None, indexed=0) </dt>
	      <dd>Define a column to be of type <tt class="verb">Bool</tt>.
	      The meaning of the parameters are the same of those in
	      the <tt class="verb">Col</tt> class.
	    </dd>

	    <dt>IntCol(dflt=0, shape=1, itemsize=4, sign=1,
	      pos=None, indexed=0)
	    </dt>
	    <dd>Declare a column to be of type <tt class="verb">IntXX</tt>,
	      depending on the value of <em>itemsize</em> parameter,
	      that sets the number of bytes of the integers in the
	      column. <em>sign</em> determines whether the integers
	      are signed or not. The meaning of the other parameters
	      are the same of those in the <tt class="verb">Col</tt> class.

	      <p class="first">This class has several descendants:
	      </p>

	      <dl>
		<dt>Int8Col(dflt=0, shape=1, pos=None,
		  indexed=0)</dt> <dd>Define a column of type
		  <tt class="verb">Int8</tt>.</dd>

		<dt>UInt8Col(dflt=0, shape=1, pos=None,
		  indexed=0)</dt> <dd>Define a column of type
		  <tt class="verb">UInt8</tt>.</dd>

		<dt>Int16Col(dflt=0, shape=1, pos=None, indexed=0)</dt>
		<dd>Define a column of type <tt class="verb">Int16</tt>.</dd>

		<dt>UInt16Col(dflt=0, shape=1, pos=None, indexed=0)</dt>
		<dd>Define a column of type <tt class="verb">UInt16</tt>.</dd>

		<dt>Int32Col(dflt=0, shape=1, pos=None, indexed=0)</dt>
		<dd>Define a column of type <tt class="verb">Int32</tt>.</dd>

		<dt>UInt32Col(dflt=0, shape=1, pos=None, indexed=0)</dt>
		<dd>Define a column of type <tt class="verb">UInt32</tt>.</dd>

		<dt>Int64Col(dflt=0, shape=1, pos=None, indexed=0)</dt>
		<dd>Define a column of type <tt class="verb">Int64</tt>.</dd>

		<dt>UInt64Col(dflt=0, shape=1, pos=None, indexed=0)</dt>
		<dd>Define a column of type <tt class="verb">UInt64</tt>.</dd>

	      </dl>

	    </dd>

	    <dt>FloatCol(dflt=0.0, shape=1, itemsize=8, pos=None,
	      indexed=0)
	    </dt>
	    <dd>Define a column to be of type <tt class="verb">FloatXX</tt>,
	      depending on the value of <tt class="verb">itemsize</tt>. The
	      <tt class="verb">itemsize</tt> parameter sets the number of bytes
	      of the floats in the column and the default is 8 bytes
	      (double precision). The meaning of the other parameters
	      are the same as those in the <tt class="verb">Col</tt> class.

	      <p class="first">This class has two descendants:
	      </p>

	      <dl>
		<dt>Float32Col(dflt=0.0, shape=1, pos=None,
		  indexed=0)</dt> <dd>Define a column of type
		  <tt class="verb">Float32</tt>.</dd>

		<dt>Float64Col(dflt=0.0, shape=1, pos=None,
		  indexed=0)</dt> <dd>Define a column of type
		  <tt class="verb">Float64</tt>.</dd>

	      </dl>
	    </dd>

	    <dt>ComplexCol(dflt=0.+0.j, shape=1, itemsize=16, pos=None)
	    </dt>
	    <dd>Define a column to be of type
	      <tt class="verb">ComplexXX</tt>, depending on the value of
	      <tt class="verb">itemsize</tt>. The <tt class="verb">itemsize</tt>
	      parameter sets the number of bytes of the complex types
	      in the column and the default is 16 bytes (double
	      precision complex). The meaning of the other parameters
	      are the same as those in the <tt class="verb">Col</tt> class.

	      <p class="first">This class has two descendants:
	      </p>

	      <dl>
		<dt>Complex32Col(dflt=0.+0.j, shape=1, pos=None)</dt>
		<dd>Define a column of type <tt class="verb">Complex32</tt>.</dd>

		<dt>Float64Col(dflt=0+0.j, shape=1, pos=None)</dt>
		<dd>Define a column of type <tt class="verb">Complex64</tt>.</dd>

	      </dl>

	      <p><tt class="verb">ComplexCol</tt> columns and its descendants
		do not support indexation.</p>

	    </dd>

	  </dl>
	</div> 

	<div id="AtomClassDescr"><a name="AtomClassDescr"></a>
	  <h3 id="subsection4.12.3"><span class="headlinenumber"><a name="subsection4.12.3"></a>4.12.3 </span>The <tt>Atom</tt> class and its
	    descendants.
	  </h3>
	  <p class="first">The <tt class="verb">Atom</tt> class is meant to declare the
	    different properties of the <em>base element</em> (also
	    known as <em>atom</em>) of <tt class="verb">EArray</tt> and
	    <tt class="verb">VLArray</tt> objects. The <tt class="verb">Atom</tt>
	    instances have the property that their length is always the
	    same. However, you can grow objects along the extendable
	    dimension in the case of <tt class="verb">EArray</tt> or put a
	    variable number of them on a <tt class="verb">VLArray</tt>
	    row. Moreover, the atoms are not restricted to scalar
	    values, and they can be fully multidimensional objects.
	  </p>
	  <p>A series of descendant classes are offered in order to
	    make the use of these element descriptions easier. In
	    general, it is recommended to use these descendant
	    classes, as they are more meaningful when found in the
	    middle of the code. Note that the only public methods
	    accessible in these classes are the
	    <tt class="verb">atomsize()</tt> method and the constructor
	    itself. The <tt class="verb">atomsize()</tt> method returns the
	    total length, in bytes, of the element base atom.
	  </p>
	  <p>A description of the different constructors with their
	    parameters follows:
	  </p>

	  <dl>
	    <dt>Atom(dtype="Float64", shape=1, flavor="NumArray")
	    </dt>
	    <dd>Define properties for the base elements of
	      <tt class="verb">EArray</tt> and <tt class="verb">VLArray</tt> objects.
	      <dl>
		<dt>dtype</dt> <dd>The data type for the base
		  element. See the <a href="usersguide7.html#datatypesSupported">appendix&nbsp;A</a> for a
		  relation of data types supported. The type
		  description is accepted both in string format and as
		  numarray data type.
		</dd>

		<dt>shape</dt> <dd>In a <tt class="verb">EArray</tt>
		  context, it is a <b>tuple</b>
		  specifing the shape of the object, and one (and only
		  one) of its dimensions <b>must</b> be 0, meaning that the
		  <tt class="verb">EArray</tt> object will be enlarged along
		  this axis. In the case of a <tt class="verb">VLArray</tt>, it
		  can be an integer with a value of 1 (one) or a
		  tuple, that specifies whether the atom is an scalar
		  (in the case of a 1) or has multiple dimensions (in
		  the case of a tuple). For 
		  <tt class="verb">CharType</tt> elements, the last dimension
		  is used as the length of the character
		  strings. However, for this kind of objects, the use
		  of <tt class="verb">StringAtom</tt> subclass is strongly
		  recommended.
		</dd>

		<dt>flavor</dt>
		  <dd>The object representation for this atom. It
		  can be any of <em>"CharArray"</em> or
		  <em>"String"</em> for the <tt class="verb">CharType</tt> type
		  and <em>"NumArray"</em>, <em>"Numeric"</em>,
		  <em>"List"</em> or <em>"Tuple"</em> for the rest of
		  the types. If the specified values differs from
		  <em>CharArray</em> or <em>NumArray</em> values, the
		  read atoms will be converted to that specific
		  flavor. If not specified, the atoms will remain in
		  their native format (i.e. <tt class="verb">CharArray</tt> or
		  <tt class="verb">NumArray</tt>).
		</dd>
	      </dl>

	    </dd> 

	    <dt>StringAtom(shape=1, length=None,
	      flavor="CharArray")</dt> <dd>Define an atom to be of
	      <tt class="verb">CharType</tt> type. The meaning of the
	      <em>shape</em> parameter is the same as in the
	      <tt class="verb">Atom</tt> class. <em>length</em> sets the length
	      of the strings atoms. <em>flavor</em> can be whether
	      <tt class="verb">"CharArray"</tt> or
	      <tt class="verb">"String"</tt>. Unicode strings are not supported
	      by this type; see the <tt class="verb">VLStringAtom</tt> class if
	      you want Unicode support (only available for
	      <tt class="verb">VLAtom</tt> objects).
	    </dd>

	    <dt>BoolAtom(shape=1, flavor="NumArray") </dt>
	      <dd>Define an atom to be of type <tt class="verb">Bool</tt>.
	      The meaning of the parameters are the same of those in
	      the <tt class="verb">Atom</tt> class.
	    </dd>

	    <dt>IntAtom(shape=1, itemsize=4, sign=1,
	      flavor="NumArray") </dt> <dd>Define an atom to be of
	      type <tt class="verb">IntXX</tt>, depending on the value of
	      <em>itemsize</em> parameter, that sets the number of
	      bytes of the integers that conform the
	      atom. <em>sign</em> determines whether the integers are
	      signed or not. The meaning of the other parameters are
	      the same of those in the <tt class="verb">Atom</tt> class.

	      <p class="first">This class has several descendants:
	      </p>

	      <dl>
		<dt>Int8Atom(shape=1, flavor="NumArray")</dt>
		<dd>Define an atom of type <tt class="verb">Int8</tt>.</dd>

		<dt>UInt8Atom(shape=1, flavor="NumArray")</dt>
		<dd>Define an atom of type <tt class="verb">UInt8</tt>.</dd>

		<dt>Int16Atom(shape=1, flavor="NumArray")</dt>
		<dd>Define an atom of type <tt class="verb">Int16</tt>.</dd>

		<dt>UInt16Atom(shape=1, flavor="NumArray")</dt>
		<dd>Define an atom of type <tt class="verb">UInt16</tt>.</dd>

		<dt>Int32Atom(shape=1, flavor="NumArray")</dt>
		<dd>Define an atom of type <tt class="verb">Int32</tt>.</dd>

		<dt>UInt32Atom(shape=1, flavor="NumArray")</dt>
		<dd>Define an atom of type <tt class="verb">UInt32</tt>.</dd>

		<dt>Int64Atom(shape=1, flavor="NumArray")</dt>
		<dd>Define an atom of type <tt class="verb">Int64</tt>.</dd>

		<dt>UInt64Atom(shape=1, flavor="NumArray")</dt>
		<dd>Define an atom of type <tt class="verb">UInt64</tt>.</dd>

	      </dl>

	    </dd>

	    <dt>FloatAtom(shape=1, itemsize=8, flavor="NumArray")
	    </dt>
	    <dd>Define an atom to be of <tt class="verb">FloatXX</tt>
	      type, depending on the value of <tt class="verb">itemsize</tt>. The
	      <tt class="verb">itemsize</tt> parameter sets the number of bytes
	      of the floats in the atom and the default is 8 bytes
	      (double precision). The meaning of the other parameters
	      are the same as those in the <tt class="verb">Atom</tt> class.

	      <p class="first">This class has two descendants:
	      </p>

	      <dl>
		<dt>Float32Atom(shape=1, flavor="NumArray")</dt>
		<dd>Define an atom of type <tt class="verb">Float32</tt>.</dd>

		<dt>Float64Atom(shape=1, flavor="NumArray")</dt>
		<dd>Define an atom of type <tt class="verb">Float64</tt>.</dd>

	      </dl>
	    </dd>

	    <dt>ComplexAtom(shape=1, itemsize=16, flavor="NumArray")
	    </dt>
	    <dd>Define an atom to be of <tt class="verb">ComplexXX</tt> type,
	      depending on the value of <tt class="verb">itemsize</tt>. The
	      <tt class="verb">itemsize</tt> parameter sets the number of bytes
	      of the floats in the atom and the default is 16 bytes
	      (double precision complex). The meaning of the other
	      parameters are the same as those in the
	      <tt class="verb">Atom</tt> class.

	      <p class="first">This class has two descendants:
	      </p>

	      <dl>
		<dt>Complex32Atom(shape=1, flavor="NumArray")</dt>
		<dd>Define an atom of type <tt class="verb">Complex32</tt>.</dd>

		<dt>Complex64Atom(shape=1, flavor="NumArray")</dt>
		<dd>Define an atom of type <tt class="verb">Complex64</tt>.</dd>

	      </dl>
	    </dd>
	  </dl>

	  <p>Now, there come two special classes,
	    <tt class="verb">ObjectAtom</tt> and <tt class="verb">VLString</tt>, that
	    actually do not descend from <tt class="verb">Atom</tt>, but which
	    goal is so similar that they should be described here. The
	    difference between them and the <tt class="verb">Atom</tt> and
	    descendents classes is that these special classes does not
	    allow multidimensional atoms, nor multiple values per
	    row. A <em>flavor</em> can't be specified neither as it is
	    immutable (see below).
	  </p>
	  <p><b>Caveat emptor:</b> You are only
	    allowed to use these classes to create
	    <tt class="verb">VLArray</tt> objects, not <tt class="verb">EArray</tt>
	    objects.
	  </p>

	  <dl>
	    <dt>ObjectAtom()</dt> <dd>This class is meant to fit
	      <em>any</em> kind of object in a row of an
	      <tt class="verb">VLArray</tt> instance by using
	      <tt class="verb">cPickle</tt> behind the scenes. Due to the fact
	      that you cannot foresee how long will be the output of
	      the <tt class="verb">cPickle</tt> serialization (i.e. the atom
	      already has a <em>variable</em> length), you can only
	      fit a representant of it per row. However, you can still
	      pass several parameters to the
	      <tt class="verb">VLArray.append()</tt> method as they will be
	      regarded as a <em>tuple</em> of compound objects (the
	      parameters), so that we still have only one object to be
	      saved in a single row. It does not accept parameters and
	      its flavor is automatically set to
	      <tt class="verb">"Object"</tt>, so the reads of rows always
	      returns an arbitrary python object.
	      
	      You can regard <tt class="verb">ObjectAtom</tt> types as an easy
	      way to save an arbitrary number of generic python
	      objects in a <tt class="verb">VLArray</tt> object.
	    </dd>

	    <dt>VLStringAtom()</dt> <dd>This class describes a
	      <em>row</em> of the <tt class="verb">VLArray</tt> class, rather
	      than an <em>atom</em>. It differs from the
	      <tt class="verb">StringAtom</tt> class in that you can only add
	      one instance of it to one specific row, i.e. the
	      <tt class="verb">VLArray.append()</tt> method only accepts one
	      object when the base atom is of this type. Besides, it
	      supports Unicode strings (contrarily to
	      <tt class="verb">StringAtom</tt>) because it uses the UTF-8
	      codification (this is why its <tt class="verb">atomsize()</tt>
	      method returns always 1) when serializing to disk. It
	      does not accept any parameter and because its
	      <em>flavor</em> is automatically set to
	      <tt class="verb">"VLString"</tt>, the reads of rows always
	      returns a python string. See the <a href="usersguide9.html#VLArrayFormatDescr">appendix&nbsp;C.3.4</a> if you are
	      curious on how this is implemented at the low-level.

	      You can regard <tt class="verb">VLStringAtom</tt> types as an
	      easy way to save generic variable length strings.
	    </dd>
	  </dl>

	  <p>See <tt class="verb">examples/vlarray1.py</tt> and
	    <tt class="verb">examples/vlarray2.py</tt> for further examples on
	    <tt class="verb">VLArray</tt>s, including object serialization and
	    Unicode string management.
	  </p>

	</div> 
      </div> 

      <div id="helperClasses"><a name="helperClasses"></a>
	<h2 id="section4.13"><span class="headlinenumber"><a name="section4.13"></a>4.13 </span>Helper classes</h2>

	<p class="first">In this section are listed classes that does not fit in any
	  other section and that mainly serves for ancillary
	  purposes.</p>

	<div id="FiltersClassDescr"><a name="FiltersClassDescr"></a>
	  <h3 id="subsection4.13.1"><span class="headlinenumber"><a name="subsection4.13.1"></a>4.13.1 </span>The <tt>Filters</tt> class
	  </h3>

	  <p class="first">This class is meant to serve as a container that keeps
	    information about the filter properties associated with
	    the enlargeable leaves, that is <tt class="verb">Table</tt>,
	    <tt class="verb">EArray</tt> and <tt class="verb">VLArray</tt>.
	  </p>

	  <p>The public variables of <tt class="verb">Filters</tt> are listed
	    below:
	  </p>

	  <dl>
	    <dt>complevel</dt> <dd>The compression level (0
	      means no compression).
	    </dd>
	    <dt>complib</dt> <dd>The compression filter used (in
	      case of compressed dataset).
	    </dd>
	    <dt>shuffle</dt> <dd>Whether the shuffle filter is
	      active or not.
	    </dd>
	    <dt>fletcher32</dt> <dd>Whether the fletcher32
	      filter is active or not.
	    </dd>
	  </dl>

	  <p>There are no <tt class="verb">Filters</tt> public methods with the
	    exception of the constructor itself that is described
	    next.
	  </p>

	  <div id="FiltersInitDescr"><a name="FiltersInitDescr"></a>
	    <h4 id="subsubsection4.13.1.1"><tt>Filters(complevel=0,
		complib="zlib", shuffle=1, fletcher32=0)</tt>
	    </h4>

	    <p class="first">The parameters that can be passed to the
	      <tt class="verb">Filters</tt> class constructor are:
	    </p>

	    <dl>
	      <dt>complevel</dt> <dd>Specifies a compress level
		for data. The allowed range is 0-9. A value of 0
		disables compression. The default is that compression
		is disabled, that balances between compression effort
		and CPU consumption.
	      </dd>
	      <dt>complib</dt> <dd> Specifies the compression
		library to be used. Right now, <tt class="verb">"zlib"</tt>
		(default), <tt class="verb">"lzo"</tt> and <tt class="verb">"ucl"</tt>
		values are supported. See <a href="usersguide6.html#compressionIssues">section&nbsp;6.3</a> for some advice
		on which library is better suited to your needs.
	      </dd>
	      <dt>shuffle</dt><dd>Whether or not to use the
		<em>shuffle</em> filter present in the
		<tt class="verb">HDF5</tt> library. This is normally used to
		improve the compression ratio (at the cost of
		consuming a little bit more CPU time). A value of 0
		disables shuffling and 1 makes it active. The default
		value depends on whether compression is enabled or
		not; if compression is enabled, shuffling defaults to
		be active, else shuffling is disabled.
	      </dd>
	      <dt>fletcher32</dt> <dd>Whether or not to use the
		<em>fletcher32</em> filter in the HDF5 library. This
		is used to add a checksum on each data chunk. A value
		of 0 disables the checksum and it is the default.
	      </dd>
	    </dl>
	    
	    <div class="p">Of course, you can also create an instance and then
	      assign the ones you want to change. For example:
	      <pre>
import numarray as na
from tables import *

fileh = openFile("test5.h5", mode = "w")
atom = Float32Atom(shape=(0,2))
filters = Filters(complevel=1, complib = "lzo")
filters.fletcher32 = 1
arr = fileh.createEArray(fileh.root, 'earray', atom, "A growable array",
                         filters = filters)
# Append several rows in only one call
arr.append(na.array([[1., 2.],
                     [2., 3.],
                     [3., 4.]], type=na.Float32))

# Print information on that enlargeable array
print "Result Array:"
print repr(arr)

fileh.close()
	      </pre>
	      This enforces the use of the <tt class="verb">LZO</tt> library, a
	      compression level of 1 and a fletcher32 checksum filter
	      as well. See the output of this example:
	      <pre>
Result Array:
/earray (EArray(3L, 2), fletcher32, shuffle, lzo(1)) 'A growable array'
  type = Float32
  shape = (3L, 2)
  itemsize = 4
  nrows = 3
  extdim = 0
  flavor = 'NumArray'
  byteorder = 'little'
	      </pre>
	    </div>
	  </div> 
	</div> 

	<div id="IndexPropsClassDescr"><a name="IndexPropsClassDescr"></a>
	  <h3 id="subsection4.13.2"><span class="headlinenumber"><a name="subsection4.13.2"></a>4.13.2 </span>The <tt>IndexProps</tt> class
	  </h3>

	  <p class="first">You can use this class to set/unset the properties in the
	    indexing process of a <tt class="verb">Table</tt> column. To use
	    it, create an instance, and assign it to the special
	    attribute <tt class="verb">_v_indexprops</tt> in a table <a href="#IsDescriptionClassDescr">description&nbsp;4.12.1</a> class or
	    dictionary.
	  </p>

	  <p>The public variables of <tt class="verb">IndexProps</tt> are listed
	    below:
	  </p>

	  <dl>
	    <dt>auto</dt> <dd>Whether an existing index should
	      be updated or not after a table append operation.
	    </dd>
	    <dt>reindex</dt> <dd>Whether the table columns are
	      to be re-indexed after an invalidating index operation.
	    </dd>
	    <dt>filters</dt> <dd>The filter settings for the
	      different <tt class="verb">Table</tt> indexes.
	    </dd>
	  </dl>

	  <p>There are no <tt class="verb">IndexProps</tt> public methods with
	    the exception of the constructor itself that is described
	    next.
	  </p>

	  <div id="IndexPropsInitDescr"><a name="IndexPropsInitDescr"></a>
	    <h4 id="subsubsection4.13.2.1"><tt>IndexProps(auto=1, reindex=1,
		filters=None)</tt>
	    </h4>

	    <p class="first">The parameters that can be passed to the
	      <tt class="verb">IndexProps</tt> class constructor are:
	    </p>

	    <dl>
	      <dt>auto</dt> <dd>Specifies whether an existing
	      index should be updated or not after a table append
	      operation. The default is enable automatic index
	      updates.
	      </dd>
	      <dt>reindex</dt> <dd>Specifies whether the table
		columns are to be re-indexed after an invalidating
		index operation (like for example, after a
		<tt class="verb">Table.removeRows</tt> call). The default is to
		reindex after operations that invalidate indexes.
	      </dd>
	      <dt>filters</dt><dd>Sets the filter properties for
		<tt class="verb">Column</tt> indexes. It has to be an instance
		of the <tt class="verb">Filters</tt> (see <a href="#FiltersClassDescr">section&nbsp;4.13.1</a>) class. A
		<tt class="verb">None</tt> value means that the default
		settings for the <tt class="verb">Filters</tt> object are
		selected.
	      </dd>
	    </dl>

	  </div>
	</div> 

	<div id="IndexClassDescr"><a name="IndexClassDescr"></a>
	  <h3 id="subsection4.13.3"><span class="headlinenumber"><a name="subsection4.13.3"></a>4.13.3 </span>The <tt>Index</tt> class</h3>

	  <p class="first">This class is used to keep the indexing information for
	    table columns. It is actually a descendant of the
	    <tt class="verb">Group</tt> class, with some added
	    functionality.
	  </p>
	  <p>It has no methods intented for programmer's use, but it
	    has some attributes that maybe interesting for him.
	  </p>

	  <div id="IndexClassInstanceVariables"><a name="IndexClassInstanceVariables"></a>
	    <h4 id="subsubsection4.13.3.1"><tt>Index</tt> instance
	      variables</h4>
	    <dl>

	      <dt>column</dt> <dd>The column object this index
		belongs to.
	      </dd>
	      
	      <dt>type</dt> <dd>The type class for the
		index.
	      </dd>

	      <dt>itemsize</dt> <dd>The size of the atomic
		items. Specially useful for columns of
		<tt class="verb">CharType</tt> type.
	      </dd>

	      <dt>nelements</dt> <dd>The total number of
		elements in index.
	      </dd>

	      <dt>dirty</dt> <dd>Whether the index is dirty or
		not.
	      </dd>

	      <dt>sorted</dt> <dd>The <tt class="verb">IndexArray</tt>
		object (see <a href="#IndexArrayClassDescr">4.13.4</a>)
		with the sorted values information.
	      </dd>

	      <dt>indices</dt> <dd>The <tt class="verb">IndexArray</tt>
		object (see <a href="#IndexArrayClassDescr">4.13.4</a>)
		with the sorted indices information.
	      </dd>

	      <dt>filters</dt> <dd>The <tt class="verb">Filters</tt> (see
		<a href="#FiltersClassDescr">section&nbsp;4.13.1</a>) instance
		for this index.
	      </dd>

	    </dl>

	  </div> 
	</div> 

	<div id="IndexArrayClassDescr"><a name="IndexArrayClassDescr"></a>
	  <h3 id="subsection4.13.4"><span class="headlinenumber"><a name="subsection4.13.4"></a>4.13.4 </span>The <tt>IndexArray</tt>
	    class</h3>

	  <p class="first">This class is used to keep part of the indexing
	    information for table columns. It is actually a descendant
	    of the <tt class="verb">EArray</tt> class, with some added
	    functionality. 
	  </p>

	  <p>It has no methods intented for programmer's use, and
	    although it has some attributes with potentially useful
	    information, all of it is accessible through
	    <tt class="verb">Index</tt> class (see <a href="#IndexClassDescr">4.13.3</a>), so it will not be
	    replicated here.
	  </p>

	</div> 

      </div> 
    </div><hr class="footnoterule"><div class="footnote"><a id="footnote6" href="#footnoteback6"><sup>6)</sup></a>&nbsp;On the following, the term <tt class="verb">Leaf</tt>
	  will refer to either a <tt class="verb">Table</tt>,
	  <tt class="verb">Array</tt>, <tt class="verb">EArray</tt>,
	  <tt class="verb">VLArray</tt> or <tt class="verb">UnImplemented</tt> node
	  object.</div><div class="footnote"><a id="footnote7" href="#footnoteback7"><sup>7)</sup></a>&nbsp;In the future,
	  multiple enlargeable dimensions might be implemented as
	  well.</div></div><div class="speedbar-bottom"><hr class="speedbar"><table class="speedbar"><tbody><tr><td style="text-align: left; width: 15%"><a href="usersguide3.html">previous</a></td><td style="text-align: center"><a href="usersguide.html#tb:table-of-contents">Table of Contents</a></td><td style="text-align: right; width: 15%"><a href="usersguide5.html">next</a></td></tr></tbody></table></div></body></html>