
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:bib="http://bibtexml.org/STSCHEMA" xmlns:adr="http://tbookdtd.sourceforge.net/addressbook" xmlns:ref="http://tbookdtd.sourceforge.net/references" xmlns:index="http://tbookdtd.sourceforge.net/index" xmlns:dimensions="http://tbookdtd.sourceforge.net/dimension-file" xmlns:depths="http://tbookdtd.sourceforge.net/depths-file" xmlns:loc="local" xmlns:CSS="http://www.w3.org/1998/Style/CSS2" lang="en"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>PyTables User's Guide</title><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="generator" content="The tbook system at http://tbookdtd.sourceforge.net"><meta name="robots" content="index"><meta name="DC.Title" content="PyTables User's Guide"><meta name="DC.Description" content="PyTables User's Guide"><meta name="DC.Creator" content="Francesc Alted"><meta name="Author" content="Francesc Alted"><meta name="DC.Date" content="2002-10-09T14:20:09Z"><meta name="Date" content="2002-10-09T14:20:09Z"><meta name="DC.Rights" content="(c) 2002 Francesc Alted"><meta name="Copyright" content="(c) 2002 Francesc Alted"><meta name="DC.Type" content="Text"><meta name="DC.Format" content="text/html"><meta name="DC.Language" scheme="rfc3066" content="en"><meta name="Language" content="en"><meta http-equiv="Content-Style-Type" content="text/css"><style type="text/css">
    body {
      font-family: serif; text-align: justify;
      margin: 0pt; line-height: 1.3; background-color: white; color: black }
    body.letter { background-image: none }
    h1, h2, h3, h4, h5, h6, div.partheadline, div.title,
      div.title-article {
      font-family: sans-serif; font-weight: bold; font-stretch: condensed;
      text-align: left; }
    h1, h2, h3, h4, h5, h6, div.partheadline { padding-left: 18pt }
    h1 { clear: both }
    h1.toc { clear: none }
    div.document, div.letter { margin-left: 80px; margin-right: 150px;
      padding-top: 3ex; padding-bottom: 5ex }
    div.authorlist { font-family: sans-serif;
      font-stretch: condensed; text-align: left; font-size: x-large;
      margin-bottom: 1ex }
    div.authorlist-article { font-size: x-large; text-align: center;
      margin-bottom: 2ex }
    div.title { font-size: xx-large; color: gray; margin-bottom: 5ex; }
    div.title-article { font-size: xx-large; text-align: center;
      margin-bottom: 2ex }
    div.date-article { font-size: large; text-align: center;
      margin-bottom: 5ex }
    div.subtitle { text-align: left; margin-bottom: 3ex }
    div.legal { text-align: right }
    div.partheadline { font-size: xx-large; margin-top: 1ex; margin-bottom: 1ex }
    div.footnote { }
    div.mathdisplay { text-align: center;
    margin-top: 2ex; margin-bottom: 2ex }
    div.figure, div.table, div.mathml-remark { margin-bottom: 3ex;
            margin-top: 2ex}
    div.mathml-remark { width: 50%; text-align: left; text-indent: 0pt }
    div.caption { margin-top: 1ex; width: 20em}
    div.caption-text { font-size: small;
      padding-left: 1em; text-indent: -1em; text-align: justify}
    caption { max-width: 100%; min-width: 200px; margin-bottom: 1ex;
      text-align: justify }
    div.verse { white-space: pre }
    div.toc { margin-bottom: 6ex }
    div.biblio, div.index { }
    div.aphorism { margin-bottom: 2ex; font-style: italic; text-align: right;
      margin-left: 50%}
    div.aphorism-origin { margin-top: 1ex }
    div.letter { }
    div.subject { margin-top: 3ex; margin-bottom: 3ex }
    div.opening { margin-top: 3ex; margin-bottom: 3ex }
    div.closing { margin-top: 3ex; text-align: right }
    div.to { margin-top: 3ex; margin-bottom: 3ex }
    span.subject { font-weight: bold }
    div.speedbar-top, div.speedbar-bottom { margin-left: 1em; margin-right: 1em }
    div.speedbar-top { margin-top: 2ex }
    div.speedbar-bottom { margin-bottom: 3ex }
    table.speedbar { width: 100% }
    hr.speedbar { clear: both }
    div.theorem-plain, div.theorem-definition, div.theorem-remark { margin-top: 2ex;
      margin-bottom: 2ex }
    div.theorem-plain { font-style: italic }
    div.proof { margin-top: 2ex; margin-bottom: 2ex }
    span.theorem-head-plain, span.theorem-head-definition, span.theorem-head-remark
      { margin-right: 0.66em }
    span.theorem-head-plain, span.theorem-head-definition
      { font-style: normal; font-weight: bold }
    span.theorem-head-remark { font-style: italic }
    span.proof-head { font-style: italic; margin-right: 0.66em }
    acronym { font-size: 95%; letter-spacing: 0.1em; text-transform: uppercase }
    td.header { text-align: center; font-weight: bold }
    table.toc { }
    table.tabular { font-size: smaller }
    td.thickline { height: 0pt; border-bottom: medium solid; padding: 2px }
    td.thinline { height: 0pt; border-bottom: thin solid;   padding: 2px }
     /* FixMe: Following definition Still bad */
    div.part-toc { margin-top: 2ex; font-weight: bold; font-size: larger }
     /* FixMe: Following definition: How cleaner? */
    div.toplevel-toc { margin-top: 1ex; font-weight: bold }
    td.number1 { width: 1.5em }
    td.number2 { width: 2em }
    td.number3 { width: 3em }
    td.author { text-align: center }
    div { }  /* Must remain empty! */
    span.captionlabel { font-family: sans-serif; font-weight: bold;
      margin-right: 0.66em }
    span.captionlabel:after { content: " " }
    b.captionlabel {  }
    b.captionlabel:after { content: " " }
    span.headlinenumber { margin-right: 0.66em }
    tt.verb {font-family: monospace }
    span.bibtag { font-weight: bold; margin-right: 1em }
    span.bib-author { }
    span.bib-lastname { font-variant: small-caps }
    span.bib-title { font-style: italic }
    span.bib-booktitle { }
    span.bib-journal { }
    span.bib-journal-volume { font-weight: bold }
    span.bib-publisher { }
    span.bib-school { }
    span.bib-year { }
    span.bib-note { }
    span { } /* Muss leer bleiben! */
    li.bibitem { margin-left: 1em; text-indent: -1em }
    img.graphics { border: 0pt }
    p,div.p { margin: 0pt; text-indent: 18pt }
    ul, dl, ol { text-indent: 0pt; }
    p.first, div.p-first { margin: 0pt; text-indent: 0pt }
    p.bibitem { margin-top: 1.5ex; margin-left: 3em; text-indent: -3em }
    ul.biblio { list-style: none }
    mi.ch { font-style: normal }
    math[display="block"], div.equation {
      margin-top: 1ex; margin-bottom: 1ex }
    div.i-lettergroup { font-size: larger; font-weight: bold; padding-left: 18pt;
      margin-top: 3ex; margin-bottom: 1.5ex }
    div.i-item { }
    div.i-main { }
    dt { display: compact; font-weight: bold }
    dd { text-indent: 0pt }
    pre { text-indent: 0pt }
    span.i-see { font-style: italic; }
</style></head><body bgcolor="#FFFFFF"><div class="document">
  <div class="header"><div class="authorlist"><span>Francesc&nbsp;Alted</span></div><p></p><font size="7" face="Sans-Serif"><b><div class="title"><tt>PyTables</tt> User's Guide</div></b></font><p></p><div class="legal">All rights reserved.<br>&copy;&nbsp;2002 Francesc&nbsp;Alted<br></div></div><hr><div class="toc" id="tb:table-of-contents"><h1 class="toc">Table of Contents</h1><table class="toc" cellspacing="0pt" cellpadding="0pt"><tr><td class="number1"><div class="toplevel-toc">1</div></td><td colspan="3"><b><div class="toplevel-toc"><a href="#chapter1">Introduction</a></div></b></td></tr><tr><td>&nbsp;</td><td class="number2">1.1</td><td colspan="2"><a href="#section1.1">Features</a></td></tr><tr><td>&nbsp;</td><td class="number2">1.2</td><td colspan="2"><a href="#section1.2">The object tree</a></td></tr><tr><td>&nbsp;</td></tr><tr><td class="number1"><div class="toplevel-toc">2</div></td><td colspan="3"><b><div class="toplevel-toc"><a href="#chapter2">Installation</a></div></b></td></tr><tr><td>&nbsp;</td></tr><tr><td class="number1"><div class="toplevel-toc">3</div></td><td colspan="3"><b><div class="toplevel-toc"><a href="#chapter3">Usage</a></div></b></td></tr><tr><td>&nbsp;</td><td class="number2">3.1</td><td colspan="2"><a href="#section3.1">A first example</a></td></tr><tr><td>&nbsp;</td><td class="number2">3.2</td><td colspan="2"><a href="#section3.2">A somewhat more complex exercise</a></td></tr><tr><td>&nbsp;</td></tr><tr><td class="number1"><div class="toplevel-toc">4</div></td><td colspan="3"><b><div class="toplevel-toc"><a href="#chapter4">Library Reference</a></div></b></td></tr><tr><td>&nbsp;</td><td class="number2">4.1</td><td colspan="2"><a href="#section4.1">The <em>File</em> class.</a></td></tr><tr><td>&nbsp;</td><td class="number2">4.2</td><td colspan="2"><a href="#section4.2">The <em>IsRecord</em> class.</a></td></tr><tr><td>&nbsp;</td></tr><tr><td class="number1"><div class="toplevel-toc">A</div></td><td colspan="3"><b><div class="toplevel-toc"><a href="#chapterA"><tt>PyTables</tt> Supported Data Types</a></div></b></td></tr></table></div>
  

  <div>
      <h1 id="chapter1"><a name="chapter1"></a>Chapter&nbsp;1: Introduction</h1>

      <p class="first"><tt>PyTables</tt> is a Python package
	that allows dealing with HDF5 (see <a href="#HDF5WhatIs">reference&nbsp;<strong>??</strong></a>) tables. In this document,
	the term <em>table</em> means exactly the same than in HDF5
	sense (see <a href="#HDF5_HL">reference&nbsp;<strong>??</strong></a>):
      </p>
      <blockquote>
	"A table is defined as a collection of records whose values
	are stored in fixed-length fields. All records have the same
	structure and all values in each field have the same data
	type."
      </blockquote>
      <p>Records in tables are also known, in the HDF5 naming scheme,
	as <em>compound</em> data types.
      </p>
      <p>So, you can define arbitrary records in Python, like for
	example:
      </p>
<pre>
class Particle(IsRecord):
    name        = '16s'  # 16-character String
    lati        = 'i'    # integer
    longi       = 'i'    # integer
    pressure    = 'f'    # float  (single-precision)
    temperature = 'd'    # double (double-precision)

</pre>
      <p>fill it with your values, and save (large) collections of
      them in a file. Then, this data can be retrieved and
      post-processed quite easily with <tt>PyTables</tt> or another HDF5 application.</p>

      <p>You probably noted that the terms "fixed-length" and strict
	"data types" present in the table definition seems to be
	strange concepts for an interpreted language like Python, but
	supporting them is fundamental when we want to save *lots* of
	data (mainly for scientific applications, but not only that),
	if we want to do that in a efficient (both in terms of CPU and
	I/O requirements) way. <tt>PyTables</tt>
	allows that.
      </p>

      <div>
	<h2><span class="headlinenumber" id="section1.1"><a name="section1.1"></a>1.1 </span>Features</h2>
	<p class="first"><tt>PyTables</tt> has the next features:</p>

	<ul>
	  <li><em>Support of HDF5 table entities:</em> Allows working
	    with large number of records that don't fit in memory.
	  </li>
	  <li><em>Supports a hierarchical data model:</em> So, you
	    can structure very clearly all your data. This is also
	    very important when dealing with XML data. Pytables builds
	    up an object tree in memory that replicates the HDF5
	    structure. That way, the access to the HDF5 objects is
	    made by walking throughout the <tt>PyTables</tt> object tree, and
	    manipulating them.
	  </li>
	  <li><em>Incremental I/O:</em> It supports adding records
	    to already created tables. So you won't need to book large
	    amounts of memory to fill the entire table and then save
	    it to disk but you can do that incrementally, even between
	    different Python sessions.
	  </li>
	  <li><em>Allows field name, data type and range
	    checking:</em> So you can be confident that if <tt>PyTables</tt> doesn't report an error, you
	    can be confident that your data is probably ok.
	  </li>
	  <li><em>Support of files bigger than 2 GB:</em> This is
	    because HDF5 already can do that (if your platform supports
	    the C long long integer,  or, on Windows, __int64).
	  </li>
	  <li><em>Data compression:</em> It supports data
	    compression (trough the use of the zlib library) out of
	    the box. This become important when you have repetitive
	    data patterns and don't have time for searching an
	    optimized way to save them.
	  </li>
	  <li><em>Big-Endian/Low-Endian safety:</em> <tt>PyTables</tt> has been coded (as HDF5 is)
	    to care with little-endian/big-endian byte orderings. So,
	    in principle, you can write a file in a big-endian machine
	    and read it in other little-endian without
	    problems<a href="#footnote1" name="footnoteback1"><sup>1)</sup></a>.</li>
	</ul>

	<p>It's important to stress that <tt>PyTables</tt> doesn't support every
	  functionality present on HDF5, so you would be able to
	  create HDF5 files with <tt>PyTables</tt>, and read them with other HDF5
	  generic tools (like <tt>h5dump</tt>),
	  but you can't hope <tt>PyTables</tt> can
	  read every HDF5 file created with tools different than
	  <tt>PyTables</tt>, as it supports only
	  table objects. However, I'm pondering to extend the support
	  to other objects too, like NumArray (see <a href="#Numarray">reference&nbsp;<strong>??</strong></a>) entities.
	</p>
	<p>In the same sense, it should noted that <tt>PyTables</tt> do not pretends to be merely a
	  wrapper of HDF5_HL library (don't confuse with HL-HDF5, the
	  Swedish Meteorological and Hydrological Institute effort to
	  provide another high Level interface to HDF5; see <a href="#HL-HDF">reference&nbsp;<strong>??</strong></a>), but to provide a flexible
	  tool to deal with HDF5 files. This is achieved by taking
	  advantage of the powerful object orientation and
	  introspection capabilities offered by Python.
	</p>
      </div>

      <div>
	<h2><span class="headlinenumber" id="section1.2"><a name="section1.2"></a>1.2 </span>The object tree</h2>

	<p class="first"><tt>PyTables</tt> take advantage of the
	  HDF5 hierarchical model to allow tables to be managed in a
	  tree-like structure. It achieves that by creating an object
	  tree imitating the HDF5 structure on disk. That way, the
	  access to the HDF5 objects is made by walking throughout the
	  <tt>PyTables</tt> object tree, and
	  manipulating them. I've got this powerful idea from the
	  excellent <tt>Objectify</tt> module by
	  David Mertz (see references <a href="#Objectify"><strong>??</strong></a>
	  and <a href="#GnosisUtils"><strong>??</strong></a>).
	</p>
	<p> You should note that not all the data present on the HDF5
	  file is loaded in <tt>PyTables</tt>
	  tree, but only the <em>metadata</em> (i.e. data that
	  actually describes the structure of the real data). The
	  actual access to the real data is provided through the
	  methods of those objects.
	</p>
	<p>For example, imagine we have made a script (in fact, this
	  script exists; its name is <tt class="verb">objecttree.py</tt> and
	  you can find it in the <tt class="verb">examples/</tt> directory)
	  that has created a simple HDF5 file, with the structure that
	  appears in <a href="#objecttree-h5">figure&nbsp;1.1</a> (we have
	  used the java program <tt class="verb">hdfview</tt> to obtain this
	  image). If you re-open again this file (in read only mode,
	  for example), the object tree with the HDF5 metadata will be
	  constructed from this hierarchy.
	</p>

	<div class="figure" id="objecttree-h5"><a name="objecttree-h5"></a>
	  <a target="_blank" href="objecttree-h5.jpg"><img class="graphics" alt="An HDF5 example with 2 subgroups and 3 tabl... (Click for original bitmap)" src="objecttree-h5-web.jpg"></a>
	  <div class="caption" style="width: 200px"><div class="caption-text"><span class="captionlabel">Figure&nbsp;1.1:</span> An HDF5 example with 2 subgroups and 3 tables.</div></div>
	</div>

	<p>In <a href="#objecttree">figure&nbsp;1.2</a> you can see an
	  example of the object tree created by reading an HDF5 file
	  (previously written with <tt>PyTables</tt>). It's important that you get
	  familiar with this diagram to better understand how to work
	  with <tt>PyTables</tt>. If you are going
	  to be a <tt>PyTables</tt> user, take
	  your time to study and understand it (bear in mind, however,
	  that this diagram is not a standard UML class diagram; I've
	  used a UML tool to draw it, that's all).
	</p>

	<div class="figure" id="objecttree"><a name="objecttree"></a>
	  
	  <img class="graphics" alt="An object tree example in PyTables.&#xA;	  " src="objecttree-web.png">
	  <div class="caption" style="width: 200px"><div class="caption-text"><span class="captionlabel">Figure&nbsp;1.2:</span> An object tree example in <tt>PyTables</tt>.
	  </div></div>
	</div>
      
	<p>It's important to bear all this in mind while you are
	  working with <tt>PyTables</tt>, because
	  it will easy your work and will make you more proactive by
	  avoiding programming mistakes.
	</p>

      </div>

    </div><div>
      <h1 id="chapter2"><a name="chapter2"></a>Chapter&nbsp;2: Installation</h1>

      <p class="first">This are instructions for Unix/Linux system. If you are using
	Windows, and get the library working, please, tell me about.
      </p>

      <p>Extensions in <tt>PyTables</tt> has been
	made using Pyrex (see <a href="#Pyrex">reference&nbsp;<strong>??</strong></a>) and
	C. You can rebuild everything from scratch if you got Pyrex
	installed, but this is not necessary, as the Pyrex compiled
	source is included in the distribution. But if you want to do
	that, merely replace <tt>setup.py</tt>
	script in these instructions by <tt>setup-pyrex.py</tt>.
      </p>

      <p>The Python Distutils are used to build and install tables, so it is
	fairly simple to get things ready to go.
      </p>

    <ol>

      <li>
	<p class="first">First, make sure that you have <tt class="verb">hdf5 1.4.x</tt> and
	  <tt class="verb">hdf5_hl</tt> libraries installed (I'm using
	  <tt class="verb">hdf5 1.4.4</tt> and <tt class="verb">hdf5_hl beta2</tt>
	  currently). If not, you can find them at
	  <tt class="verb">http://hdf.ncsa.uiuc.edu/HDF5</tt>; compile/install
	  them.
	</p>
	<p><tt class="verb">setup.py</tt> will detect these libraries and
	  include files under either <tt class="verb">/usr</tt> or
	  <tt class="verb">/usr/local</tt>; this will catch installations from
	  RPMs and most hand installations under Unix.  If
	  <tt class="verb">setup.py</tt> can't find your <tt class="verb">libhdf5</tt>
	  and <tt class="verb">libhdf5_hl</tt> or if you have several versions
	  installed and wants to select one of them, then you can give
	  it a hint either in the environment (using the
	  <tt class="verb">HDF5_DIR</tt> environment variable) or on the command
	  line by specifying the directory containing the include and
	  lib directory.  For example:
	</p>
	<pre>
        --hdf5=/stuff/hdf5-1.4.4
	</pre>
	<p>The libraries can installed anywhere on the filesystem,
	  but remember to always place them together. For example, if
	  <tt class="verb">libhdf5.so</tt> is installed in
	  <tt class="verb">/usr/lib</tt>, so does <tt class="verb">hdf5_hl.so</tt>. The
	  same applies to the headers.
	</p>

	<p>If your <tt class="verb">HDF5</tt> libs were built as shared
	  libraries, and if these shared libraries are not on the
	  runtime load path, then you can specify the additional
	  linker flags needed to find the shared library on the
	  command line as well. For example:
	</p>
	<pre>
        --lflags="-Xlinker -rpath -Xlinker /stuff/hdf5-1.4.4/lib"
	</pre>
	<p>or perhaps just
	</p>
	<pre>
        --lflags="-R /stuff/hdf5-1.4.4/lib"
	</pre>

	<p>Check your compiler and linker documentation to be sure.
	</p>

	<p>It is also possible to specify linking against different
	  libraries with the --libs switch:
	</p>
	<pre>
        --libs="-lhdf5-1.4.6 -lhdf5_hl-beta2"
        --libs="-lhdf5-1.4.6 -lhdf5_hl-beta2 -lnsl"
	</pre>
      </li>
      <li>
	<p class="first">From the main pytables distribution directory run this
	  command, (plus any extra flags needed as discussed above):
	</p>
	<pre>
        python setup.py build_ext --inplace
	</pre>
	<p>depending on the compiler flags used when compiling your
	  Python executable, it may appear lots of warnings. Don't
	  worry, almost all of them are caused by variables declared
	  but never used. That's normal in Pyrex extensions.
	</p>
      </li>
      <li>
	<p class="first">To run the test suite change into the test directory and run this
	  command, (assuming your shell is bash or compatible):
	</p>
	<pre>
        export PYTHONPATH=..
        python test_all.py
	</pre>

	<p>If you would like to see some verbose output from the tests
	  simply add the word <tt class="verb">verbose</tt> to the command
	  line.  You can also run only the tests in a particular test
	  module by themselves.  For example:</p>
	<pre>
        python test_types.py
	</pre>
      </li>
      <li>
	<p class="first">To install the entire <tt>PyTables</tt> Python package, change back
	  to the root distribution directory and run this command as
	  the root user:
	</p>
        python setup.py install
      </li>
    </ol>

    <p>That's it!. Now, read on the next section to see some program
      examples.
    </p>

  </div><div>
      <h1 id="chapter3"><a name="chapter3"></a>Chapter&nbsp;3: Usage</h1>

      <div id="firstexample"><a name="firstexample"></a>
	<h2><span class="headlinenumber" id="section3.1"><a name="section3.1"></a>3.1 </span>A first example</h2> 

	<p class="first">Let's start by showing a simple example. For simplicity and
	  direct comparison, I'll choose the same that is exposed in
	  an HDF5_HL example (see <a href="#HDF5TableExamples">reference&nbsp;<strong>??</strong></a>).
	</p>
	<p>So, we want to create a table whose records are particle
	  properties. Each particle (record) has a name, a position
	  (specified by latitude and longitude), pressure and
	  temperature.
	</p>
	<p>We start by define this record in <tt>PyTables</tt> by declaring a subclass of
	  <tt class="verb">IsRecord</tt>. But first, the necessary imports:
	</p>
	<pre>
from tables import File, IsRecord

class Particle(IsRecord):
    name        = '16s'  # 16-character String
    lati        = 'i'    # integer
    longi       = 'i'    # integer
    pressure    = 'f'    # float  (single-precision)
    temperature = 'd'    # double (double-precision)
	</pre>
	<p>As you see, we define the Particle class as a subclass of
	  IsRecord (which is actually a <em>metaclass</em>, but this
	  is not important now). The name of each Particle attribute
	  will be the name of the record field and its value will
	  become its data type. '16s' typecode means a 16-character
	  string, 'i' an integer, 'd' a double, and so on. For a
	  complete list of data types supported see <a href="#datatypesSupported">table&nbsp;AA.1</a>.
	</p>
      <p>Now, we open an HDF5 file in write mode:
      </p>
      <pre>
fileh = File(filename = "example1.h5", mode = "w")
      </pre>
      <p>and get the object which is the root directory in HDF5 hierarchy:
      </p>
      <pre>
group = fileh.getRootGroup()
      </pre>
      <p>then, create a new table object
      </p>
      <pre>
table = fileh.newTable(group, 'table', Particle(), "Title example")
      </pre>
      <p>get the the Particle instance associated with the table
      </p>
      <pre>
particle = fileh.getRecordObject(table)
      </pre>
      <p>and fill the table with 10 particles
      </p>
      <pre>
for i in xrange(10):
    # First, assign the values to the Particle record
    particle.name  = '%16d' % i
    particle.lati = i 
    particle.longi = i
    particle.pressure = float(i)
    particle.temperature = float(i)
    # This injects the Particle values
    fileh.appendRecord(table, particle)
      </pre>
      <p>and finally, close the file:
      </p>
      <pre>
fileh.close()
      </pre>
      <p>That's it!. We can see here the complete example for a better
	inspection, with a few additional comments:
      </p>
      <pre>
from tables import File, IsRecord

class Particle(IsRecord):
    name        = '16s'  # 16-character String
    lati        = 'i'    # integer
    longi       = 'i'    # integer
    pressure    = 'f'    # float  (single-precision)
    temperature = 'd'    # double (double-precision)

# Open a file in "w"rite mode
fileh = File(name = "example1.h5", mode = "w")
# Get the HDF5 root group
root = fileh.getRootGroup()
# Create a new table
table = fileh.newTable(root, 'table', Particle(), "Title example")
#print "Table name ==&gt;", table._v_name
# Get the record object associated with the table: all three ways are valid
#particle = table.record
particle = fileh.getRecordObject(table)  # This is really an accessor
#particle = fileh.getRecordObject("/table")
# Fill the table with 10 particles
for i in xrange(10):
    # First, assign the values to the Particle record
    particle.name  = 'Particle: %6d' % (i)
    particle.lati = i 
    particle.longi = 10 - i
    particle.pressure = float(i*i)
    particle.temperature = float(i**2)
    # This injects the Record values. Both ways do that.
    #table.appendRecord(particle)      
    fileh.appendRecord(table, particle)      

# Finally, close the file
fileh.close()
      </pre> 

      <p>In <a href="#example1">figure&nbsp;3.1</a> you can see the table we
	have created in this example. You will find in the directory
	<tt class="verb">examples</tt> the working version of the code
	(source file <tt class="verb">example1.py</tt>).
      </p>

      <div class="figure" id="example1"><a name="example1"></a>
	<a target="_blank" href="example1.jpg"><img class="graphics" alt="A simple table in HDF5. (Click for original bitmap)" src="example1-web.jpg"></a>
	<div class="caption" style="width: 200px"><div class="caption-text"><span class="captionlabel">Figure&nbsp;3.1:</span> A simple table in HDF5.</div></div>
      </div>
      </div>

      <div id="secondExample"><a name="secondExample"></a>
	<h2><span class="headlinenumber" id="section3.2"><a name="section3.2"></a>3.2 </span>A somewhat more complex exercise</h2>

      <p class="first">Now, time for a more sophisticated example. Here, we will
	create a couple of directories (groups, in HDF5 jargon)
	hanging directly from the root directory called
	<tt class="verb">Particles</tt> and <tt class="verb">Events</tt>. Then, we will
	put 3 tables in each group; in <tt class="verb">Particles</tt> we will
	put instances of <tt class="verb">Particle</tt> records and in
	<tt class="verb">Events</tt>, instances of <tt class="verb">Event</tt>. After
	that, we will feed the tables with 257 (you will see soon why
	I choose such an "esoteric" number) entries each. Finally, we
	will read the recently created table
	<tt class="verb">/Events/TEvent3</tt> and select some values from it
	using a comprehension list.
      </p>
      <p>Lets go,</p>

      <pre>
from tables import File, IsRecord

class Particle(IsRecord):
    name        = '16s'  # 16-character String
    lati        = 'i'    # integer
    longi       = 'i'    # integer
    pressure    = 'f'    # float  (single-precision)
    temperature = 'd'    # double (double-precision)

class Event(IsRecord):
    name        = '16s'  # 16-character String
    TDCcount    = 'B'    # unsigned char
    ADCcount    = 'H'    # unsigned short
    xcoord      = 'f'    # float  (single-precision)
    ycoord      = 'f'    # float  (single-precision)

# Open a file in "w"rite mode
fileh = File(name = "example2.h5", mode = "w")
# Get the HDF5 root group
root = fileh.getRootGroup()

# Create the groups:
for groupname in ("Particles", "Events"):
    group = fileh.newGroup(root, groupname)

# Now, create and fill the tables in Particles group
gparticles = fileh.getNode("/Particles")
# You can achieve the same result with the next notation
# (it can be convenient and more intuitive in some contexts)
#gparticles = root.Particles
# Create 3 new tables
for tablename in ("TParticle1", "TParticle2", "TParticle3"):
    # Create a table
    table = fileh.newTable("/Particles", tablename, Particle(),
                           "Particles: "+tablename)
    # Get the record object associated with the table:
    particle = fileh.getRecordObject(table)
    # Fill the table with 10 particles
    for i in xrange(257):
        # First, assign the values to the Particle record
        particle.name  = 'Particle: %6d' % (i)
        particle.lati = i 
        particle.longi = 10 - i
        particle.pressure = float(i*i)
        particle.temperature = float(i**2)
        # This injects the Record values
        fileh.appendRecord(table, particle)      

    # Flush the table buffers
    fileh.flushTable(table)

# Now, go for Events:
for tablename in ("TEvent1", "TEvent2", "TEvent3"):
    # Create a table. Look carefully at how we reference the Events group!.
    table = fileh.newTable(root.Events, tablename, Event(),
                           "Events: "+tablename)
    # Get the record object associated with the table:
    event = table.record
    # Fill the table with 10 events
    for i in xrange(257):
        # First, assign the values to the Event record
        event.name  = 'Event: %6d' % (i)
        #event.TDCcount = i
        event.ADCcount = i * 2
        event.xcoor = float(i**2)
        event.ycoord = float(i**4)
        # This injects the Record values
        fileh.appendRecord(table, event)      

    # Flush the buffers
    fileh.flushTable(table)

# Read the records from table "/Events/TEvent3" and select some
e = [ p.TDCcount for p in fileh.readRecords("/Events/TEvent3")
      if p.ADCcount &lt; 20 and 4&lt;= p.TDCcount &lt; 15 ]
print "Last record ==&gt;", p
print "Selected values ==&gt;", e
print "Total selected records ==&gt; ", len(e)

# Finally, close the file (this also will flush all the remaining buffers!)
fileh.close()
      </pre>

      <p>Throughout the comments, you can see that <tt>PyTables</tt> let's you
      do things in, generally, more than one way. I don't know if
      that's good or not, but I'm afraid it is not. This is in part
      due to the fact that <tt>PyTables</tt> is in first stages of development,
      and probably as the API matures, there will be less choices.</p>

      <p>If you have read the code carefully it looks pretty good, but
      it won't work. If you run this example, you will get the next
      error:
      </p>
      <pre>
Traceback (most recent call last):
  File "example2.py", line 68, in ?
    event.xcoor  = float(i**2)
AttributeError: 'Event' object has no attribute 'xcoor'
      </pre>
      <p>This error is saying us that we tried to assign a value to a
	non-existent field in an <tt class="verb">Event</tt> object. By looking
	carefully at the <tt class="verb">Event</tt> attributes, we see that we
	misspelled the <tt class="verb">xcoord</tt> field (we wrote
	<tt class="verb">xcoor</tt> instead). So we correct this in the source,
	and run it again.</p>
      <p>And again, we find another problem:
      </p>
      <pre>
Traceback (most recent call last):
  File "example2.py", line 69, in ?
    table.appendRecord(event)      
  File "/usr/lib/python2.2/site-packages/tables/Table.py", line 210, in appendRecord
    self._v_packedtuples.append(recordObject._f_pack2())
  File "/usr/lib/python2.2/site-packages/tables/IsRecord.py", line 121, in _f_pack2
    self._f_raiseValueError()
  File "/usr/lib/python2.2/site-packages/tables/IsRecord.py", line 130, in 
_f_raiseValueError
    raise ValueError, \
ValueError: Error packing record object: 
 [('ADCcount', 'H', 256), ('TDCcount', 'B', 256), ('name', '16s', 'Event:    256'),
 ('xcoord', 'f', 65536.0), ('ycoord', 'f', 4294967296.0)]
 Error was: ubyte format requires 0&lt;=number&lt;=255
      </pre>
      <p>This other error is saying that one of the records is having
	trouble to be converted to the data types stated in the Event
	class definition. By looking carefully to the record object
	causing the problem, we see that we are trying to assign a
	value of 256 to the 'TDCcount' field which has a 'B' (C
	unsigned char) typecode and the allowed range for it is
	<tt class="verb">0&lt;=TDCcount&lt;=255</tt>. This is a very powerful
	capability to automatically check for ranges: the message
	error is explicit enough to figure out what is happening. In
	this case you can solve the problem by promoting the
	<tt class="verb">TDCcount</tt> to 'H' which is a unsigned 16-bit
	integer, or avoid the mistake you probably made in assigning a
	value greater than 255 to a 'B' typecode.
      </p>
      <p>If we change the line:
      </p>
      <pre>event.TDCcount = i
      </pre>
      <p>by the next one:
      </p>
      <pre>event.TDCcount = i % (1&lt;&lt;8)
      </pre>
      <p>you will see that our problem has disappeared, and the HDF5
	file has been created. As before, you will find in the
	directory <tt class="verb">examples</tt> the working version of the
	code (source file <tt class="verb">example2.py</tt>).
      </p>
      <p>Finally, admire the structure we have created in <a href="#example2">figure&nbsp;3.2</a>.</p>

      <div class="figure" id="example2"><a name="example2"></a>
	<a target="_blank" href="example2.jpg"><img class="graphics" alt="Tables structured in a hierarchical order. (Click for original bitmap)" src="example2-web.jpg"></a>
	<div class="caption" style="width: 200px"><div class="caption-text"><span class="captionlabel">Figure&nbsp;3.2:</span> Tables structured in a hierarchical order.</div></div>
      </div>

      <p>Feel free to visit the rest of examples in directory
        <tt class="verb">examples</tt>, and try to understand them. I've tried
        to make the cases as orthogonal as possible to give you an idea
        of the <tt class="verb">PyTables</tt> capabilities and its way of
        dealing with HDF5 objects.</p>

      </div>
    </div><div>
      <h1 id="chapter4"><a name="chapter4"></a>Chapter&nbsp;4: Library Reference</h1>

      <p class="first">This package implements an important class to deal with HDF5
	files, called <tt class="verb">File</tt> and another one to help
	defining records, with field, type and range checks, which is
	called IsRecord. There exists other important classes called
	<tt class="verb">Group</tt> and <tt class="verb">Table</tt> which do their work
	silently behind the scenes. The user has to be aware of its
	existence, but generally speaking, they won't need to call
	their methods explicitly.
      </p>
      <div id="FileClass"><a name="FileClass"></a>
	<h2><span class="headlinenumber" id="section4.1"><a name="section4.1"></a>4.1 </span>The <em>File</em> class.</h2>

	<p class="first">The <tt class="verb">File</tt> class hosts the most part of <tt>PyTables</tt>
          user interface. It is in charge of create, open, flush and
          close the HDF5 files. In addition it provides accessors to
          functionality present in <tt class="verb">Group</tt> and
          <tt class="verb">Table</tt> classes.
	</p>
	
	<p>This class defines the next methods<a href="#footnote2" name="footnoteback2"><sup>2)</sup></a>:</p>

	<dl>
	  <dt>File(filename, mode="r"):</dt> <dd>This is the
	    constructor and opens an HDF5 file. The supported access
	    modes are: "r" means read-only; no data can be
	    modified. "w" means write; a new file is created, an
	    existing file with the same name is deleted. "a" means
	    append (in analogy with serial files); an existing file is
	    opened for reading and writing, and if the file does not
	    exist it is created. "r+" is similar to "a", but the file
	    must already exist.</dd>
	</dl>

	<dl>
	  <dt>getRootGroup():</dt> <dd>Returns a
	    <tt class="verb">Group</tt> instance that will act as the root
	    group in the hierarchical tree. If file is opened in "r",
	    "r+" or "a" mode, and the file already exists, this method
	    dynamically builds a python object tree emulating the
	    structure present on file. It <em>must</em> be always
	    called after the File object is constructed.</dd>
	</dl>

	<dl>
	  <dt>newTable(where, name, tableTitle = "", compress = 1,
	    expectedrows = 10000):</dt> <dd>Returns a new
	    <tt class="verb">Table</tt> instance with name <em>name</em> in
	    <em>where</em> location.  <em>where</em> parameter can be
	    a path string, or another group instance.  Other optional
	    parameters are: <em>tableTitle</em> sets a
	    <tt class="verb">TITLE</tt> attribute on the HDF5 table entity.
	    <em>compress</em> is a boolean option and specifies if
	    data compression will be enabled or
	    not. <em>expectedrows</em> is an user estimate about the
	    number of records that will be on table. This parameter is
	    used to set important internal parameters, as buffer size
	    or HDF5 chunk size. If not provided, the default value is
	    appropriate to tables until 100 KB in size. If you plan to
	    save bigger tables by providing a guess to <tt>PyTables</tt> will
	    optimize the HDF5 B-Tree creation and management process
	    time and memory used.</dd>
	</dl>

	<dl>
	  <dt>newGroup(where, name):</dt> <dd>Returns a new
	    <tt class="verb">Group</tt> instance with name <em>name</em> in
	    <em>where</em> location.  <em>where</em> parameter can be
	    a path (for example <em>"/Particles/TParticle1"</em>
	    string, or another <tt class="verb">Group</tt> instance.</dd>
	</dl>

	<dl>
	  <dt>getNode(where):</dt> <dd>Returns the object node
	    (<tt class="verb">Group</tt> or Leave) in <em>where</em>
	    location. <em>where</em> can be a path string,
	    <tt class="verb">Group</tt> instance or a <tt class="verb">Table</tt>
	    instance.</dd>
	</dl>

	<dl>
	  <dt>getGroup(where):</dt> <dd>Returns the object group
	    in <em>where</em> location. <em>where</em> can be a path
	    string or a <tt class="verb">Group</tt> instance. If <em>where</em>
	    doesn't point to a <tt class="verb">Group</tt>, a ValueError error
	    is raised.</dd>
	</dl>

	<dl>
	  <dt>getTable(where):</dt> <dd>Returns the object table
	    in <em>where</em> location. <em>where</em> can be a path
	    string or a <tt class="verb">Table</tt> instance. If <em>where</em>
	    doesn't point to a <tt class="verb">Table</tt>, a ValueError error
	    is raised.</dd>
	</dl>

	<dl>
	  <dt>listNodes(where):</dt> <dd>Returns all the object
	    nodes (groups or tables) hanging from
	    <em>where</em>. <em>where</em> can be a path string or
	    group instance.</dd>
	</dl>

	<dl>
	  <dt>listGroups(where):</dt> <dd>Returns all the groups
	    hanging from <em>where</em>. <em>where</em> can be a path
	    string or group instance.</dd>
	</dl>

	<dl>
	  <dt>listLeaves(where):</dt> <dd>Returns all the Leaves
	    objects hanging from <em>where</em>. <em>where</em> can be
	    a path string or group instance.</dd>
	</dl>

	<dl>
	  <dt>walkGroups(where):</dt> <dd>Recursively obtains
	    groups (not leaves) hanging from <em>where</em>.</dd>
	</dl>

	<dl>
	  <dt>getRecordObject(table):</dt> <dd>Returns the
	    record object associated with the <em>table</em>.
	    <em>table</em> can be a path string or table
	    instance.</dd>
	</dl>

	<dl>
	  <dt>appendRecord(table, record):</dt> <dd>Append the
	    <em>record</em> object to the <em>table</em> output
	    buffer. <em>table</em> can be a path string or table
	    instance.</dd>
	</dl>

	<dl>
	  <dt>readRecords(table):</dt> <dd>Generator thats return
	    a Record instance from a <em>table</em> object each time
	    it is called. <em>table</em> can be a path string or table
	    instance.</dd>
	</dl>

	<dl>
	  <dt>flushTable(table):</dt> <dd>Flush the table object
	    to disk. <em>table</em> can be a path string or table
	    instance.</dd>
	</dl>

	<dl>
	  <dt>flush():</dt> <dd>Flush the buffers for all the
	    objects on the HDF5 file tree.</dd>
	</dl>

	<dl>
	  <dt>close():</dt> <dd>Flush all the objects in HDF5
	    file and close the file.</dd>
	</dl>

      </div>

      <div id="IsRecordClass"><a name="IsRecordClass"></a>
	<h2><span class="headlinenumber" id="section4.2"><a name="section4.2"></a>4.2 </span>The <em>IsRecord</em> class.</h2>

	<p class="first">This class is in fact a so-called <em>metaclass</em>
	  object. There is nothing special on it, except that their
	  subclasses attributes are transformed during its
	  construction phase, and new methods for the are defined
	  based on the values of the attributes. In that way, we can
	  <em>force</em> the resulting instance to only accept
	  assignments on the declared attributes (in fact, it has a
	  few more, but they are hidden with prefixes like <tt>"__"</tt>, <tt>"_v_"</tt> or <tt>"_f_"</tt>, so please, don't use attributes
	  names starting with these prefixes). If you try to do an
	  assignment to a non-declared attribute, <tt>PyTables</tt> will raise
	  an error.</p>

	<p>To use such a particular class, you have to declare a
	  descendent class from <em>IsRecord</em>, with many
	  attributes as fields you want in your record. To declare
	  their types, you simply assign to these attributes their
	  <em>typecode</em>. That's all, from now on, you can
	  instantiate objects from you new class and use them as a
	  very flexible record object with safe features like
	  automatic name field, data type and range checks (see the
	  <a href="#secondExample">section&nbsp;3.2</a> for an example on
	  how it works).
	</p>
	<p>See the <a href="#datatypesSupported">appendix&nbsp;AA.1</a> for
	  a relation of data types supported in a <tt>IsRecord</tt> class declaration.
	</p>

      </div>
    </div><div>
      <div id="datatypesSupported"><a name="datatypesSupported"></a>
	<h1 id="chapterA"><a name="chapterA"></a>Appendix&nbsp;A: <tt>PyTables</tt> Supported Data Types</h1>
        <p class="first">The supported data types are the same that are supported by
	  the <tt>array</tt> module in Python,
	  with some additions, which will be briefly discussed
	  shortly. The typecodes for the supported data types are
	  listed on <a href="#datatypesSupported">table&nbsp;AA.1</a>.
	</p>

	<div class="table" id="datatypesSupported"><a name="datatypesSupported"></a>
	  <table class="tabular" cellspacing="0" cellpadding="5" frame="hsides" rules="groups"><caption><span class="captionlabel">Table&nbsp;A.1:</span> Data types supported by <tt>PyTables</tt></caption><col align="left"><col align="left"><col align="left"><col align="center"><col align="left">
	  <thead><tr><td colspan="5" class="thickline"></td></tr>
	    <tr><th align="left">Type Code</th><th align="left">Description</th><th align="left">C Type</th><th align="center">Size (in bytes)</th><th align="left">Python Counterpart</th></tr>
	  <tr><td colspan="5" class="thinline"></td></tr></thead>
	  <tbody>
	    <tr><td align="left">'c'</td><td align="left">8-bit character</td><td align="left">char</td><td align="center">1</td><td align="left">String of lenght 1</td></tr>
	    <tr><td align="left">'b'</td><td align="left">8-bit integer</td><td align="left">signed char</td><td align="center">1</td><td align="left">Integer</td></tr>
	    <tr><td align="left">'B'</td><td align="left">8-bit unsigned integer</td><td align="left">unsigned char</td><td align="center">1</td><td align="left">Integer</td></tr>
	    <tr><td align="left">'h'</td><td align="left">16-bit integer</td><td align="left">short</td><td align="center">2</td><td align="left">Integer</td></tr>
	    <tr><td align="left">'H'</td><td align="left">16-bit unsigned integer</td><td align="left">unsigned short</td><td align="center">2</td><td align="left">Integer</td></tr>
	    <tr><td align="left">'i'</td><td align="left">integer</td><td align="left">int</td><td align="center">4 or 8</td><td align="left">Integer</td></tr>
	    <tr><td align="left">'I'</td><td align="left">unsigned integer</td><td align="left">unsigned int</td><td align="center">4 or 8</td><td align="left">Long</td></tr>
	    <tr><td align="left">'l'</td><td align="left">long integer</td><td align="left">long</td><td align="center">4 or 8</td><td align="left">Integer</td></tr>
	    <tr><td align="left">'L'</td><td align="left">unsigned long integer</td><td align="left">unsigned long</td><td align="center">4 or 8</td><td align="left">Long</td></tr>
	    <tr><td align="left">'q'</td><td align="left">long long integer</td><td align="left">long long</td><td align="center">8</td><td align="left">Long</td></tr>
	    <tr><td align="left">'Q'</td><td align="left">unsigned long long integer</td><td align="left">unsigned long long</td><td align="center">8</td><td align="left">Long</td></tr>
	    <tr><td align="left">'f'</td><td align="left">single-precision float</td><td align="left">float</td><td align="center">4</td><td align="left">Float</td></tr>
	    <tr><td align="left">'d'</td><td align="left">double-precision float</td><td align="left">double</td><td align="center">8</td><td align="left">Float</td></tr>
	    <tr><td align="left">'s'</td><td align="left">arbitrary lenght string</td><td align="left">char[]</td><td align="center">*</td><td align="left">String</td></tr>
	  <tr><td colspan="5" class="thickline"></td></tr></tbody>
	</table>
	  
	</div>

	<p>The additions to the array module typecodes are the <tt>'q'</tt>, <tt>'Q'</tt>
	  and <tt>'s'</tt>.  The <tt>'q'</tt> and <tt>'Q'</tt> conversion codes are available in
	  native mode only if the platform C compiler supports C long
	  long, or, on Windows, __int64. They are always available in
	  standard modes. The <tt>'s'</tt>
	  typecode can be preceded by an integer to indicate the
	  maximum length of the string, so <tt>'16s'</tt> represents a 16-byte string.</p>

	<p>Also note that when the <tt>'I'</tt>
	  and <tt>'L'</tt> codetypes are used in
	  records, Python uses internally <tt>Long</tt> integers to represent them, that
	  can (or cannot, depending on what you are trying to do) be
	  a source of inefficiency in your code.</p>
      </div>
    </div>

  
    
  
<hr align="left" noshade="true" style="text-align: left; width: 20%; color: black"><div class="footnote"><a name="footnote1" href="#footnoteback1"><sup>1)</sup></a>&nbsp;Well, I didn't actually test that in
	    real world, but if you do, please, tell
	    me.</div><div class="footnote"><a name="footnote2" href="#footnoteback2"><sup>2)</sup></a>&nbsp;On the
	    following, the term <tt class="verb">Leaf</tt> will refer to a
	    <tt class="verb">Table</tt> instance. Right now the only supported
	    <tt class="verb">Leaf</tt> object is <tt class="verb">Table</tt>, but that will
	    change in the short future.</div></div></body></html>