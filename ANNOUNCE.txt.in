===========================
 Announcing PyTables @VERSION@
===========================

This is a new major release of PyTables. Blurb, blurb, blurb...

Go to the (new) PyTables web site for downloading the beast:
http://www.pytables.org/

or keep reading for more info about the new features and bugs fixed.


Changes more in depth
=====================

Improvements:

- NumPy is finally at the core! That means that PyTables no longer needs
  numarray in order to operate, although it continues to be supported
  (as well as Numeric). This also means that you should be able to run
  PyTables in scenarios combining Python2.5 and 64-platforms (these are
  a source of problems with numarray/Numeric because they don't support
  this combination yet).

- Most of the operations in PyTables has experimented noticeably
  speed-ups (sometimes up to 2x, like in pythonical table selections) as
  a consequence of using NumPy internally.

- numexpr has been integrated in all in-kernel selections. So, now it is
  possible to perform complex selections like:

res = [ row['var3'] for row in table.where('(var2 < 20) | (var1 == "sas")') ]

  or:

cplx_cond = '((%s<=col5) & (col2<=%s)) | (sqrt(col1+3.1*col2+col3*col4)>3)'
res = [ row['var3'] for row in table.where('cplx_cond' % (inf, sup)) ]

  and run them at full C-speed (or even more, due to the cache-tuned
  computing kernel of numexpr).

- Row.__getitem__() now understands extended sliced notation for
  specifying field positions. So now, you can do things like:

res = [ row[4] for row in table if row[1] < 20 ]
res = [ row[:] for row in table if row['var2'] < 20 ]
res = [ row[1::2] for row in table.iterrows(2, 3000, 3) ]

in addition to the classical:

res = [ row['var3'] for row in table.where('var2 < 20') ]

- Row has received a new method called ``fetch_all_rows`` in order to
  easily retrieve all the fields of a row in situations like:

[row.fetch_all_rows() for row in table.where('column1 < 0.3')]

- Now, all the data that is read from disk is converted, if necessary,
  to the native byteorder of the hosting machine (before, this only
  happened with Table objects). This should help to accelerate apps that
  have to do computations with data generated in platforms with a
  byteorder different than the user machine.

- All the leaf constructors have received a new pararameter called
  'byteorder' that lets the user to specify the byteorder of his data
  *on disk*. This effectively allows to create datasets in other
  byteorders than the native platform.

Bug fixes:

- As mentioned above, the fact that NumPy is at the core makes that
  certain bizarre interactions between NumPy scalars like:

>>> numarray.array([1980291274, 4006003351], "i8") == numpy.uint32(4006003351)
array([0, 0], type=Bool)    # WRONG!

  doesn't affect the behaviour of table selections anymore.  Fixes
  http://www.pytables.org/trac/ticket/29.

- Did I mentioned that PyTables 2.0 can be safely used in 64-bit
  platforms in combination with Python 2.5? ;)

Deprecated features:

- Not much, really. Please, see ``RELEASE-NOTES.txt`` file.

Backward-incompatible changes:

- Many. Please, see ``RELEASE-NOTES.txt`` file.


Important note for Windows users
================================

In order to keep PyTables happy, you will need to get the HDF5 library
compiled for MSVC 7.1, aka .NET 2003.  It can be found at:
ftp://ftp.ncsa.uiuc.edu/HDF/HDF5/current/bin/windows/5-165-win-net.ZIP

Please, remind that, from PyTables 2.0 on, Python 2.3 (and lesser) is
not supported anymore.


What it is
==========

**PyTables** is a package for managing hierarchical datasets and
designed to efficiently cope with extremely large amounts of data (with
support for full 64-bit file addressing).  It features an
object-oriented interface that, combined with C extensions for the
performance-critical parts of the code, makes it a very easy-to-use tool
for high performance data storage and retrieval.

PyTables runs on top of the HDF5 library and numarray (but NumPy and
Numeric are also supported) package for achieving maximum throughput and
convenient use.

Besides, PyTables I/O for table objects is buffered, implemented in C
and carefully tuned so that you can reach much better performance with
PyTables than with your own home-grown wrappings to the HDF5 library.
PyTables sports indexing capabilities as well, allowing doing selections
in tables exceeding one billion of rows in just seconds.


Platforms
=========

This version has been extensively checked on quite a few platforms, like
Linux on Intel32 (Pentium), Win on Intel32 (Pentium), Linux on Intel64
(Itanium2), FreeBSD on AMD64 (Opteron), Linux on PowerPC (and PowerPC64)
and MacOSX on PowerPC.  For other platforms, chances are that the code
can be easily compiled and run without further issues.  Please, contact
us in case you are experiencing problems.


Resources
=========

Go to the PyTables web site for more details:

http://www.pytables.org

About the HDF5 library:

http://hdf.ncsa.uiuc.edu/HDF5/

About numarray:

http://www.stsci.edu/resources/software_hardware/numarray

To know more about the company behind the PyTables development, see:

http://www.carabos.com/


Acknowledgments
===============

Thanks to various the users who provided feature improvements, patches,
bug reports, support and suggestions.  See the ``THANKS`` file in the
distribution package for a (incomplete) list of contributors.  Many
thanks also to SourceForge who have helped to make and distribute this
package!  And last but not least, a big thank you to THG
(http://www.hdfgroup.org/) for sponsoring many of the new features
recently introduced in PyTables.


Share your experience
=====================

Let us know of any bugs, suggestions, gripes, kudos, etc. you may
have.


----

  **Enjoy data!**

  -- The PyTables Team

.. Local Variables:
.. mode: text
.. coding: utf-8
.. fill-column: 72
.. End:
